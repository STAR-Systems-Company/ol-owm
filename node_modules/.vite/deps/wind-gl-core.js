import {
  BlendType,
  DataTexture,
  EventEmitter,
  Geometry,
  Mesh,
  Program,
  Raf,
  RenderTarget,
  Texture,
  Vector2,
  index
} from "./chunk-SEC2ZWGE.js";
import "./chunk-XR5TTCGL.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/wind-gl-core/node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/wind-gl-core/node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut2;
    module.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects2(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx) return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e;
            else list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects2(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b)) return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/wind-gl-core/dist/wind-gl-core.esm.js
var import_earcut = __toESM(require_earcut());
var shared;
var worker;
var wgw;
function define(_, chunk) {
  if (!shared) {
    shared = chunk;
  } else if (!worker) {
    worker = chunk;
  } else {
    var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
    var sharedChunk = {};
    shared(sharedChunk);
    wgw = chunk(sharedChunk);
    if (typeof window !== "undefined") {
      wgw.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
    }
  }
}
define(["exports"], function(exports) {
  function asyncAll(array, fn, callback) {
    if (!array.length) {
      return callback(null, []);
    }
    let remaining = array.length;
    const results = new Array(array.length);
    let error = null;
    array.forEach((item, i2) => {
      fn(item, (err, result) => {
        if (err) {
          error = err;
        }
        results[i2] = result;
        if (--remaining === 0)
          callback(error, results);
      });
    });
  }
  function isWorker() {
    return typeof WorkerGlobalScope !== "undefined" && typeof self !== "undefined" && self instanceof WorkerGlobalScope;
  }
  const warnOnceHistory = {};
  function warnOnce(message) {
    if (!warnOnceHistory[message]) {
      if (typeof console !== "undefined")
        console.warn(message);
      warnOnceHistory[message] = true;
    }
  }
  function isImageBitmap2(image) {
    return typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
  }
  function isArrayBuffer(value) {
    return value && typeof ArrayBuffer !== "undefined" && (value instanceof ArrayBuffer || value.constructor && value.constructor.name === "ArrayBuffer");
  }
  let _isSafari = null;
  function isSafari(scope) {
    if (_isSafari == null) {
      const userAgent = scope.navigator ? scope.navigator.userAgent : null;
      _isSafari = !!scope.safari || !!(userAgent && (/\b(iPad|iPhone|iPod)\b/.test(userAgent) || !!userAgent.match("Safari") && !userAgent.match("Chrome")));
    }
    return _isSafari;
  }
  function nullFunction() {
  }
  const uidCounters = {};
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] ?? 0;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
  }
  function typeOf(value) {
    return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
  }
  function isFunction2(v2) {
    return typeOf(v2) === "function";
  }
  const getReferrer = isWorker() ? () => self.worker && self.worker.referrer : () => (window.location.protocol === "blob:" ? window.parent : window).location.href;
  function arrayBufferToImageBitmap(data, callback) {
    const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
    createImageBitmap(blob).then((imgBitmap) => {
      callback(null, imgBitmap);
    }).catch((e2) => {
      callback(
        new Error(
          `Could not load image because of ${e2.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
        )
      );
    });
  }
  const transparentPngUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
  function arrayBufferToImage(data, callback) {
    const img = new Image();
    img.onload = () => {
      callback(null, img);
      URL.revokeObjectURL(img.src);
      img.onload = null;
      window.requestAnimationFrame(() => {
        img.src = transparentPngUrl;
      });
    };
    img.onerror = () => callback(
      new Error(
        "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
      )
    );
    const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
    img.src = data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
  }
  function unflatten(valuesInOneDimension, size) {
    const { height, width } = size;
    const valuesInTwoDimensions = [];
    for (let y2 = 0; y2 < height; y2++) {
      const start = y2 * width;
      const end = start + width;
      valuesInTwoDimensions.push(valuesInOneDimension.slice(start, end));
    }
    return valuesInTwoDimensions;
  }
  function parseMetedata(str) {
    const array = str.split(",");
    const res = array.map((item) => {
      const kv = item.split(":");
      return {
        [kv[0]]: isNaN(parseFloat(kv[1])) ? kv[1] : parseFloat(kv[1])
      };
    });
    return res.reduce((pre, cur) => Object.assign({}, pre, cur), {});
  }
  var utils = Object.freeze({
    __proto__: null,
    arrayBufferToImage,
    arrayBufferToImageBitmap,
    asyncAll,
    getReferrer,
    isArrayBuffer,
    isFunction: isFunction2,
    isImageBitmap: isImageBitmap2,
    isSafari,
    isWorker,
    nullFunction,
    parseMetedata,
    typeOf,
    uid,
    unflatten,
    warnOnce
  });
  function e(e2, t2, i2) {
    return t2 in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
  }
  var t = "undefined" != typeof self ? self : global;
  const i = "undefined" != typeof navigator, s = i && "undefined" == typeof HTMLImageElement, n = !("undefined" == typeof global || "undefined" == typeof process || !process.versions || !process.versions.node), r = t.Buffer, a = t.BigInt, o = !!r, h = (e2) => f(e2) ? void 0 : e2, l = (e2) => void 0 !== e2;
  function f(e2) {
    return void 0 === e2 || (e2 instanceof Map ? 0 === e2.size : 0 === Object.values(e2).filter(l).length);
  }
  function u(e2) {
    let t2 = new Error(e2);
    throw delete t2.stack, t2;
  }
  function d(e2) {
    return "" === (e2 = function(e3) {
      for (; e3.endsWith("\0"); )
        e3 = e3.slice(0, -1);
      return e3;
    }(e2).trim()) ? void 0 : e2;
  }
  function c(e2) {
    let t2 = function(e3) {
      let t3 = 0;
      return e3.ifd0.enabled && (t3 += 1024), e3.exif.enabled && (t3 += 2048), e3.makerNote && (t3 += 2048), e3.userComment && (t3 += 1024), e3.gps.enabled && (t3 += 512), e3.interop.enabled && (t3 += 100), e3.ifd1.enabled && (t3 += 1024), t3 + 2048;
    }(e2);
    return e2.jfif.enabled && (t2 += 50), e2.xmp.enabled && (t2 += 2e4), e2.iptc.enabled && (t2 += 14e3), e2.icc.enabled && (t2 += 6e3), t2;
  }
  const g = (e2) => String.fromCharCode.apply(null, e2), p = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
  function m(e2) {
    return p ? p.decode(e2) : o ? Buffer.from(e2).toString("utf8") : decodeURIComponent(escape(g(e2)));
  }
  class y {
    static from(e2, t2) {
      return e2 instanceof this && e2.le === t2 ? e2 : new y(e2, void 0, void 0, t2);
    }
    constructor(e2, t2 = 0, i2, s2) {
      if ("boolean" == typeof s2 && (this.le = s2), Array.isArray(e2) && (e2 = new Uint8Array(e2)), 0 === e2)
        this.byteOffset = 0, this.byteLength = 0;
      else if (e2 instanceof ArrayBuffer) {
        void 0 === i2 && (i2 = e2.byteLength - t2);
        let s3 = new DataView(e2, t2, i2);
        this._swapDataView(s3);
      } else if (e2 instanceof Uint8Array || e2 instanceof DataView || e2 instanceof y) {
        void 0 === i2 && (i2 = e2.byteLength - t2), (t2 += e2.byteOffset) + i2 > e2.byteOffset + e2.byteLength && u("Creating view outside of available memory in ArrayBuffer");
        let s3 = new DataView(e2.buffer, t2, i2);
        this._swapDataView(s3);
      } else if ("number" == typeof e2) {
        let t3 = new DataView(new ArrayBuffer(e2));
        this._swapDataView(t3);
      } else
        u("Invalid input argument for BufferView: " + e2);
    }
    _swapArrayBuffer(e2) {
      this._swapDataView(new DataView(e2));
    }
    _swapBuffer(e2) {
      this._swapDataView(new DataView(e2.buffer, e2.byteOffset, e2.byteLength));
    }
    _swapDataView(e2) {
      this.dataView = e2, this.buffer = e2.buffer, this.byteOffset = e2.byteOffset, this.byteLength = e2.byteLength;
    }
    _lengthToEnd(e2) {
      return this.byteLength - e2;
    }
    set(e2, t2, i2 = y) {
      return e2 instanceof DataView || e2 instanceof y ? e2 = new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2)), e2 instanceof Uint8Array || u("BufferView.set(): Invalid data argument."), this.toUint8().set(e2, t2), new i2(this, t2, e2.byteLength);
    }
    subarray(e2, t2) {
      return t2 = t2 || this._lengthToEnd(e2), new y(this, e2, t2);
    }
    toUint8() {
      return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
    }
    getUint8Array(e2, t2) {
      return new Uint8Array(this.buffer, this.byteOffset + e2, t2);
    }
    getString(e2 = 0, t2 = this.byteLength) {
      return m(this.getUint8Array(e2, t2));
    }
    getLatin1String(e2 = 0, t2 = this.byteLength) {
      let i2 = this.getUint8Array(e2, t2);
      return g(i2);
    }
    getUnicodeString(e2 = 0, t2 = this.byteLength) {
      const i2 = [];
      for (let s2 = 0; s2 < t2 && e2 + s2 < this.byteLength; s2 += 2)
        i2.push(this.getUint16(e2 + s2));
      return g(i2);
    }
    getInt8(e2) {
      return this.dataView.getInt8(e2);
    }
    getUint8(e2) {
      return this.dataView.getUint8(e2);
    }
    getInt16(e2, t2 = this.le) {
      return this.dataView.getInt16(e2, t2);
    }
    getInt32(e2, t2 = this.le) {
      return this.dataView.getInt32(e2, t2);
    }
    getUint16(e2, t2 = this.le) {
      return this.dataView.getUint16(e2, t2);
    }
    getUint32(e2, t2 = this.le) {
      return this.dataView.getUint32(e2, t2);
    }
    getFloat32(e2, t2 = this.le) {
      return this.dataView.getFloat32(e2, t2);
    }
    getFloat64(e2, t2 = this.le) {
      return this.dataView.getFloat64(e2, t2);
    }
    getFloat(e2, t2 = this.le) {
      return this.dataView.getFloat32(e2, t2);
    }
    getDouble(e2, t2 = this.le) {
      return this.dataView.getFloat64(e2, t2);
    }
    getUintBytes(e2, t2, i2) {
      switch (t2) {
        case 1:
          return this.getUint8(e2, i2);
        case 2:
          return this.getUint16(e2, i2);
        case 4:
          return this.getUint32(e2, i2);
        case 8:
          return this.getUint64 && this.getUint64(e2, i2);
      }
    }
    getUint(e2, t2, i2) {
      switch (t2) {
        case 8:
          return this.getUint8(e2, i2);
        case 16:
          return this.getUint16(e2, i2);
        case 32:
          return this.getUint32(e2, i2);
        case 64:
          return this.getUint64 && this.getUint64(e2, i2);
      }
    }
    toString(e2) {
      return this.dataView.toString(e2, this.constructor.name);
    }
    ensureChunk() {
    }
  }
  function b(e2, t2) {
    u(`${e2} '${t2}' was not loaded, try using full build of exifr.`);
  }
  class w extends Map {
    constructor(e2) {
      super(), this.kind = e2;
    }
    get(e2, t2) {
      return this.has(e2) || b(this.kind, e2), t2 && (e2 in t2 || function(e3, t3) {
        u(`Unknown ${e3} '${t3}'.`);
      }(this.kind, e2), t2[e2].enabled || b(this.kind, e2)), super.get(e2);
    }
    keyList() {
      return Array.from(this.keys());
    }
  }
  var S = new w("file parser"), k = new w("segment parser"), v = new w("file reader");
  let O = t.fetch;
  function x(e2, t2) {
    return (s2 = e2).startsWith("data:") || s2.length > 1e4 ? P(e2, t2, "base64") : n && e2.includes("://") ? C(e2, t2, "url", A) : n ? P(e2, t2, "fs") : i ? C(e2, t2, "url", A) : void u("Invalid input argument");
    var s2;
  }
  async function C(e2, t2, i2, s2) {
    return v.has(i2) ? P(e2, t2, i2) : s2 ? async function(e3, t3) {
      let i3 = await t3(e3);
      return new y(i3);
    }(e2, s2) : void u(`Parser ${i2} is not loaded`);
  }
  async function P(e2, t2, i2) {
    let s2 = new (v.get(i2))(e2, t2);
    return await s2.read(), s2;
  }
  const A = (e2) => O(e2).then((e3) => e3.arrayBuffer()), U = (e2) => new Promise((t2, i2) => {
    let s2 = new FileReader();
    s2.onloadend = () => t2(s2.result || new ArrayBuffer()), s2.onerror = i2, s2.readAsArrayBuffer(e2);
  });
  class I extends Map {
    get tagKeys() {
      return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
    }
    get tagValues() {
      return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
    }
  }
  function B(e2, t2, i2) {
    let s2 = new I();
    for (let [e3, t3] of i2)
      s2.set(e3, t3);
    if (Array.isArray(t2))
      for (let i3 of t2)
        e2.set(i3, s2);
    else
      e2.set(t2, s2);
    return s2;
  }
  const L = /* @__PURE__ */ new Map(), D = /* @__PURE__ */ new Map(), T = /* @__PURE__ */ new Map(), z = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"], N = ["jfif", "xmp", "icc", "iptc", "ihdr"], V = ["tiff", ...N], M = ["ifd0", "ifd1", "exif", "gps", "interop"], E = [...V, ...M], R = ["makerNote", "userComment"], j = ["translateKeys", "translateValues", "reviveValues", "multiSegment"], G = [...j, "sanitize", "mergeOutput", "silentErrors"];
  class H {
    get translate() {
      return this.translateKeys || this.translateValues || this.reviveValues;
    }
  }
  class _ extends H {
    get needed() {
      return this.enabled || this.deps.size > 0;
    }
    constructor(t2, i2, s2, n2) {
      if (super(), e(this, "enabled", false), e(this, "skip", /* @__PURE__ */ new Set()), e(this, "pick", /* @__PURE__ */ new Set()), e(this, "deps", /* @__PURE__ */ new Set()), e(this, "translateKeys", false), e(this, "translateValues", false), e(this, "reviveValues", false), this.key = t2, this.enabled = i2, this.parse = this.enabled, this.applyInheritables(n2), this.canBeFiltered = M.includes(t2), this.canBeFiltered && (this.dict = L.get(t2)), void 0 !== s2)
        if (Array.isArray(s2))
          this.parse = this.enabled = true, this.canBeFiltered && s2.length > 0 && this.translateTagSet(s2, this.pick);
        else if ("object" == typeof s2) {
          if (this.enabled = true, this.parse = false !== s2.parse, this.canBeFiltered) {
            let { pick: e2, skip: t3 } = s2;
            e2 && e2.length > 0 && this.translateTagSet(e2, this.pick), t3 && t3.length > 0 && this.translateTagSet(t3, this.skip);
          }
          this.applyInheritables(s2);
        } else
          true === s2 || false === s2 ? this.parse = this.enabled = s2 : u(`Invalid options argument: ${s2}`);
    }
    applyInheritables(e2) {
      let t2, i2;
      for (t2 of j)
        i2 = e2[t2], void 0 !== i2 && (this[t2] = i2);
    }
    translateTagSet(e2, t2) {
      if (this.dict) {
        let i2, s2, { tagKeys: n2, tagValues: r2 } = this.dict;
        for (i2 of e2)
          "string" == typeof i2 ? (s2 = r2.indexOf(i2), -1 === s2 && (s2 = n2.indexOf(Number(i2))), -1 !== s2 && t2.add(Number(n2[s2]))) : t2.add(i2);
      } else
        for (let i2 of e2)
          t2.add(i2);
    }
    finalizeFilters() {
      !this.enabled && this.deps.size > 0 ? (this.enabled = true, q(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && q(this.pick, this.deps);
    }
  }
  var W = { jfif: false, tiff: true, xmp: false, icc: false, iptc: false, ifd0: true, ifd1: false, exif: true, gps: true, interop: false, ihdr: void 0, makerNote: false, userComment: false, multiSegment: false, skip: [], pick: [], translateKeys: true, translateValues: true, reviveValues: true, sanitize: true, mergeOutput: true, silentErrors: true, chunked: true, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 }, $ = /* @__PURE__ */ new Map();
  class K extends H {
    static useCached(e2) {
      let t2 = $.get(e2);
      return void 0 !== t2 || (t2 = new this(e2), $.set(e2, t2)), t2;
    }
    constructor(e2) {
      super(), true === e2 ? this.setupFromTrue() : void 0 === e2 ? this.setupFromUndefined() : Array.isArray(e2) ? this.setupFromArray(e2) : "object" == typeof e2 ? this.setupFromObject(e2) : u(`Invalid options argument ${e2}`), void 0 === this.firstChunkSize && (this.firstChunkSize = i ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = false), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
    }
    setupFromUndefined() {
      let e2;
      for (e2 of z)
        this[e2] = W[e2];
      for (e2 of G)
        this[e2] = W[e2];
      for (e2 of R)
        this[e2] = W[e2];
      for (e2 of E)
        this[e2] = new _(e2, W[e2], void 0, this);
    }
    setupFromTrue() {
      let e2;
      for (e2 of z)
        this[e2] = W[e2];
      for (e2 of G)
        this[e2] = W[e2];
      for (e2 of R)
        this[e2] = true;
      for (e2 of E)
        this[e2] = new _(e2, true, void 0, this);
    }
    setupFromArray(e2) {
      let t2;
      for (t2 of z)
        this[t2] = W[t2];
      for (t2 of G)
        this[t2] = W[t2];
      for (t2 of R)
        this[t2] = W[t2];
      for (t2 of E)
        this[t2] = new _(t2, false, void 0, this);
      this.setupGlobalFilters(e2, void 0, M);
    }
    setupFromObject(e2) {
      let t2;
      for (t2 of (M.ifd0 = M.ifd0 || M.image, M.ifd1 = M.ifd1 || M.thumbnail, Object.assign(this, e2), z))
        this[t2] = Y(e2[t2], W[t2]);
      for (t2 of G)
        this[t2] = Y(e2[t2], W[t2]);
      for (t2 of R)
        this[t2] = Y(e2[t2], W[t2]);
      for (t2 of V)
        this[t2] = new _(t2, W[t2], e2[t2], this);
      for (t2 of M)
        this[t2] = new _(t2, W[t2], e2[t2], this.tiff);
      this.setupGlobalFilters(e2.pick, e2.skip, M, E), true === e2.tiff ? this.batchEnableWithBool(M, true) : false === e2.tiff ? this.batchEnableWithUserValue(M, e2) : Array.isArray(e2.tiff) ? this.setupGlobalFilters(e2.tiff, void 0, M) : "object" == typeof e2.tiff && this.setupGlobalFilters(e2.tiff.pick, e2.tiff.skip, M);
    }
    batchEnableWithBool(e2, t2) {
      for (let i2 of e2)
        this[i2].enabled = t2;
    }
    batchEnableWithUserValue(e2, t2) {
      for (let i2 of e2) {
        let e3 = t2[i2];
        this[i2].enabled = false !== e3 && void 0 !== e3;
      }
    }
    setupGlobalFilters(e2, t2, i2, s2 = i2) {
      if (e2 && e2.length) {
        for (let e3 of s2)
          this[e3].enabled = false;
        let t3 = X(e2, i2);
        for (let [e3, i3] of t3)
          q(this[e3].pick, i3), this[e3].enabled = true;
      } else if (t2 && t2.length) {
        let e3 = X(t2, i2);
        for (let [t3, i3] of e3)
          q(this[t3].skip, i3);
      }
    }
    filterNestedSegmentTags() {
      let { ifd0: e2, exif: t2, xmp: i2, iptc: s2, icc: n2 } = this;
      this.makerNote ? t2.deps.add(37500) : t2.skip.add(37500), this.userComment ? t2.deps.add(37510) : t2.skip.add(37510), i2.enabled || e2.skip.add(700), s2.enabled || e2.skip.add(33723), n2.enabled || e2.skip.add(34675);
    }
    traverseTiffDependencyTree() {
      let { ifd0: e2, exif: t2, gps: i2, interop: s2 } = this;
      s2.needed && (t2.deps.add(40965), e2.deps.add(40965)), t2.needed && e2.deps.add(34665), i2.needed && e2.deps.add(34853), this.tiff.enabled = M.some((e3) => true === this[e3].enabled) || this.makerNote || this.userComment;
      for (let e3 of M)
        this[e3].finalizeFilters();
    }
    get onlyTiff() {
      return !N.map((e2) => this[e2].enabled).some((e2) => true === e2) && this.tiff.enabled;
    }
    checkLoadedPlugins() {
      for (let e2 of V)
        this[e2].enabled && !k.has(e2) && b("segment parser", e2);
    }
  }
  function X(e2, t2) {
    let i2, s2, n2, r2, a2 = [];
    for (n2 of t2) {
      for (r2 of (i2 = L.get(n2), s2 = [], i2))
        (e2.includes(r2[0]) || e2.includes(r2[1])) && s2.push(r2[0]);
      s2.length && a2.push([n2, s2]);
    }
    return a2;
  }
  function Y(e2, t2) {
    return void 0 !== e2 ? e2 : void 0 !== t2 ? t2 : void 0;
  }
  function q(e2, t2) {
    for (let i2 of t2)
      e2.add(i2);
  }
  e(K, "default", W);
  class J {
    constructor(t2) {
      e(this, "parsers", {}), e(this, "output", {}), e(this, "errors", []), e(this, "pushToErrors", (e2) => this.errors.push(e2)), this.options = K.useCached(t2);
    }
    async read(e2) {
      this.file = await function(e3, t2) {
        return "string" == typeof e3 ? x(e3, t2) : i && !s && e3 instanceof HTMLImageElement ? x(e3.src, t2) : e3 instanceof Uint8Array || e3 instanceof ArrayBuffer || e3 instanceof DataView ? new y(e3) : i && e3 instanceof Blob ? C(e3, t2, "blob", U) : void u("Invalid input argument");
      }(e2, this.options);
    }
    setup() {
      if (this.fileParser)
        return;
      let { file: e2 } = this, t2 = e2.getUint16(0);
      for (let [i2, s2] of S)
        if (s2.canHandle(e2, t2))
          return this.fileParser = new s2(this.options, this.file, this.parsers), e2[i2] = true;
      this.file.close && this.file.close(), u("Unknown file format");
    }
    async parse() {
      let { output: e2, errors: t2 } = this;
      return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t2.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t2.length > 0 && (e2.errors = t2), h(e2);
    }
    async executeParsers() {
      let { output: e2 } = this;
      await this.fileParser.parse();
      let t2 = Object.values(this.parsers).map(async (t3) => {
        let i2 = await t3.parse();
        t3.assignToOutput(e2, i2);
      });
      this.options.silentErrors && (t2 = t2.map((e3) => e3.catch(this.pushToErrors))), await Promise.all(t2);
    }
    async extractThumbnail() {
      this.setup();
      let { options: e2, file: t2 } = this, i2 = k.get("tiff", e2);
      var s2;
      if (t2.tiff ? s2 = { start: 0, type: "tiff" } : t2.jpeg && (s2 = await this.fileParser.getOrFindSegment("tiff")), void 0 === s2)
        return;
      let n2 = await this.fileParser.ensureSegmentChunk(s2), r2 = this.parsers.tiff = new i2(n2, e2, t2), a2 = await r2.extractThumbnail();
      return t2.close && t2.close(), a2;
    }
  }
  async function Z(e2, t2) {
    let i2 = new J(t2);
    return await i2.read(e2), i2.parse();
  }
  class ee {
    constructor(t2, i2, s2) {
      e(this, "errors", []), e(this, "ensureSegmentChunk", async (e2) => {
        let t3 = e2.start, i3 = e2.size || 65536;
        if (this.file.chunked)
          if (this.file.available(t3, i3))
            e2.chunk = this.file.subarray(t3, i3);
          else
            try {
              e2.chunk = await this.file.readChunk(t3, i3);
            } catch (t4) {
              u(`Couldn't read segment: ${JSON.stringify(e2)}. ${t4.message}`);
            }
        else
          this.file.byteLength > t3 + i3 ? e2.chunk = this.file.subarray(t3, i3) : void 0 === e2.size ? e2.chunk = this.file.subarray(t3) : u("Segment unreachable: " + JSON.stringify(e2));
        return e2.chunk;
      }), this.extendOptions && this.extendOptions(t2), this.options = t2, this.file = i2, this.parsers = s2;
    }
    injectSegment(e2, t2) {
      this.options[e2].enabled && this.createParser(e2, t2);
    }
    createParser(e2, t2) {
      let i2 = new (k.get(e2))(t2, this.options, this.file);
      return this.parsers[e2] = i2;
    }
    createParsers(e2) {
      for (let t2 of e2) {
        let { type: e3, chunk: i2 } = t2, s2 = this.options[e3];
        if (s2 && s2.enabled) {
          let t3 = this.parsers[e3];
          t3 && t3.append || t3 || this.createParser(e3, i2);
        }
      }
    }
    async readSegments(e2) {
      let t2 = e2.map(this.ensureSegmentChunk);
      await Promise.all(t2);
    }
  }
  class te {
    static findPosition(e2, t2) {
      let i2 = e2.getUint16(t2 + 2) + 2, s2 = "function" == typeof this.headerLength ? this.headerLength(e2, t2, i2) : this.headerLength, n2 = t2 + s2, r2 = i2 - s2;
      return { offset: t2, length: i2, headerLength: s2, start: n2, size: r2, end: n2 + r2 };
    }
    static parse(e2, t2 = {}) {
      return new this(e2, new K({ [this.type]: t2 }), e2).parse();
    }
    normalizeInput(e2) {
      return e2 instanceof y ? e2 : new y(e2);
    }
    constructor(t2, i2 = {}, s2) {
      e(this, "errors", []), e(this, "raw", /* @__PURE__ */ new Map()), e(this, "handleError", (e2) => {
        if (!this.options.silentErrors)
          throw e2;
        this.errors.push(e2.message);
      }), this.chunk = this.normalizeInput(t2), this.file = s2, this.type = this.constructor.type, this.globalOptions = this.options = i2, this.localOptions = i2[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
    }
    translate() {
      this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
    }
    get output() {
      return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
    }
    translateBlock(e2, t2) {
      let i2 = T.get(t2), s2 = D.get(t2), n2 = L.get(t2), r2 = this.options[t2], a2 = r2.reviveValues && !!i2, o2 = r2.translateValues && !!s2, h2 = r2.translateKeys && !!n2, l2 = {};
      for (let [t3, r3] of e2)
        a2 && i2.has(t3) ? r3 = i2.get(t3)(r3) : o2 && s2.has(t3) && (r3 = this.translateValue(r3, s2.get(t3))), h2 && n2.has(t3) && (t3 = n2.get(t3) || t3), l2[t3] = r3;
      return l2;
    }
    translateValue(e2, t2) {
      return t2[e2] || t2.DEFAULT || e2;
    }
    assignToOutput(e2, t2) {
      this.assignObjectToOutput(e2, this.constructor.type, t2);
    }
    assignObjectToOutput(e2, t2, i2) {
      if (this.globalOptions.mergeOutput)
        return Object.assign(e2, i2);
      e2[t2] ? Object.assign(e2[t2], i2) : e2[t2] = i2;
    }
  }
  e(te, "headerLength", 4), e(te, "type", void 0), e(te, "multiSegment", false), e(te, "canHandle", () => false);
  function ie(e2) {
    return 192 === e2 || 194 === e2 || 196 === e2 || 219 === e2 || 221 === e2 || 218 === e2 || 254 === e2;
  }
  function se(e2) {
    return e2 >= 224 && e2 <= 239;
  }
  function ne(e2, t2, i2) {
    for (let [s2, n2] of k)
      if (n2.canHandle(e2, t2, i2))
        return s2;
  }
  class re extends ee {
    constructor(...t2) {
      super(...t2), e(this, "appSegments", []), e(this, "jpegSegments", []), e(this, "unknownSegments", []);
    }
    static canHandle(e2, t2) {
      return 65496 === t2;
    }
    async parse() {
      await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
    }
    setupSegmentFinderArgs(e2) {
      true === e2 ? (this.findAll = true, this.wanted = new Set(k.keyList())) : (e2 = void 0 === e2 ? k.keyList().filter((e3) => this.options[e3].enabled) : e2.filter((e3) => this.options[e3].enabled && k.has(e3)), this.findAll = false, this.remaining = new Set(e2), this.wanted = new Set(e2)), this.unfinishedMultiSegment = false;
    }
    async findAppSegments(e2 = 0, t2) {
      this.setupSegmentFinderArgs(t2);
      let { file: i2, findAll: s2, wanted: n2, remaining: r2 } = this;
      if (!s2 && this.file.chunked && (s2 = Array.from(n2).some((e3) => {
        let t3 = k.get(e3), i3 = this.options[e3];
        return t3.multiSegment && i3.multiSegment;
      }), s2 && await this.file.readWhole()), e2 = this.findAppSegmentsInRange(e2, i2.byteLength), !this.options.onlyTiff && i2.chunked) {
        let t3 = false;
        for (; r2.size > 0 && !t3 && (i2.canReadNextChunk || this.unfinishedMultiSegment); ) {
          let { nextChunkOffset: s3 } = i2, n3 = this.appSegments.some((e3) => !this.file.available(e3.offset || e3.start, e3.length || e3.size));
          if (t3 = e2 > s3 && !n3 ? !await i2.readNextChunk(e2) : !await i2.readNextChunk(s3), void 0 === (e2 = this.findAppSegmentsInRange(e2, i2.byteLength)))
            return;
        }
      }
    }
    findAppSegmentsInRange(e2, t2) {
      t2 -= 2;
      let i2, s2, n2, r2, a2, o2, { file: h2, findAll: l2, wanted: f2, remaining: u2, options: d2 } = this;
      for (; e2 < t2; e2++)
        if (255 === h2.getUint8(e2)) {
          if (i2 = h2.getUint8(e2 + 1), se(i2)) {
            if (s2 = h2.getUint16(e2 + 2), n2 = ne(h2, e2, s2), n2 && f2.has(n2) && (r2 = k.get(n2), a2 = r2.findPosition(h2, e2), o2 = d2[n2], a2.type = n2, this.appSegments.push(a2), !l2 && (r2.multiSegment && o2.multiSegment ? (this.unfinishedMultiSegment = a2.chunkNumber < a2.chunkCount, this.unfinishedMultiSegment || u2.delete(n2)) : u2.delete(n2), 0 === u2.size)))
              break;
            d2.recordUnknownSegments && (a2 = te.findPosition(h2, e2), a2.marker = i2, this.unknownSegments.push(a2)), e2 += s2 + 1;
          } else if (ie(i2)) {
            if (s2 = h2.getUint16(e2 + 2), 218 === i2 && false !== d2.stopAfterSos)
              return;
            d2.recordJpegSegments && this.jpegSegments.push({ offset: e2, length: s2, marker: i2 }), e2 += s2 + 1;
          }
        }
      return e2;
    }
    mergeMultiSegments() {
      if (!this.appSegments.some((e3) => e3.multiSegment))
        return;
      let e2 = function(e3, t2) {
        let i2, s2, n2, r2 = /* @__PURE__ */ new Map();
        for (let a2 = 0; a2 < e3.length; a2++)
          i2 = e3[a2], s2 = i2[t2], r2.has(s2) ? n2 = r2.get(s2) : r2.set(s2, n2 = []), n2.push(i2);
        return Array.from(r2);
      }(this.appSegments, "type");
      this.mergedAppSegments = e2.map(([e3, t2]) => {
        let i2 = k.get(e3, this.options);
        if (i2.handleMultiSegments) {
          return { type: e3, chunk: i2.handleMultiSegments(t2) };
        }
        return t2[0];
      });
    }
    getSegment(e2) {
      return this.appSegments.find((t2) => t2.type === e2);
    }
    async getOrFindSegment(e2) {
      let t2 = this.getSegment(e2);
      return void 0 === t2 && (await this.findAppSegments(0, [e2]), t2 = this.getSegment(e2)), t2;
    }
  }
  e(re, "type", "jpeg"), S.set("jpeg", re);
  const ae = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
  class oe extends te {
    parseHeader() {
      var e2 = this.chunk.getUint16();
      18761 === e2 ? this.le = true : 19789 === e2 && (this.le = false), this.chunk.le = this.le, this.headerParsed = true;
    }
    parseTags(e2, t2, i2 = /* @__PURE__ */ new Map()) {
      let { pick: s2, skip: n2 } = this.options[t2];
      s2 = new Set(s2);
      let r2 = s2.size > 0, a2 = 0 === n2.size, o2 = this.chunk.getUint16(e2);
      e2 += 2;
      for (let h2 = 0; h2 < o2; h2++) {
        let o3 = this.chunk.getUint16(e2);
        if (r2) {
          if (s2.has(o3) && (i2.set(o3, this.parseTag(e2, o3, t2)), s2.delete(o3), 0 === s2.size))
            break;
        } else
          !a2 && n2.has(o3) || i2.set(o3, this.parseTag(e2, o3, t2));
        e2 += 12;
      }
      return i2;
    }
    parseTag(e2, t2, i2) {
      let { chunk: s2 } = this, n2 = s2.getUint16(e2 + 2), r2 = s2.getUint32(e2 + 4), a2 = ae[n2];
      if (a2 * r2 <= 4 ? e2 += 8 : e2 = s2.getUint32(e2 + 8), (n2 < 1 || n2 > 13) && u(`Invalid TIFF value type. block: ${i2.toUpperCase()}, tag: ${t2.toString(16)}, type: ${n2}, offset ${e2}`), e2 > s2.byteLength && u(`Invalid TIFF value offset. block: ${i2.toUpperCase()}, tag: ${t2.toString(16)}, type: ${n2}, offset ${e2} is outside of chunk size ${s2.byteLength}`), 1 === n2)
        return s2.getUint8Array(e2, r2);
      if (2 === n2)
        return d(s2.getString(e2, r2));
      if (7 === n2)
        return s2.getUint8Array(e2, r2);
      if (1 === r2)
        return this.parseTagValue(n2, e2);
      {
        let t3 = new (function(e3) {
          switch (e3) {
            case 1:
              return Uint8Array;
            case 3:
              return Uint16Array;
            case 4:
              return Uint32Array;
            case 5:
              return Array;
            case 6:
              return Int8Array;
            case 8:
              return Int16Array;
            case 9:
              return Int32Array;
            case 10:
              return Array;
            case 11:
              return Float32Array;
            case 12:
              return Float64Array;
            default:
              return Array;
          }
        }(n2))(r2), i3 = a2;
        for (let s3 = 0; s3 < r2; s3++)
          t3[s3] = this.parseTagValue(n2, e2), e2 += i3;
        return t3;
      }
    }
    parseTagValue(e2, t2) {
      let { chunk: i2 } = this;
      switch (e2) {
        case 1:
          return i2.getUint8(t2);
        case 3:
          return i2.getUint16(t2);
        case 4:
          return i2.getUint32(t2);
        case 5:
          return i2.getUint32(t2) / i2.getUint32(t2 + 4);
        case 6:
          return i2.getInt8(t2);
        case 8:
          return i2.getInt16(t2);
        case 9:
          return i2.getInt32(t2);
        case 10:
          return i2.getInt32(t2) / i2.getInt32(t2 + 4);
        case 11:
          return i2.getFloat(t2);
        case 12:
          return i2.getDouble(t2);
        case 13:
          return i2.getUint32(t2);
        default:
          u(`Invalid tiff type ${e2}`);
      }
    }
  }
  class he extends oe {
    static canHandle(e2, t2) {
      return 225 === e2.getUint8(t2 + 1) && 1165519206 === e2.getUint32(t2 + 4) && 0 === e2.getUint16(t2 + 8);
    }
    async parse() {
      this.parseHeader();
      let { options: e2 } = this;
      return e2.ifd0.enabled && await this.parseIfd0Block(), e2.exif.enabled && await this.safeParse("parseExifBlock"), e2.gps.enabled && await this.safeParse("parseGpsBlock"), e2.interop.enabled && await this.safeParse("parseInteropBlock"), e2.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
    }
    safeParse(e2) {
      let t2 = this[e2]();
      return void 0 !== t2.catch && (t2 = t2.catch(this.handleError)), t2;
    }
    findIfd0Offset() {
      void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
    }
    findIfd1Offset() {
      if (void 0 === this.ifd1Offset) {
        this.findIfd0Offset();
        let e2 = this.chunk.getUint16(this.ifd0Offset), t2 = this.ifd0Offset + 2 + 12 * e2;
        this.ifd1Offset = this.chunk.getUint32(t2);
      }
    }
    parseBlock(e2, t2) {
      let i2 = /* @__PURE__ */ new Map();
      return this[t2] = i2, this.parseTags(e2, t2, i2), i2;
    }
    async parseIfd0Block() {
      if (this.ifd0)
        return;
      let { file: e2 } = this;
      this.findIfd0Offset(), this.ifd0Offset < 8 && u("Malformed EXIF data"), !e2.chunked && this.ifd0Offset > e2.byteLength && u(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e2.byteLength}`), e2.tiff && await e2.ensureChunk(this.ifd0Offset, c(this.options));
      let t2 = this.parseBlock(this.ifd0Offset, "ifd0");
      return 0 !== t2.size ? (this.exifOffset = t2.get(34665), this.interopOffset = t2.get(40965), this.gpsOffset = t2.get(34853), this.xmp = t2.get(700), this.iptc = t2.get(33723), this.icc = t2.get(34675), this.options.sanitize && (t2.delete(34665), t2.delete(40965), t2.delete(34853), t2.delete(700), t2.delete(33723), t2.delete(34675)), t2) : void 0;
    }
    async parseExifBlock() {
      if (this.exif)
        return;
      if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset)
        return;
      this.file.tiff && await this.file.ensureChunk(this.exifOffset, c(this.options));
      let e2 = this.parseBlock(this.exifOffset, "exif");
      return this.interopOffset || (this.interopOffset = e2.get(40965)), this.makerNote = e2.get(37500), this.userComment = e2.get(37510), this.options.sanitize && (e2.delete(40965), e2.delete(37500), e2.delete(37510)), this.unpack(e2, 41728), this.unpack(e2, 41729), e2;
    }
    unpack(e2, t2) {
      let i2 = e2.get(t2);
      i2 && 1 === i2.length && e2.set(t2, i2[0]);
    }
    async parseGpsBlock() {
      if (this.gps)
        return;
      if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset)
        return;
      let e2 = this.parseBlock(this.gpsOffset, "gps");
      return e2 && e2.has(2) && e2.has(4) && (e2.set("latitude", le(...e2.get(2), e2.get(1))), e2.set("longitude", le(...e2.get(4), e2.get(3)))), e2;
    }
    async parseInteropBlock() {
      if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset))
        return this.parseBlock(this.interopOffset, "interop");
    }
    async parseThumbnailBlock(e2 = false) {
      if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e2))
        return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = true), this.ifd1;
    }
    async extractThumbnail() {
      if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(true), void 0 === this.ifd1)
        return;
      let e2 = this.ifd1.get(513), t2 = this.ifd1.get(514);
      return this.chunk.getUint8Array(e2, t2);
    }
    get image() {
      return this.ifd0;
    }
    get thumbnail() {
      return this.ifd1;
    }
    createOutput() {
      let e2, t2, i2, s2 = {};
      for (t2 of M)
        if (e2 = this[t2], !f(e2))
          if (i2 = this.canTranslate ? this.translateBlock(e2, t2) : Object.fromEntries(e2), this.options.mergeOutput) {
            if ("ifd1" === t2)
              continue;
            Object.assign(s2, i2);
          } else
            s2[t2] = i2;
      return this.makerNote && (s2.makerNote = this.makerNote), this.userComment && (s2.userComment = this.userComment), s2;
    }
    assignToOutput(e2, t2) {
      if (this.globalOptions.mergeOutput)
        Object.assign(e2, t2);
      else
        for (let [i2, s2] of Object.entries(t2))
          this.assignObjectToOutput(e2, i2, s2);
    }
  }
  function le(e2, t2, i2, s2) {
    var n2 = e2 + t2 / 60 + i2 / 3600;
    return "S" !== s2 && "W" !== s2 || (n2 *= -1), n2;
  }
  e(he, "type", "tiff"), e(he, "headerLength", 10), k.set("tiff", he);
  const ue = { ifd0: false, ifd1: false, exif: false, gps: false, interop: false, sanitize: false, reviveValues: true, translateKeys: false, translateValues: false, mergeOutput: false };
  Object.assign({}, ue, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
  Object.assign({}, ue, { tiff: false, ifd1: true, mergeOutput: false });
  Object.assign({}, ue, { firstChunkSize: 4e4, ifd0: [274] });
  if ("object" == typeof navigator) {
    let e2 = navigator.userAgent;
    if (e2.includes("iPad") || e2.includes("iPhone")) {
      e2.match(/OS (\d+)_(\d+)/);
    } else if (e2.includes("OS X 10")) {
      e2.match(/OS X 10[_.](\d+)/);
    }
    if (e2.includes("Chrome/")) {
      e2.match(/Chrome\/(\d+)/);
    } else if (e2.includes("Firefox/")) {
      e2.match(/Firefox\/(\d+)/);
    }
  }
  class Oe extends y {
    constructor(...t2) {
      super(...t2), e(this, "ranges", new xe()), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
    }
    _tryExtend(e2, t2, i2) {
      if (0 === e2 && 0 === this.byteLength && i2) {
        let e3 = new DataView(i2.buffer || i2, i2.byteOffset, i2.byteLength);
        this._swapDataView(e3);
      } else {
        let i3 = e2 + t2;
        if (i3 > this.byteLength) {
          let { dataView: e3 } = this._extend(i3);
          this._swapDataView(e3);
        }
      }
    }
    _extend(e2) {
      let t2;
      t2 = o ? r.allocUnsafe(e2) : new Uint8Array(e2);
      let i2 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
      return t2.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t2, dataView: i2 };
    }
    subarray(e2, t2, i2 = false) {
      return t2 = t2 || this._lengthToEnd(e2), i2 && this._tryExtend(e2, t2), this.ranges.add(e2, t2), super.subarray(e2, t2);
    }
    set(e2, t2, i2 = false) {
      i2 && this._tryExtend(t2, e2.byteLength, e2);
      let s2 = super.set(e2, t2);
      return this.ranges.add(t2, s2.byteLength), s2;
    }
    async ensureChunk(e2, t2) {
      this.chunked && (this.ranges.available(e2, t2) || await this.readChunk(e2, t2));
    }
    available(e2, t2) {
      return this.ranges.available(e2, t2);
    }
  }
  class xe {
    constructor() {
      e(this, "list", []);
    }
    get length() {
      return this.list.length;
    }
    add(e2, t2, i2 = 0) {
      let s2 = e2 + t2, n2 = this.list.filter((t3) => Ce(e2, t3.offset, s2) || Ce(e2, t3.end, s2));
      if (n2.length > 0) {
        e2 = Math.min(e2, ...n2.map((e3) => e3.offset)), s2 = Math.max(s2, ...n2.map((e3) => e3.end)), t2 = s2 - e2;
        let i3 = n2.shift();
        i3.offset = e2, i3.length = t2, i3.end = s2, this.list = this.list.filter((e3) => !n2.includes(e3));
      } else
        this.list.push({ offset: e2, length: t2, end: s2 });
    }
    available(e2, t2) {
      let i2 = e2 + t2;
      return this.list.some((t3) => t3.offset <= e2 && i2 <= t3.end);
    }
  }
  function Ce(e2, t2, i2) {
    return e2 <= t2 && t2 <= i2;
  }
  class Pe extends Oe {
    constructor(t2, i2) {
      super(0), e(this, "chunksRead", 0), this.input = t2, this.options = i2;
    }
    async readWhole() {
      this.chunked = false, await this.readChunk(this.nextChunkOffset);
    }
    async readChunked() {
      this.chunked = true, await this.readChunk(0, this.options.firstChunkSize);
    }
    async readNextChunk(e2 = this.nextChunkOffset) {
      if (this.fullyRead)
        return this.chunksRead++, false;
      let t2 = this.options.chunkSize, i2 = await this.readChunk(e2, t2);
      return !!i2 && i2.byteLength === t2;
    }
    async readChunk(e2, t2) {
      if (this.chunksRead++, 0 !== (t2 = this.safeWrapAddress(e2, t2)))
        return this._readChunk(e2, t2);
    }
    safeWrapAddress(e2, t2) {
      return void 0 !== this.size && e2 + t2 > this.size ? Math.max(0, this.size - e2) : t2;
    }
    get nextChunkOffset() {
      if (0 !== this.ranges.list.length)
        return this.ranges.list[0].length;
    }
    get canReadNextChunk() {
      return this.chunksRead < this.options.chunkLimit;
    }
    get fullyRead() {
      return void 0 !== this.size && this.nextChunkOffset === this.size;
    }
    read() {
      return this.options.chunked ? this.readChunked() : this.readWhole();
    }
    close() {
    }
  }
  v.set("blob", class extends Pe {
    async readWhole() {
      this.chunked = false;
      let e2 = await U(this.input);
      this._swapArrayBuffer(e2);
    }
    readChunked() {
      return this.chunked = true, this.size = this.input.size, super.readChunked();
    }
    async _readChunk(e2, t2) {
      let i2 = t2 ? e2 + t2 : void 0, s2 = this.input.slice(e2, i2), n2 = await U(s2);
      return this.set(n2, e2, true);
    }
  });
  v.set("url", class extends Pe {
    async readWhole() {
      this.chunked = false;
      let e2 = await A(this.input);
      e2 instanceof ArrayBuffer ? this._swapArrayBuffer(e2) : e2 instanceof Uint8Array && this._swapBuffer(e2);
    }
    async _readChunk(e2, t2) {
      let i2 = t2 ? e2 + t2 - 1 : void 0, s2 = this.options.httpHeaders || {};
      (e2 || i2) && (s2.range = `bytes=${[e2, i2].join("-")}`);
      let n2 = await O(this.input, { headers: s2 }), r2 = await n2.arrayBuffer(), a2 = r2.byteLength;
      if (416 !== n2.status)
        return a2 !== t2 && (this.size = e2 + a2), this.set(r2, e2, true);
    }
  });
  y.prototype.getUint64 = function(e2) {
    let t2 = this.getUint32(e2), i2 = this.getUint32(e2 + 4);
    return t2 < 1048575 ? t2 << 32 | i2 : void 0 !== typeof a ? (console.warn("Using BigInt because of type 64uint but JS can only handle 53b numbers."), a(t2) << a(32) | a(i2)) : void u("Trying to read 64b value but JS can only handle 53b numbers.");
  };
  class Ue extends ee {
    parseBoxes(e2 = 0) {
      let t2 = [];
      for (; e2 < this.file.byteLength - 4; ) {
        let i2 = this.parseBoxHead(e2);
        if (t2.push(i2), 0 === i2.length)
          break;
        e2 += i2.length;
      }
      return t2;
    }
    parseSubBoxes(e2) {
      e2.boxes = this.parseBoxes(e2.start);
    }
    findBox(e2, t2) {
      return void 0 === e2.boxes && this.parseSubBoxes(e2), e2.boxes.find((e3) => e3.kind === t2);
    }
    parseBoxHead(e2) {
      let t2 = this.file.getUint32(e2), i2 = this.file.getString(e2 + 4, 4), s2 = e2 + 8;
      return 1 === t2 && (t2 = this.file.getUint64(e2 + 8), s2 += 8), { offset: e2, length: t2, kind: i2, start: s2 };
    }
    parseBoxFullHead(e2) {
      if (void 0 !== e2.version)
        return;
      let t2 = this.file.getUint32(e2.start);
      e2.version = t2 >> 24, e2.start += 4;
    }
  }
  class Ie extends Ue {
    static canHandle(e2, t2) {
      if (0 !== t2)
        return false;
      let i2 = e2.getUint16(2);
      if (i2 > 50)
        return false;
      let s2 = 16, n2 = [];
      for (; s2 < i2; )
        n2.push(e2.getString(s2, 4)), s2 += 4;
      return n2.includes(this.type);
    }
    async parse() {
      let e2 = this.file.getUint32(0), t2 = this.parseBoxHead(e2);
      for (; "meta" !== t2.kind; )
        e2 += t2.length, await this.file.ensureChunk(e2, 16), t2 = this.parseBoxHead(e2);
      await this.file.ensureChunk(t2.offset, t2.length), this.parseBoxFullHead(t2), this.parseSubBoxes(t2), this.options.icc.enabled && await this.findIcc(t2), this.options.tiff.enabled && await this.findExif(t2);
    }
    async registerSegment(e2, t2, i2) {
      await this.file.ensureChunk(t2, i2);
      let s2 = this.file.subarray(t2, i2);
      this.createParser(e2, s2);
    }
    async findIcc(e2) {
      let t2 = this.findBox(e2, "iprp");
      if (void 0 === t2)
        return;
      let i2 = this.findBox(t2, "ipco");
      if (void 0 === i2)
        return;
      let s2 = this.findBox(i2, "colr");
      void 0 !== s2 && await this.registerSegment("icc", s2.offset + 12, s2.length);
    }
    async findExif(e2) {
      let t2 = this.findBox(e2, "iinf");
      if (void 0 === t2)
        return;
      let i2 = this.findBox(e2, "iloc");
      if (void 0 === i2)
        return;
      let s2 = this.findExifLocIdInIinf(t2), n2 = this.findExtentInIloc(i2, s2);
      if (void 0 === n2)
        return;
      let [r2, a2] = n2;
      await this.file.ensureChunk(r2, a2);
      let o2 = 4 + this.file.getUint32(r2);
      r2 += o2, a2 -= o2, await this.registerSegment("tiff", r2, a2);
    }
    findExifLocIdInIinf(e2) {
      this.parseBoxFullHead(e2);
      let t2, i2, s2, n2, r2 = e2.start, a2 = this.file.getUint16(r2);
      for (r2 += 2; a2--; ) {
        if (t2 = this.parseBoxHead(r2), this.parseBoxFullHead(t2), i2 = t2.start, t2.version >= 2 && (s2 = 3 === t2.version ? 4 : 2, n2 = this.file.getString(i2 + s2 + 2, 4), "Exif" === n2))
          return this.file.getUintBytes(i2, s2);
        r2 += t2.length;
      }
    }
    get8bits(e2) {
      let t2 = this.file.getUint8(e2);
      return [t2 >> 4, 15 & t2];
    }
    findExtentInIloc(e2, t2) {
      this.parseBoxFullHead(e2);
      let i2 = e2.start, [s2, n2] = this.get8bits(i2++), [r2, a2] = this.get8bits(i2++), o2 = 2 === e2.version ? 4 : 2, h2 = 1 === e2.version || 2 === e2.version ? 2 : 0, l2 = a2 + s2 + n2, f2 = 2 === e2.version ? 4 : 2, u2 = this.file.getUintBytes(i2, f2);
      for (i2 += f2; u2--; ) {
        let e3 = this.file.getUintBytes(i2, o2);
        i2 += o2 + h2 + 2 + r2;
        let f3 = this.file.getUint16(i2);
        if (i2 += 2, e3 === t2)
          return f3 > 1 && console.warn("ILOC box has more than one extent but we're only processing one\nPlease create an issue at https://github.com/MikeKovarik/exifr with this file"), [this.file.getUintBytes(i2 + a2, s2), this.file.getUintBytes(i2 + a2 + s2, n2)];
        i2 += f3 * l2;
      }
    }
  }
  class Be extends Ie {
  }
  e(Be, "type", "heic");
  class Fe extends Ie {
  }
  e(Fe, "type", "avif"), S.set("heic", Be), S.set("avif", Fe), B(L, ["ifd0", "ifd1"], [[256, "ImageWidth"], [257, "ImageHeight"], [258, "BitsPerSample"], [259, "Compression"], [262, "PhotometricInterpretation"], [270, "ImageDescription"], [271, "Make"], [272, "Model"], [273, "StripOffsets"], [274, "Orientation"], [277, "SamplesPerPixel"], [278, "RowsPerStrip"], [279, "StripByteCounts"], [282, "XResolution"], [283, "YResolution"], [284, "PlanarConfiguration"], [296, "ResolutionUnit"], [301, "TransferFunction"], [305, "Software"], [306, "ModifyDate"], [315, "Artist"], [316, "HostComputer"], [317, "Predictor"], [318, "WhitePoint"], [319, "PrimaryChromaticities"], [513, "ThumbnailOffset"], [514, "ThumbnailLength"], [529, "YCbCrCoefficients"], [530, "YCbCrSubSampling"], [531, "YCbCrPositioning"], [532, "ReferenceBlackWhite"], [700, "ApplicationNotes"], [33432, "Copyright"], [33723, "IPTC"], [34665, "ExifIFD"], [34675, "ICC"], [34853, "GpsIFD"], [330, "SubIFD"], [40965, "InteropIFD"], [40091, "XPTitle"], [40092, "XPComment"], [40093, "XPAuthor"], [40094, "XPKeywords"], [40095, "XPSubject"]]), B(L, "exif", [[33434, "ExposureTime"], [33437, "FNumber"], [34850, "ExposureProgram"], [34852, "SpectralSensitivity"], [34855, "ISO"], [34858, "TimeZoneOffset"], [34859, "SelfTimerMode"], [34864, "SensitivityType"], [34865, "StandardOutputSensitivity"], [34866, "RecommendedExposureIndex"], [34867, "ISOSpeed"], [34868, "ISOSpeedLatitudeyyy"], [34869, "ISOSpeedLatitudezzz"], [36864, "ExifVersion"], [36867, "DateTimeOriginal"], [36868, "CreateDate"], [36873, "GooglePlusUploadCode"], [36880, "OffsetTime"], [36881, "OffsetTimeOriginal"], [36882, "OffsetTimeDigitized"], [37121, "ComponentsConfiguration"], [37122, "CompressedBitsPerPixel"], [37377, "ShutterSpeedValue"], [37378, "ApertureValue"], [37379, "BrightnessValue"], [37380, "ExposureCompensation"], [37381, "MaxApertureValue"], [37382, "SubjectDistance"], [37383, "MeteringMode"], [37384, "LightSource"], [37385, "Flash"], [37386, "FocalLength"], [37393, "ImageNumber"], [37394, "SecurityClassification"], [37395, "ImageHistory"], [37396, "SubjectArea"], [37500, "MakerNote"], [37510, "UserComment"], [37520, "SubSecTime"], [37521, "SubSecTimeOriginal"], [37522, "SubSecTimeDigitized"], [37888, "AmbientTemperature"], [37889, "Humidity"], [37890, "Pressure"], [37891, "WaterDepth"], [37892, "Acceleration"], [37893, "CameraElevationAngle"], [40960, "FlashpixVersion"], [40961, "ColorSpace"], [40962, "ExifImageWidth"], [40963, "ExifImageHeight"], [40964, "RelatedSoundFile"], [41483, "FlashEnergy"], [41486, "FocalPlaneXResolution"], [41487, "FocalPlaneYResolution"], [41488, "FocalPlaneResolutionUnit"], [41492, "SubjectLocation"], [41493, "ExposureIndex"], [41495, "SensingMethod"], [41728, "FileSource"], [41729, "SceneType"], [41730, "CFAPattern"], [41985, "CustomRendered"], [41986, "ExposureMode"], [41987, "WhiteBalance"], [41988, "DigitalZoomRatio"], [41989, "FocalLengthIn35mmFormat"], [41990, "SceneCaptureType"], [41991, "GainControl"], [41992, "Contrast"], [41993, "Saturation"], [41994, "Sharpness"], [41996, "SubjectDistanceRange"], [42016, "ImageUniqueID"], [42032, "OwnerName"], [42033, "SerialNumber"], [42034, "LensInfo"], [42035, "LensMake"], [42036, "LensModel"], [42037, "LensSerialNumber"], [42080, "CompositeImage"], [42081, "CompositeImageCount"], [42082, "CompositeImageExposureTimes"], [42240, "Gamma"], [59932, "Padding"], [59933, "OffsetSchema"], [65e3, "OwnerName"], [65001, "SerialNumber"], [65002, "Lens"], [65100, "RawFile"], [65101, "Converter"], [65102, "WhiteBalance"], [65105, "Exposure"], [65106, "Shadows"], [65107, "Brightness"], [65108, "Contrast"], [65109, "Saturation"], [65110, "Sharpness"], [65111, "Smoothness"], [65112, "MoireFilter"], [40965, "InteropIFD"]]), B(L, "gps", [[0, "GPSVersionID"], [1, "GPSLatitudeRef"], [2, "GPSLatitude"], [3, "GPSLongitudeRef"], [4, "GPSLongitude"], [5, "GPSAltitudeRef"], [6, "GPSAltitude"], [7, "GPSTimeStamp"], [8, "GPSSatellites"], [9, "GPSStatus"], [10, "GPSMeasureMode"], [11, "GPSDOP"], [12, "GPSSpeedRef"], [13, "GPSSpeed"], [14, "GPSTrackRef"], [15, "GPSTrack"], [16, "GPSImgDirectionRef"], [17, "GPSImgDirection"], [18, "GPSMapDatum"], [19, "GPSDestLatitudeRef"], [20, "GPSDestLatitude"], [21, "GPSDestLongitudeRef"], [22, "GPSDestLongitude"], [23, "GPSDestBearingRef"], [24, "GPSDestBearing"], [25, "GPSDestDistanceRef"], [26, "GPSDestDistance"], [27, "GPSProcessingMethod"], [28, "GPSAreaInformation"], [29, "GPSDateStamp"], [30, "GPSDifferential"], [31, "GPSHPositioningError"]]), B(D, ["ifd0", "ifd1"], [[274, { 1: "Horizontal (normal)", 2: "Mirror horizontal", 3: "Rotate 180", 4: "Mirror vertical", 5: "Mirror horizontal and rotate 270 CW", 6: "Rotate 90 CW", 7: "Mirror horizontal and rotate 90 CW", 8: "Rotate 270 CW" }], [296, { 1: "None", 2: "inches", 3: "cm" }]]);
  let Le = B(D, "exif", [[34850, { 0: "Not defined", 1: "Manual", 2: "Normal program", 3: "Aperture priority", 4: "Shutter priority", 5: "Creative program", 6: "Action program", 7: "Portrait mode", 8: "Landscape mode" }], [37121, { 0: "-", 1: "Y", 2: "Cb", 3: "Cr", 4: "R", 5: "G", 6: "B" }], [37383, { 0: "Unknown", 1: "Average", 2: "CenterWeightedAverage", 3: "Spot", 4: "MultiSpot", 5: "Pattern", 6: "Partial", 255: "Other" }], [37384, { 0: "Unknown", 1: "Daylight", 2: "Fluorescent", 3: "Tungsten (incandescent light)", 4: "Flash", 9: "Fine weather", 10: "Cloudy weather", 11: "Shade", 12: "Daylight fluorescent (D 5700 - 7100K)", 13: "Day white fluorescent (N 4600 - 5400K)", 14: "Cool white fluorescent (W 3900 - 4500K)", 15: "White fluorescent (WW 3200 - 3700K)", 17: "Standard light A", 18: "Standard light B", 19: "Standard light C", 20: "D55", 21: "D65", 22: "D75", 23: "D50", 24: "ISO studio tungsten", 255: "Other" }], [37385, { 0: "Flash did not fire", 1: "Flash fired", 5: "Strobe return light not detected", 7: "Strobe return light detected", 9: "Flash fired, compulsory flash mode", 13: "Flash fired, compulsory flash mode, return light not detected", 15: "Flash fired, compulsory flash mode, return light detected", 16: "Flash did not fire, compulsory flash mode", 24: "Flash did not fire, auto mode", 25: "Flash fired, auto mode", 29: "Flash fired, auto mode, return light not detected", 31: "Flash fired, auto mode, return light detected", 32: "No flash function", 65: "Flash fired, red-eye reduction mode", 69: "Flash fired, red-eye reduction mode, return light not detected", 71: "Flash fired, red-eye reduction mode, return light detected", 73: "Flash fired, compulsory flash mode, red-eye reduction mode", 77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected", 79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected", 89: "Flash fired, auto mode, red-eye reduction mode", 93: "Flash fired, auto mode, return light not detected, red-eye reduction mode", 95: "Flash fired, auto mode, return light detected, red-eye reduction mode" }], [41495, { 1: "Not defined", 2: "One-chip color area sensor", 3: "Two-chip color area sensor", 4: "Three-chip color area sensor", 5: "Color sequential area sensor", 7: "Trilinear sensor", 8: "Color sequential linear sensor" }], [41728, { 1: "Film Scanner", 2: "Reflection Print Scanner", 3: "Digital Camera" }], [41729, { 1: "Directly photographed" }], [41985, { 0: "Normal", 1: "Custom", 2: "HDR (no original saved)", 3: "HDR (original saved)", 4: "Original (for HDR)", 6: "Panorama", 7: "Portrait HDR", 8: "Portrait" }], [41986, { 0: "Auto", 1: "Manual", 2: "Auto bracket" }], [41987, { 0: "Auto", 1: "Manual" }], [41990, { 0: "Standard", 1: "Landscape", 2: "Portrait", 3: "Night", 4: "Other" }], [41991, { 0: "None", 1: "Low gain up", 2: "High gain up", 3: "Low gain down", 4: "High gain down" }], [41996, { 0: "Unknown", 1: "Macro", 2: "Close", 3: "Distant" }], [42080, { 0: "Unknown", 1: "Not a Composite Image", 2: "General Composite Image", 3: "Composite Image Captured While Shooting" }]]);
  const De = { 1: "No absolute unit of measurement", 2: "Inch", 3: "Centimeter" };
  Le.set(37392, De), Le.set(41488, De);
  const Te = { 0: "Normal", 1: "Low", 2: "High" };
  function ze(e2) {
    return "object" == typeof e2 && void 0 !== e2.length ? e2[0] : e2;
  }
  function Ne(e2) {
    let t2 = Array.from(e2).slice(1);
    return t2[1] > 15 && (t2 = t2.map((e3) => String.fromCharCode(e3))), "0" !== t2[2] && 0 !== t2[2] || t2.pop(), t2.join(".");
  }
  function Ve(e2) {
    if ("string" == typeof e2) {
      var [t2, i2, s2, n2, r2, a2] = e2.trim().split(/[-: ]/g).map(Number), o2 = new Date(t2, i2 - 1, s2);
      return Number.isNaN(n2) || Number.isNaN(r2) || Number.isNaN(a2) || (o2.setHours(n2), o2.setMinutes(r2), o2.setSeconds(a2)), Number.isNaN(+o2) ? e2 : o2;
    }
  }
  function Me(e2) {
    if ("string" == typeof e2)
      return e2;
    let t2 = [];
    if (0 === e2[1] && 0 === e2[e2.length - 1])
      for (let i2 = 0; i2 < e2.length; i2 += 2)
        t2.push(Ee(e2[i2 + 1], e2[i2]));
    else
      for (let i2 = 0; i2 < e2.length; i2 += 2)
        t2.push(Ee(e2[i2], e2[i2 + 1]));
    return d(String.fromCodePoint(...t2));
  }
  function Ee(e2, t2) {
    return e2 << 8 | t2;
  }
  Le.set(41992, Te), Le.set(41993, Te), Le.set(41994, Te), B(T, ["ifd0", "ifd1"], [[50827, function(e2) {
    return "string" != typeof e2 ? m(e2) : e2;
  }], [306, Ve], [40091, Me], [40092, Me], [40093, Me], [40094, Me], [40095, Me]]), B(T, "exif", [[40960, Ne], [36864, Ne], [36867, Ve], [36868, Ve], [40962, ze], [40963, ze]]), B(T, "gps", [[0, (e2) => Array.from(e2).join(".")], [7, (e2) => Array.from(e2).join(":")]]);
  class Re extends te {
    static canHandle(e2, t2) {
      return 225 === e2.getUint8(t2 + 1) && 1752462448 === e2.getUint32(t2 + 4) && "http://ns.adobe.com/" === e2.getString(t2 + 4, "http://ns.adobe.com/".length);
    }
    static headerLength(e2, t2) {
      return "http://ns.adobe.com/xmp/extension/" === e2.getString(t2 + 4, "http://ns.adobe.com/xmp/extension/".length) ? 79 : 4 + "http://ns.adobe.com/xap/1.0/".length + 1;
    }
    static findPosition(e2, t2) {
      let i2 = super.findPosition(e2, t2);
      return i2.multiSegment = i2.extended = 79 === i2.headerLength, i2.multiSegment ? (i2.chunkCount = e2.getUint8(t2 + 72), i2.chunkNumber = e2.getUint8(t2 + 76), 0 !== e2.getUint8(t2 + 77) && i2.chunkNumber++) : (i2.chunkCount = 1 / 0, i2.chunkNumber = -1), i2;
    }
    static handleMultiSegments(e2) {
      return e2.map((e3) => e3.chunk.getString()).join("");
    }
    normalizeInput(e2) {
      return "string" == typeof e2 ? e2 : y.from(e2).getString();
    }
    parse(e2 = this.chunk) {
      if (!this.localOptions.parse)
        return e2;
      e2 = function(e3) {
        let t3 = {}, i3 = {};
        for (let e4 of Ye)
          t3[e4] = [], i3[e4] = 0;
        return e3.replace(qe, (e4, s3, n2) => {
          if ("<" === s3) {
            let s4 = ++i3[n2];
            return t3[n2].push(s4), `${e4}#${s4}`;
          }
          return `${e4}#${t3[n2].pop()}`;
        });
      }(e2);
      let t2 = Ge.findAll(e2, "rdf", "Description");
      0 === t2.length && t2.push(new Ge("rdf", "Description", void 0, e2));
      let i2, s2 = {};
      for (let e3 of t2)
        for (let t3 of e3.properties)
          i2 = $e(t3.ns, s2), He(t3, i2);
      return function(e3) {
        let t3;
        for (let i3 in e3)
          t3 = e3[i3] = h(e3[i3]), void 0 === t3 && delete e3[i3];
        return h(e3);
      }(s2);
    }
    assignToOutput(e2, t2) {
      if (this.localOptions.parse)
        for (let [i2, s2] of Object.entries(t2))
          switch (i2) {
            case "tiff":
              this.assignObjectToOutput(e2, "ifd0", s2);
              break;
            case "exif":
              this.assignObjectToOutput(e2, "exif", s2);
              break;
            case "xmlns":
              break;
            default:
              this.assignObjectToOutput(e2, i2, s2);
          }
      else
        e2.xmp = t2;
    }
  }
  e(Re, "type", "xmp"), e(Re, "multiSegment", true), k.set("xmp", Re);
  class je {
    static findAll(e2) {
      return Ke(e2, /([a-zA-Z0-9-]+):([a-zA-Z0-9-]+)=("[^"]*"|'[^']*')/gm).map(je.unpackMatch);
    }
    static unpackMatch(e2) {
      let t2 = e2[1], i2 = e2[2], s2 = e2[3].slice(1, -1);
      return s2 = Xe(s2), new je(t2, i2, s2);
    }
    constructor(e2, t2, i2) {
      this.ns = e2, this.name = t2, this.value = i2;
    }
    serialize() {
      return this.value;
    }
  }
  class Ge {
    static findAll(e2, t2, i2) {
      if (void 0 !== t2 || void 0 !== i2) {
        t2 = t2 || "[\\w\\d-]+", i2 = i2 || "[\\w\\d-]+";
        var s2 = new RegExp(`<(${t2}):(${i2})(#\\d+)?((\\s+?[\\w\\d-:]+=("[^"]*"|'[^']*'))*\\s*)(\\/>|>([\\s\\S]*?)<\\/\\1:\\2\\3>)`, "gm");
      } else
        s2 = /<([\w\d-]+):([\w\d-]+)(#\d+)?((\s+?[\w\d-:]+=("[^"]*"|'[^']*'))*\s*)(\/>|>([\s\S]*?)<\/\1:\2\3>)/gm;
      return Ke(e2, s2).map(Ge.unpackMatch);
    }
    static unpackMatch(e2) {
      let t2 = e2[1], i2 = e2[2], s2 = e2[4], n2 = e2[8];
      return new Ge(t2, i2, s2, n2);
    }
    constructor(e2, t2, i2, s2) {
      this.ns = e2, this.name = t2, this.attrString = i2, this.innerXml = s2, this.attrs = je.findAll(i2), this.children = Ge.findAll(s2), this.value = 0 === this.children.length ? Xe(s2) : void 0, this.properties = [...this.attrs, ...this.children];
    }
    get isPrimitive() {
      return void 0 !== this.value && 0 === this.attrs.length && 0 === this.children.length;
    }
    get isListContainer() {
      return 1 === this.children.length && this.children[0].isList;
    }
    get isList() {
      let { ns: e2, name: t2 } = this;
      return "rdf" === e2 && ("Seq" === t2 || "Bag" === t2 || "Alt" === t2);
    }
    get isListItem() {
      return "rdf" === this.ns && "li" === this.name;
    }
    serialize() {
      if (0 === this.properties.length && void 0 === this.value)
        return;
      if (this.isPrimitive)
        return this.value;
      if (this.isListContainer)
        return this.children[0].serialize();
      if (this.isList)
        return We(this.children.map(_e));
      if (this.isListItem && 1 === this.children.length && 0 === this.attrs.length)
        return this.children[0].serialize();
      let e2 = {};
      for (let t2 of this.properties)
        He(t2, e2);
      return void 0 !== this.value && (e2.value = this.value), h(e2);
    }
  }
  function He(e2, t2) {
    let i2 = e2.serialize();
    void 0 !== i2 && (t2[e2.name] = i2);
  }
  var _e = (e2) => e2.serialize(), We = (e2) => 1 === e2.length ? e2[0] : e2, $e = (e2, t2) => t2[e2] ? t2[e2] : t2[e2] = {};
  function Ke(e2, t2) {
    let i2, s2 = [];
    if (!e2)
      return s2;
    for (; null !== (i2 = t2.exec(e2)); )
      s2.push(i2);
    return s2;
  }
  function Xe(e2) {
    if (function(e3) {
      return null == e3 || "null" === e3 || "undefined" === e3 || "" === e3 || "" === e3.trim();
    }(e2))
      return;
    let t2 = Number(e2);
    if (!Number.isNaN(t2))
      return t2;
    let i2 = e2.toLowerCase();
    return "true" === i2 || "false" !== i2 && e2.trim();
  }
  const Ye = ["rdf:li", "rdf:Seq", "rdf:Bag", "rdf:Alt", "rdf:Description"], qe = new RegExp(`(<|\\/)(${Ye.join("|")})`, "g");
  const defaultOptions2 = {
    maxRequests: 6
  };
  class RequestScheduler {
    constructor(options) {
      this.options = {
        ...defaultOptions2,
        ...options
      };
      this.requestQueue = [];
      this.executing = /* @__PURE__ */ new Set();
    }
    remove(p2) {
      this.executing.delete(p2);
      if (!p2.cancelled) {
        p2.completed = true;
        this.enqueue();
      }
    }
    enqueue() {
      for (let numImageRequests = this.executing.size; numImageRequests < this.options.maxRequests && this.requestQueue.length > 0; numImageRequests++) {
        const q2 = this.requestQueue.shift();
        if (q2.cancelled) {
          this.remove(q2);
          continue;
        }
        const p2 = Promise.resolve().then(() => {
          const request2 = q2.ref();
          q2.request = request2;
          return request2;
        });
        this.executing.add(q2);
        p2.then(() => {
          this.remove(q2);
        }).catch(() => {
          this.remove(q2);
        });
      }
    }
    scheduleRequest(fn) {
      const request2 = {
        ref: fn,
        cancelled: false,
        completed: false,
        request: null,
        cancel: () => {
          if (!request2.completed && !request2.cancelled) {
            request2.cancelled = true;
            if (request2.request) {
              request2.request.cancel();
            }
            this.enqueue();
          }
        }
      };
      this.requestQueue.push(request2);
      this.enqueue();
      return request2;
    }
  }
  var _bin = {
    nextZero: function(data, p2) {
      while (data[p2] != 0)
        p2++;
      return p2;
    },
    readUshort: function(buff, p2) {
      return buff[p2] << 8 | buff[p2 + 1];
    },
    writeUshort: function(buff, p2, n2) {
      buff[p2] = n2 >> 8 & 255;
      buff[p2 + 1] = n2 & 255;
    },
    readUint: function(buff, p2) {
      return buff[p2] * (256 * 256 * 256) + (buff[p2 + 1] << 16 | buff[p2 + 2] << 8 | buff[p2 + 3]);
    },
    writeUint: function(buff, p2, n2) {
      buff[p2] = n2 >> 24 & 255;
      buff[p2 + 1] = n2 >> 16 & 255;
      buff[p2 + 2] = n2 >> 8 & 255;
      buff[p2 + 3] = n2 & 255;
    },
    readASCII: function(buff, p2, l2) {
      var s2 = "";
      for (var i2 = 0; i2 < l2; i2++)
        s2 += String.fromCharCode(buff[p2 + i2]);
      return s2;
    },
    writeASCII: function(data, p2, s2) {
      for (var i2 = 0; i2 < s2.length; i2++)
        data[p2 + i2] = s2.charCodeAt(i2);
    },
    readBytes: function(buff, p2, l2) {
      var arr = [];
      for (var i2 = 0; i2 < l2; i2++)
        arr.push(buff[p2 + i2]);
      return arr;
    },
    pad: function(n2) {
      return n2.length < 2 ? "0" + n2 : n2;
    },
    readUTF8: function(buff, p2, l2) {
      var s2 = "", ns;
      for (var i2 = 0; i2 < l2; i2++)
        s2 += "%" + _bin.pad(buff[p2 + i2].toString(16));
      try {
        ns = decodeURIComponent(s2);
      } catch (e2) {
        return _bin.readASCII(buff, p2, l2);
      }
      return ns;
    }
  };
  function toRGBA8(out) {
    var w2 = out.width, h2 = out.height;
    if (out.tabs.acTL == null)
      return [decodeImage(out.data, w2, h2, out).buffer];
    var frms = [];
    if (out.frames[0].data == null)
      out.frames[0].data = out.data;
    var len = w2 * h2 * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
    for (var i2 = 0; i2 < out.frames.length; i2++) {
      var frm = out.frames[i2];
      var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
      var fdata = decodeImage(frm.data, fw, fh, out);
      if (i2 != 0)
        for (var j2 = 0; j2 < len; j2++)
          prev[j2] = img[j2];
      if (frm.blend == 0)
        _copyTile(fdata, fw, fh, img, w2, h2, fx, fy, 0);
      else if (frm.blend == 1)
        _copyTile(fdata, fw, fh, img, w2, h2, fx, fy, 1);
      frms.push(img.buffer.slice(0));
      if (frm.dispose == 0) ;
      else if (frm.dispose == 1)
        _copyTile(empty, fw, fh, img, w2, h2, fx, fy, 0);
      else if (frm.dispose == 2)
        for (var j2 = 0; j2 < len; j2++)
          img[j2] = prev[j2];
    }
    return frms;
  }
  function decodeImage(data, w2, h2, out) {
    var area = w2 * h2, bpp = _getBPP(out);
    var bpl = Math.ceil(w2 * bpp / 8);
    var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
    var ctype = out.ctype, depth = out.depth;
    var rs = _bin.readUshort;
    if (ctype == 6) {
      var qarea = area << 2;
      if (depth == 8)
        for (var i2 = 0; i2 < qarea; i2 += 4) {
          bf[i2] = data[i2];
          bf[i2 + 1] = data[i2 + 1];
          bf[i2 + 2] = data[i2 + 2];
          bf[i2 + 3] = data[i2 + 3];
        }
      if (depth == 16)
        for (var i2 = 0; i2 < qarea; i2++) {
          bf[i2] = data[i2 << 1];
        }
    } else if (ctype == 2) {
      var ts = out.tabs["tRNS"];
      if (ts == null) {
        if (depth == 8)
          for (var i2 = 0; i2 < area; i2++) {
            var ti = i2 * 3;
            bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
          }
        if (depth == 16)
          for (var i2 = 0; i2 < area; i2++) {
            var ti = i2 * 6;
            bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
          }
      } else {
        var tr = ts[0], tg = ts[1], tb = ts[2];
        if (depth == 8)
          for (var i2 = 0; i2 < area; i2++) {
            var qi = i2 << 2, ti = i2 * 3;
            bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
            if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
              bf[qi + 3] = 0;
          }
        if (depth == 16)
          for (var i2 = 0; i2 < area; i2++) {
            var qi = i2 << 2, ti = i2 * 6;
            bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
            if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
              bf[qi + 3] = 0;
          }
      }
    } else if (ctype == 3) {
      var p2 = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
      if (depth == 1)
        for (var y2 = 0; y2 < h2; y2++) {
          var s0 = y2 * bpl, t0 = y2 * w2;
          for (var i2 = 0; i2 < w2; i2++) {
            var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 3)] >> 7 - ((i2 & 7) << 0) & 1, cj = 3 * j2;
            bf[qi] = p2[cj];
            bf[qi + 1] = p2[cj + 1];
            bf[qi + 2] = p2[cj + 2];
            bf[qi + 3] = j2 < tl ? ap[j2] : 255;
          }
        }
      if (depth == 2)
        for (var y2 = 0; y2 < h2; y2++) {
          var s0 = y2 * bpl, t0 = y2 * w2;
          for (var i2 = 0; i2 < w2; i2++) {
            var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 2)] >> 6 - ((i2 & 3) << 1) & 3, cj = 3 * j2;
            bf[qi] = p2[cj];
            bf[qi + 1] = p2[cj + 1];
            bf[qi + 2] = p2[cj + 2];
            bf[qi + 3] = j2 < tl ? ap[j2] : 255;
          }
        }
      if (depth == 4)
        for (var y2 = 0; y2 < h2; y2++) {
          var s0 = y2 * bpl, t0 = y2 * w2;
          for (var i2 = 0; i2 < w2; i2++) {
            var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 1)] >> 4 - ((i2 & 1) << 2) & 15, cj = 3 * j2;
            bf[qi] = p2[cj];
            bf[qi + 1] = p2[cj + 1];
            bf[qi + 2] = p2[cj + 2];
            bf[qi + 3] = j2 < tl ? ap[j2] : 255;
          }
        }
      if (depth == 8)
        for (var i2 = 0; i2 < area; i2++) {
          var qi = i2 << 2, j2 = data[i2], cj = 3 * j2;
          bf[qi] = p2[cj];
          bf[qi + 1] = p2[cj + 1];
          bf[qi + 2] = p2[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
    } else if (ctype == 4) {
      if (depth == 8)
        for (var i2 = 0; i2 < area; i2++) {
          var qi = i2 << 2, di = i2 << 1, gr = data[di];
          bf[qi] = gr;
          bf[qi + 1] = gr;
          bf[qi + 2] = gr;
          bf[qi + 3] = data[di + 1];
        }
      if (depth == 16)
        for (var i2 = 0; i2 < area; i2++) {
          var qi = i2 << 2, di = i2 << 2, gr = data[di];
          bf[qi] = gr;
          bf[qi + 1] = gr;
          bf[qi + 2] = gr;
          bf[qi + 3] = data[di + 2];
        }
    } else if (ctype == 0) {
      var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
      for (var y2 = 0; y2 < h2; y2++) {
        var off = y2 * bpl, to = y2 * w2;
        if (depth == 1)
          for (var x2 = 0; x2 < w2; x2++) {
            var gr = 255 * (data[off + (x2 >>> 3)] >>> 7 - (x2 & 7) & 1), al = gr == tr * 255 ? 0 : 255;
            bf32[to + x2] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 2)
          for (var x2 = 0; x2 < w2; x2++) {
            var gr = 85 * (data[off + (x2 >>> 2)] >>> 6 - ((x2 & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
            bf32[to + x2] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 4)
          for (var x2 = 0; x2 < w2; x2++) {
            var gr = 17 * (data[off + (x2 >>> 1)] >>> 4 - ((x2 & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
            bf32[to + x2] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 8)
          for (var x2 = 0; x2 < w2; x2++) {
            var gr = data[off + x2], al = gr == tr ? 0 : 255;
            bf32[to + x2] = al << 24 | gr << 16 | gr << 8 | gr;
          }
        else if (depth == 16)
          for (var x2 = 0; x2 < w2; x2++) {
            var gr = data[off + (x2 << 1)], al = rs(data, off + (x2 << 1)) == tr ? 0 : 255;
            bf32[to + x2] = al << 24 | gr << 16 | gr << 8 | gr;
          }
      }
    }
    return bf;
  }
  function decode2(buff) {
    var data = new Uint8Array(buff), offset = 8, bin = _bin, rUs = bin.readUshort, rUi = bin.readUint;
    var out = { tabs: {}, frames: [] };
    var dd = new Uint8Array(data.length), doff = 0;
    var fd, foff = 0;
    var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
    for (var i2 = 0; i2 < 8; i2++)
      if (data[i2] != mgck[i2])
        throw "The input is not a PNG file!";
    while (offset < data.length) {
      var len = bin.readUint(data, offset);
      offset += 4;
      var type = bin.readASCII(data, offset, 4);
      offset += 4;
      if (type == "IHDR") {
        _IHDR(data, offset, out);
      } else if (type == "iCCP") {
        var off = offset;
        while (data[off] != 0)
          off++;
        bin.readASCII(data, offset, off - offset);
        data[off + 1];
        var fil = data.slice(off + 2, offset + len);
        var res = null;
        try {
          res = _inflate(fil);
        } catch (e2) {
          res = inflateRaw(fil);
        }
        out.tabs[type] = res;
      } else if (type == "CgBI") {
        out.tabs[type] = data.slice(offset, offset + 4);
      } else if (type == "IDAT") {
        for (var i2 = 0; i2 < len; i2++)
          dd[doff + i2] = data[offset + i2];
        doff += len;
      } else if (type == "acTL") {
        out.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) };
        fd = new Uint8Array(data.length);
      } else if (type == "fcTL") {
        if (foff != 0) {
          var fr = out.frames[out.frames.length - 1];
          fr.data = _decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
          foff = 0;
        }
        var rct = { x: rUi(data, offset + 12), y: rUi(data, offset + 16), width: rUi(data, offset + 4), height: rUi(data, offset + 8) };
        var del = rUs(data, offset + 22);
        del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
        var frm = { rect: rct, delay: Math.round(del * 1e3), dispose: data[offset + 24], blend: data[offset + 25] };
        out.frames.push(frm);
      } else if (type == "fdAT") {
        for (var i2 = 0; i2 < len - 4; i2++)
          fd[foff + i2] = data[offset + i2 + 4];
        foff += len - 4;
      } else if (type == "pHYs") {
        out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
      } else if (type == "cHRM") {
        out.tabs[type] = [];
        for (var i2 = 0; i2 < 8; i2++)
          out.tabs[type].push(bin.readUint(data, offset + i2 * 4));
      } else if (type == "tEXt" || type == "zTXt") {
        if (out.tabs[type] == null)
          out.tabs[type] = {};
        var nz = bin.nextZero(data, offset);
        var keyw = bin.readASCII(data, offset, nz - offset);
        var text, tl = offset + len - nz - 1;
        if (type == "tEXt")
          text = bin.readASCII(data, nz + 1, tl);
        else {
          var bfr = _inflate(data.slice(nz + 2, nz + 2 + tl));
          text = bin.readUTF8(bfr, 0, bfr.length);
        }
        out.tabs[type][keyw] = text;
      } else if (type == "iTXt") {
        if (out.tabs[type] == null)
          out.tabs[type] = {};
        var nz = 0, off = offset;
        nz = bin.nextZero(data, off);
        var keyw = bin.readASCII(data, off, nz - off);
        off = nz + 1;
        var cflag = data[off];
        data[off + 1];
        off += 2;
        nz = bin.nextZero(data, off);
        bin.readASCII(data, off, nz - off);
        off = nz + 1;
        nz = bin.nextZero(data, off);
        bin.readUTF8(data, off, nz - off);
        off = nz + 1;
        var text, tl = len - (off - offset);
        if (cflag == 0)
          text = bin.readUTF8(data, off, tl);
        else {
          var bfr = _inflate(data.slice(off, off + tl));
          text = bin.readUTF8(bfr, 0, bfr.length);
        }
        out.tabs[type][keyw] = text;
      } else if (type == "PLTE") {
        out.tabs[type] = bin.readBytes(data, offset, len);
      } else if (type == "hIST") {
        var pl = out.tabs["PLTE"].length / 3;
        out.tabs[type] = [];
        for (var i2 = 0; i2 < pl; i2++)
          out.tabs[type].push(rUs(data, offset + i2 * 2));
      } else if (type == "tRNS") {
        if (out.ctype == 3)
          out.tabs[type] = bin.readBytes(data, offset, len);
        else if (out.ctype == 0)
          out.tabs[type] = rUs(data, offset);
        else if (out.ctype == 2)
          out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
      } else if (type == "gAMA")
        out.tabs[type] = bin.readUint(data, offset) / 1e5;
      else if (type == "sRGB")
        out.tabs[type] = data[offset];
      else if (type == "bKGD") {
        if (out.ctype == 0 || out.ctype == 4)
          out.tabs[type] = [rUs(data, offset)];
        else if (out.ctype == 2 || out.ctype == 6)
          out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
        else if (out.ctype == 3)
          out.tabs[type] = data[offset];
      } else if (type == "IEND") {
        break;
      }
      offset += len;
      bin.readUint(data, offset);
      offset += 4;
    }
    if (foff != 0) {
      var fr = out.frames[out.frames.length - 1];
      fr.data = _decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
    }
    out.data = _decompress(out, dd, out.width, out.height);
    delete out.compress;
    delete out.interlace;
    delete out.filter;
    return out;
  }
  function _decompress(out, dd, w2, h2) {
    var bpp = _getBPP(out), bpl = Math.ceil(w2 * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h2);
    if (out.tabs["CgBI"])
      dd = inflateRaw(dd, buff);
    else
      dd = _inflate(dd, buff);
    if (out.interlace == 0)
      dd = _filterZero(dd, out, 0, w2, h2);
    else if (out.interlace == 1)
      dd = _readInterlace(dd, out);
    return dd;
  }
  function _inflate(data, buff) {
    var out = inflateRaw(new Uint8Array(data.buffer, 2, data.length - 6), buff);
    return out;
  }
  var inflateRaw = function() {
    var H2 = {};
    H2.H = {};
    H2.H.N = function(N2, W2) {
      var R2 = Uint8Array, i2 = 0, m2 = 0, J2 = 0, h2 = 0, Q2 = 0, X2 = 0, u2 = 0, w2 = 0, d2 = 0, v2, C2;
      if (N2[0] == 3 && N2[1] == 0)
        return W2 ? W2 : new R2(0);
      var V2 = H2.H, n2 = V2.b, A2 = V2.e, l2 = V2.R, M2 = V2.n, I2 = V2.A, e2 = V2.Z, b2 = V2.m, Z2 = W2 == null;
      if (Z2)
        W2 = new R2(N2.length >>> 2 << 5);
      while (i2 == 0) {
        i2 = n2(N2, d2, 1);
        m2 = n2(N2, d2 + 1, 2);
        d2 += 3;
        if (m2 == 0) {
          if ((d2 & 7) != 0)
            d2 += 8 - (d2 & 7);
          var D2 = (d2 >>> 3) + 4, q2 = N2[D2 - 4] | N2[D2 - 3] << 8;
          if (Z2)
            W2 = H2.H.W(W2, w2 + q2);
          W2.set(new R2(N2.buffer, N2.byteOffset + D2, q2), w2);
          d2 = D2 + q2 << 3;
          w2 += q2;
          continue;
        }
        if (Z2)
          W2 = H2.H.W(W2, w2 + (1 << 17));
        if (m2 == 1) {
          v2 = b2.J;
          C2 = b2.h;
          X2 = (1 << 9) - 1;
          u2 = (1 << 5) - 1;
        }
        if (m2 == 2) {
          J2 = A2(N2, d2, 5) + 257;
          h2 = A2(N2, d2 + 5, 5) + 1;
          Q2 = A2(N2, d2 + 10, 4) + 4;
          d2 += 14;
          var j2 = 1;
          for (var c2 = 0; c2 < 38; c2 += 2) {
            b2.Q[c2] = 0;
            b2.Q[c2 + 1] = 0;
          }
          for (var c2 = 0; c2 < Q2; c2++) {
            var K2 = A2(N2, d2 + c2 * 3, 3);
            b2.Q[(b2.X[c2] << 1) + 1] = K2;
            if (K2 > j2)
              j2 = K2;
          }
          d2 += 3 * Q2;
          M2(b2.Q, j2);
          I2(b2.Q, j2, b2.u);
          v2 = b2.w;
          C2 = b2.d;
          d2 = l2(b2.u, (1 << j2) - 1, J2 + h2, N2, d2, b2.v);
          var r2 = V2.V(b2.v, 0, J2, b2.C);
          X2 = (1 << r2) - 1;
          var S2 = V2.V(b2.v, J2, h2, b2.D);
          u2 = (1 << S2) - 1;
          M2(b2.C, r2);
          I2(b2.C, r2, v2);
          M2(b2.D, S2);
          I2(b2.D, S2, C2);
        }
        while (true) {
          var T2 = v2[e2(N2, d2) & X2];
          d2 += T2 & 15;
          var p2 = T2 >>> 4;
          if (p2 >>> 8 == 0) {
            W2[w2++] = p2;
          } else if (p2 == 256) {
            break;
          } else {
            var z2 = w2 + p2 - 254;
            if (p2 > 264) {
              var _2 = b2.q[p2 - 257];
              z2 = w2 + (_2 >>> 3) + A2(N2, d2, _2 & 7);
              d2 += _2 & 7;
            }
            var $2 = C2[e2(N2, d2) & u2];
            d2 += $2 & 15;
            var s2 = $2 >>> 4, Y2 = b2.c[s2], a2 = (Y2 >>> 4) + n2(N2, d2, Y2 & 15);
            d2 += Y2 & 15;
            while (w2 < z2) {
              W2[w2] = W2[w2++ - a2];
              W2[w2] = W2[w2++ - a2];
              W2[w2] = W2[w2++ - a2];
              W2[w2] = W2[w2++ - a2];
            }
            w2 = z2;
          }
        }
      }
      return W2.length == w2 ? W2 : W2.slice(0, w2);
    };
    H2.H.W = function(N2, W2) {
      var R2 = N2.length;
      if (W2 <= R2)
        return N2;
      var V2 = new Uint8Array(R2 << 1);
      V2.set(N2, 0);
      return V2;
    };
    H2.H.R = function(N2, W2, R2, V2, n2, A2) {
      var l2 = H2.H.e, M2 = H2.H.Z, I2 = 0;
      while (I2 < R2) {
        var e2 = N2[M2(V2, n2) & W2];
        n2 += e2 & 15;
        var b2 = e2 >>> 4;
        if (b2 <= 15) {
          A2[I2] = b2;
          I2++;
        } else {
          var Z2 = 0, m2 = 0;
          if (b2 == 16) {
            m2 = 3 + l2(V2, n2, 2);
            n2 += 2;
            Z2 = A2[I2 - 1];
          } else if (b2 == 17) {
            m2 = 3 + l2(V2, n2, 3);
            n2 += 3;
          } else if (b2 == 18) {
            m2 = 11 + l2(V2, n2, 7);
            n2 += 7;
          }
          var J2 = I2 + m2;
          while (I2 < J2) {
            A2[I2] = Z2;
            I2++;
          }
        }
      }
      return n2;
    };
    H2.H.V = function(N2, W2, R2, V2) {
      var n2 = 0, A2 = 0, l2 = V2.length >>> 1;
      while (A2 < R2) {
        var M2 = N2[A2 + W2];
        V2[A2 << 1] = 0;
        V2[(A2 << 1) + 1] = M2;
        if (M2 > n2)
          n2 = M2;
        A2++;
      }
      while (A2 < l2) {
        V2[A2 << 1] = 0;
        V2[(A2 << 1) + 1] = 0;
        A2++;
      }
      return n2;
    };
    H2.H.n = function(N2, W2) {
      var R2 = H2.H.m, V2 = N2.length, n2, A2, l2, M2, I2, e2 = R2.j;
      for (var M2 = 0; M2 <= W2; M2++)
        e2[M2] = 0;
      for (M2 = 1; M2 < V2; M2 += 2)
        e2[N2[M2]]++;
      var b2 = R2.K;
      n2 = 0;
      e2[0] = 0;
      for (A2 = 1; A2 <= W2; A2++) {
        n2 = n2 + e2[A2 - 1] << 1;
        b2[A2] = n2;
      }
      for (l2 = 0; l2 < V2; l2 += 2) {
        I2 = N2[l2 + 1];
        if (I2 != 0) {
          N2[l2] = b2[I2];
          b2[I2]++;
        }
      }
    };
    H2.H.A = function(N2, W2, R2) {
      var V2 = N2.length, n2 = H2.H.m, A2 = n2.r;
      for (var l2 = 0; l2 < V2; l2 += 2)
        if (N2[l2 + 1] != 0) {
          var M2 = l2 >> 1, I2 = N2[l2 + 1], e2 = M2 << 4 | I2, b2 = W2 - I2, Z2 = N2[l2] << b2, m2 = Z2 + (1 << b2);
          while (Z2 != m2) {
            var J2 = A2[Z2] >>> 15 - W2;
            R2[J2] = e2;
            Z2++;
          }
        }
    };
    H2.H.l = function(N2, W2) {
      var R2 = H2.H.m.r, V2 = 15 - W2;
      for (var n2 = 0; n2 < N2.length; n2 += 2) {
        var A2 = N2[n2] << W2 - N2[n2 + 1];
        N2[n2] = R2[A2] >>> V2;
      }
    };
    H2.H.M = function(N2, W2, R2) {
      R2 = R2 << (W2 & 7);
      var V2 = W2 >>> 3;
      N2[V2] |= R2;
      N2[V2 + 1] |= R2 >>> 8;
    };
    H2.H.I = function(N2, W2, R2) {
      R2 = R2 << (W2 & 7);
      var V2 = W2 >>> 3;
      N2[V2] |= R2;
      N2[V2 + 1] |= R2 >>> 8;
      N2[V2 + 2] |= R2 >>> 16;
    };
    H2.H.e = function(N2, W2, R2) {
      return (N2[W2 >>> 3] | N2[(W2 >>> 3) + 1] << 8) >>> (W2 & 7) & (1 << R2) - 1;
    };
    H2.H.b = function(N2, W2, R2) {
      return (N2[W2 >>> 3] | N2[(W2 >>> 3) + 1] << 8 | N2[(W2 >>> 3) + 2] << 16) >>> (W2 & 7) & (1 << R2) - 1;
    };
    H2.H.Z = function(N2, W2) {
      return (N2[W2 >>> 3] | N2[(W2 >>> 3) + 1] << 8 | N2[(W2 >>> 3) + 2] << 16) >>> (W2 & 7);
    };
    H2.H.i = function(N2, W2) {
      return (N2[W2 >>> 3] | N2[(W2 >>> 3) + 1] << 8 | N2[(W2 >>> 3) + 2] << 16 | N2[(W2 >>> 3) + 3] << 24) >>> (W2 & 7);
    };
    H2.H.m = function() {
      var N2 = Uint16Array, W2 = Uint32Array;
      return { K: new N2(16), j: new N2(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new N2(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new W2(32), J: new N2(512), _: [], h: new N2(32), $: [], w: new N2(32768), C: [], v: [], d: new N2(32768), D: [], u: new N2(512), Q: [], r: new N2(1 << 15), s: new W2(286), Y: new W2(30), a: new W2(19), t: new W2(15e3), k: new N2(1 << 16), g: new N2(1 << 15) };
    }();
    (function() {
      var N2 = H2.H.m, W2 = 1 << 15;
      for (var R2 = 0; R2 < W2; R2++) {
        var V2 = R2;
        V2 = (V2 & 2863311530) >>> 1 | (V2 & 1431655765) << 1;
        V2 = (V2 & 3435973836) >>> 2 | (V2 & 858993459) << 2;
        V2 = (V2 & 4042322160) >>> 4 | (V2 & 252645135) << 4;
        V2 = (V2 & 4278255360) >>> 8 | (V2 & 16711935) << 8;
        N2.r[R2] = (V2 >>> 16 | V2 << 16) >>> 17;
      }
      function n2(A2, l2, M2) {
        while (l2-- != 0)
          A2.push(0, M2);
      }
      for (var R2 = 0; R2 < 32; R2++) {
        N2.q[R2] = N2.S[R2] << 3 | N2.T[R2];
        N2.c[R2] = N2.p[R2] << 4 | N2.z[R2];
      }
      n2(N2._, 144, 8);
      n2(N2._, 255 - 143, 9);
      n2(N2._, 279 - 255, 7);
      n2(N2._, 287 - 279, 8);
      H2.H.n(N2._, 9);
      H2.H.A(N2._, 9, N2.J);
      H2.H.l(N2._, 9);
      n2(N2.$, 32, 5);
      H2.H.n(N2.$, 5);
      H2.H.A(N2.$, 5, N2.h);
      H2.H.l(N2.$, 5);
      n2(N2.Q, 19, 0);
      n2(N2.C, 286, 0);
      n2(N2.D, 30, 0);
      n2(N2.v, 320, 0);
    })();
    return H2.H.N;
  }();
  function _readInterlace(data, out) {
    var w2 = out.width, h2 = out.height;
    var bpp = _getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w2 * bpp / 8);
    var img = new Uint8Array(h2 * bpl);
    var di = 0;
    var starting_row = [0, 0, 4, 0, 2, 0, 1];
    var starting_col = [0, 4, 0, 2, 0, 1, 0];
    var row_increment = [8, 8, 8, 4, 4, 2, 2];
    var col_increment = [8, 8, 4, 4, 2, 2, 1];
    var pass = 0;
    while (pass < 7) {
      var ri = row_increment[pass], ci = col_increment[pass];
      var sw = 0, sh = 0;
      var cr = starting_row[pass];
      while (cr < h2) {
        cr += ri;
        sh++;
      }
      var cc = starting_col[pass];
      while (cc < w2) {
        cc += ci;
        sw++;
      }
      var bpll = Math.ceil(sw * bpp / 8);
      _filterZero(data, out, di, sw, sh);
      var y2 = 0, row = starting_row[pass];
      while (row < h2) {
        var col = starting_col[pass];
        var cdi = di + y2 * bpll << 3;
        while (col < w2) {
          if (bpp == 1) {
            var val = data[cdi >> 3];
            val = val >> 7 - (cdi & 7) & 1;
            img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
          }
          if (bpp == 2) {
            var val = data[cdi >> 3];
            val = val >> 6 - (cdi & 7) & 3;
            img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
          }
          if (bpp == 4) {
            var val = data[cdi >> 3];
            val = val >> 4 - (cdi & 7) & 15;
            img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
          }
          if (bpp >= 8) {
            var ii = row * bpl + col * cbpp;
            for (var j2 = 0; j2 < cbpp; j2++)
              img[ii + j2] = data[(cdi >> 3) + j2];
          }
          cdi += bpp;
          col += ci;
        }
        y2++;
        row += ri;
      }
      if (sw * sh != 0)
        di += sh * (1 + bpll);
      pass = pass + 1;
    }
    return img;
  }
  function _getBPP(out) {
    var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
    return noc * out.depth;
  }
  function _filterZero(data, out, off, w2, h2) {
    var bpp = _getBPP(out), bpl = Math.ceil(w2 * bpp / 8);
    bpp = Math.ceil(bpp / 8);
    var i2, di, type = data[off], x2 = 0;
    if (type > 1)
      data[off] = [0, 0, 1][type - 2];
    if (type == 3)
      for (x2 = bpp; x2 < bpl; x2++)
        data[x2 + 1] = data[x2 + 1] + (data[x2 + 1 - bpp] >>> 1) & 255;
    for (var y2 = 0; y2 < h2; y2++) {
      i2 = off + y2 * bpl;
      di = i2 + y2 + 1;
      type = data[di - 1];
      x2 = 0;
      if (type == 0)
        for (; x2 < bpl; x2++)
          data[i2 + x2] = data[di + x2];
      else if (type == 1) {
        for (; x2 < bpp; x2++)
          data[i2 + x2] = data[di + x2];
        for (; x2 < bpl; x2++)
          data[i2 + x2] = data[di + x2] + data[i2 + x2 - bpp];
      } else if (type == 2) {
        for (; x2 < bpl; x2++)
          data[i2 + x2] = data[di + x2] + data[i2 + x2 - bpl];
      } else if (type == 3) {
        for (; x2 < bpp; x2++)
          data[i2 + x2] = data[di + x2] + (data[i2 + x2 - bpl] >>> 1);
        for (; x2 < bpl; x2++)
          data[i2 + x2] = data[di + x2] + (data[i2 + x2 - bpl] + data[i2 + x2 - bpp] >>> 1);
      } else {
        for (; x2 < bpp; x2++)
          data[i2 + x2] = data[di + x2] + _paeth(0, data[i2 + x2 - bpl], 0);
        for (; x2 < bpl; x2++)
          data[i2 + x2] = data[di + x2] + _paeth(data[i2 + x2 - bpp], data[i2 + x2 - bpl], data[i2 + x2 - bpp - bpl]);
      }
    }
    return data;
  }
  function _paeth(a2, b2, c2) {
    var p2 = a2 + b2 - c2, pa = p2 - a2, pb = p2 - b2, pc = p2 - c2;
    if (pa * pa <= pb * pb && pa * pa <= pc * pc)
      return a2;
    else if (pb * pb <= pc * pc)
      return b2;
    return c2;
  }
  function _IHDR(data, offset, out) {
    out.width = _bin.readUint(data, offset);
    offset += 4;
    out.height = _bin.readUint(data, offset);
    offset += 4;
    out.depth = data[offset];
    offset++;
    out.ctype = data[offset];
    offset++;
    out.compress = data[offset];
    offset++;
    out.filter = data[offset];
    offset++;
    out.interlace = data[offset];
    offset++;
  }
  function _copyTile(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
    var w2 = Math.min(sw, tw), h2 = Math.min(sh, th);
    var si = 0, ti = 0;
    for (var y2 = 0; y2 < h2; y2++)
      for (var x2 = 0; x2 < w2; x2++) {
        if (xoff >= 0 && yoff >= 0) {
          si = y2 * sw + x2 << 2;
          ti = (yoff + y2) * tw + xoff + x2 << 2;
        } else {
          si = (-yoff + y2) * sw - xoff + x2 << 2;
          ti = y2 * tw + x2 << 2;
        }
        if (mode == 0) {
          tb[ti] = sb[si];
          tb[ti + 1] = sb[si + 1];
          tb[ti + 2] = sb[si + 2];
          tb[ti + 3] = sb[si + 3];
        } else if (mode == 1) {
          var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
          var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
          var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
          tb[ti + 3] = 255 * oa;
          tb[ti + 0] = (fr + br * ifa) * ioa;
          tb[ti + 1] = (fg + bg * ifa) * ioa;
          tb[ti + 2] = (fb + bb * ifa) * ioa;
        } else if (mode == 2) {
          var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
          var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
          if (fa == ba && fr == br && fg == bg && fb == bb) {
            tb[ti] = 0;
            tb[ti + 1] = 0;
            tb[ti + 2] = 0;
            tb[ti + 3] = 0;
          } else {
            tb[ti] = fr;
            tb[ti + 1] = fg;
            tb[ti + 2] = fb;
            tb[ti + 3] = fa;
          }
        } else if (mode == 3) {
          var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
          var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
          if (fa == ba && fr == br && fg == bg && fb == bb)
            continue;
          if (fa < 220 && ba > 20)
            return false;
        }
      }
    return true;
  }
  class AJAXError extends Error {
    constructor(status, statusText, url, body) {
      super(`AJAXError: ${statusText} (${status}): ${url}`);
      this.status = status;
      this.statusText = statusText;
      this.url = url;
      this.body = body;
    }
  }
  const isFileURL = (url) => /^file:/.test(url) || /^file:/.test(getReferrer()) && !/^\w+:/.test(url);
  function makeFetchRequest(requestParameters, callback) {
    const controller = new AbortController();
    const request2 = new Request(requestParameters.url, {
      method: requestParameters.method || "GET",
      body: requestParameters.body,
      credentials: requestParameters.credentials,
      headers: requestParameters.headers,
      referrer: getReferrer(),
      signal: controller.signal
    });
    let complete = false;
    let aborted = false;
    if (requestParameters.type === "json") {
      request2.headers.set("Accept", "application/json");
    }
    const validateOrFetch = (err, cachedResponse, responseIsFresh) => {
      if (aborted)
        return;
      if (err) {
        if (err.message !== "SecurityError") {
          warnOnce(err);
        }
      }
      if (cachedResponse && responseIsFresh) {
        return finishRequest(cachedResponse);
      }
      fetch(request2).then((response) => {
        if (response.ok) {
          return finishRequest(response);
        } else {
          return response.blob().then((body) => callback(new AJAXError(response.status, response.statusText, requestParameters.url, body)));
        }
      }).catch((error) => {
        if (error.code === 20) ;
        callback(new Error(error.message));
      });
    };
    const finishRequest = (response) => {
      (requestParameters.type === "arrayBuffer" ? response.arrayBuffer() : requestParameters.type === "json" ? response.json() : response.text()).then((result) => {
        if (aborted)
          return;
        complete = true;
        callback(null, result, response.headers.get("Cache-Control"), response.headers.get("Expires"));
      }).catch((err) => {
        if (!aborted)
          callback(new Error(err.message));
      });
    };
    validateOrFetch(null, null);
    return {
      cancel: () => {
        aborted = true;
        if (!complete)
          controller.abort();
      }
    };
  }
  function makeXMLHttpRequest(requestParameters, callback) {
    const xhr = new XMLHttpRequest();
    xhr.open(requestParameters.method || "GET", requestParameters.url, true);
    if (requestParameters.type === "arrayBuffer") {
      xhr.responseType = "arraybuffer";
    }
    for (const k2 in requestParameters.headers) {
      xhr.setRequestHeader(k2, requestParameters.headers[k2]);
    }
    if (requestParameters.type === "json") {
      xhr.responseType = "text";
      xhr.setRequestHeader("Accept", "application/json");
    }
    xhr.withCredentials = requestParameters.credentials === "include";
    xhr.onerror = () => {
      callback(new Error(xhr.statusText));
    };
    xhr.onload = () => {
      if ((xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) && xhr.response !== null) {
        let data = xhr.response;
        if (requestParameters.type === "json") {
          try {
            data = JSON.parse(xhr.response);
          } catch (err) {
            return callback(err);
          }
        }
        callback(null, data, xhr.getResponseHeader("Cache-Control"), xhr.getResponseHeader("Expires"));
      } else {
        const body = new Blob([xhr.response], { type: xhr.getResponseHeader("Content-Type") });
        callback(new AJAXError(xhr.status, xhr.statusText, requestParameters.url, body));
      }
    };
    xhr.send(requestParameters.body);
    return { cancel: () => xhr.abort() };
  }
  const makeRequest = function(requestParameters, callback) {
    if (/:\/\//.test(requestParameters.url) && !/^https?:|^file:/.test(requestParameters.url)) {
      if (isWorker() && self.worker && self.worker.actor) {
        return self.worker.actor.send("getResource", requestParameters, callback);
      }
      if (!isWorker()) {
        return makeFetchRequest(requestParameters, callback);
      }
    }
    if (!isFileURL(requestParameters.url)) {
      if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")
      ) {
        return makeFetchRequest(requestParameters, callback);
      }
      if (isWorker() && self.worker && self.worker.actor) {
        const queueOnMainThread = true;
        return self.worker.actor.send("getResource", requestParameters, callback, void 0, queueOnMainThread);
      }
    }
    return makeXMLHttpRequest(requestParameters, callback);
  };
  let pool;
  function getPool() {
    if (!pool) {
      pool = new self.GeoTIFF.Pool();
    }
    return pool;
  }
  class RequestAdapter {
    constructor(options) {
      this.requestScheduler = new RequestScheduler(options);
    }
    getResource(mapId, params, callback) {
      return makeRequest(params, callback);
    }
    /**
     * arrayBuffer 转 Unit8
     * @param data
     * @param callback
     */
    arrayBuffer2unit8(data, callback) {
      const pngImage = decode2(data);
      const pixels = toRGBA8(pngImage);
      callback(null, {
        data: new Uint8Array(pixels[0]),
        width: pngImage.width,
        height: pngImage.height
      });
    }
    /**
     * arrayBuffer 转图像
     * 1. 如果支持 ImageBitmap 则生成 `ImageBitmap` 除了极少数浏览器不支持外兼容性尚可
     * 2. 在 safari 和移动浏览器下配合 rgba2float 有精度问题，不建议使用
     * @param data
     * @param callback
     */
    arrayBuffer2Image(data, callback) {
      const imageBitmapSupported = typeof createImageBitmap === "function";
      if (imageBitmapSupported) {
        arrayBufferToImageBitmap(data, callback);
      } else {
        this.arrayBuffer2unit8(data, callback);
      }
    }
    /**
     * geotiff 解析
     * @param data
     * @param callback
     */
    arrayBuffer2tiff(data, callback) {
      if (!self.GeoTIFF) {
        throw new Error("Must config [geotiff](https://github.com/geotiffjs/geotiff.js) dep use `configDeps`");
      }
      self.GeoTIFF.fromArrayBuffer(data).then((geotiff) => {
        geotiff.getImage().then((image) => {
          const result = {};
          const fileDirectory = image.fileDirectory;
          const { GeographicTypeGeoKey, ProjectedCSTypeGeoKey } = image.getGeoKeys();
          result.projection = ProjectedCSTypeGeoKey || GeographicTypeGeoKey;
          const height = image.getHeight();
          result.height = height;
          const width = image.getWidth();
          result.width = width;
          const [resolutionX, resolutionY] = image.getResolution();
          result.pixelHeight = Math.abs(resolutionY);
          result.pixelWidth = Math.abs(resolutionX);
          const [originX, originY] = image.getOrigin();
          result.xmin = originX;
          result.xmax = result.xmin + width * result.pixelWidth;
          result.ymax = originY;
          result.ymin = result.ymax - height * result.pixelHeight;
          result.noDataValue = fileDirectory.GDAL_NODATA ? parseFloat(fileDirectory.GDAL_NODATA) : null;
          result.numberOfRasters = fileDirectory.SamplesPerPixel;
          image.readRasters({ pool: getPool() }).then((rasters) => {
            result.rasters = rasters;
            const r2 = rasters[0];
            if (r2) {
              let i2 = 0;
              const bands = rasters.length;
              const d2 = new r2.constructor(r2.length * bands);
              for (; i2 < r2.length; i2++) {
                for (let j2 = 0; j2 < bands; j2++) {
                  d2[i2 + j2] = rasters[j2][i2];
                }
              }
              result.data = d2;
            }
            result.metadata = image.getGDALMetadata();
            const metadata = parseMetedata(fileDirectory.ImageDescription || "");
            result.min = metadata.min;
            result.max = metadata.max;
            result.isTiff = true;
            callback(null, result);
          }).catch((err) => {
            callback(err);
          });
        }).catch((err) => {
          callback(err);
        });
      }).catch((err) => {
        callback(err);
      });
    }
    /**
     * 解析 exif 信息
     * @param data
     * @param callback
     */
    parseExif(data, callback) {
      Z(data).then((res) => {
        this.arrayBuffer2Image(data, (error, image) => {
          if (error) {
            callback(error);
          } else {
            callback(null, {
              data: isImageBitmap2(image) ? image : image.data,
              width: image.width,
              height: image.height,
              exif: res,
              withExif: true
            });
          }
        });
      }).catch((err) => {
        callback(err);
      });
    }
    fetch(params, callback) {
      let aborted = false;
      const r2 = this.requestScheduler.scheduleRequest(() => {
        const p2 = new Promise((resolve) => {
          const request2 = makeRequest(params, (...args) => {
            if (aborted) {
              resolve(false);
              return;
            }
            callback(...args);
            resolve(args);
          });
          p2.cancel = () => {
            request2.cancel();
          };
        });
        return p2;
      });
      return {
        cancel: () => {
          aborted = true;
          r2.cancel();
        }
      };
    }
  }
  let request = null;
  function getRequest(options = {}, force = false) {
    if (!request || force) {
      request = new RequestAdapter(options);
    }
    return request;
  }
  const registry = {};
  function register(name, klass, options = {}) {
    if (registry[name])
      throw new Error(`${name} is already registered.`);
    Object.defineProperty(klass, "_classRegistryKey", {
      value: name,
      writeable: false
    });
    registry[name] = {
      klass,
      omit: options.omit || [],
      shallow: options.shallow || []
    };
  }
  register("Object", Object);
  register("Error", Error);
  register("AJAXError", AJAXError);
  function serialize(input, transferables) {
    if (input === null || input === void 0 || typeof input === "boolean" || typeof input === "number" || typeof input === "string" || input instanceof Boolean || input instanceof Number || input instanceof String || input instanceof Date || input instanceof RegExp || input instanceof Blob) {
      return input;
    }
    if (isArrayBuffer(input)) {
      if (transferables) {
        transferables.push(input);
      }
      return input;
    }
    if (isImageBitmap2(input)) {
      if (transferables) {
        transferables.push(input);
      }
      return input;
    }
    if (ArrayBuffer.isView(input)) {
      const view = input;
      if (transferables) {
        transferables.push(view.buffer);
      }
      return view;
    }
    if (input instanceof ImageData) {
      if (transferables) {
        transferables.push(input.data.buffer);
      }
      return input;
    }
    if (Array.isArray(input)) {
      const serialized = [];
      for (const item of input) {
        serialized.push(serialize(item, transferables));
      }
      return serialized;
    }
    if (typeof input === "object") {
      const klass = input.constructor;
      const name = klass._classRegistryKey;
      if (!name) {
        throw new Error("can't serialize object of unregistered class");
      }
      if (!registry[name])
        throw new Error(`${name} is not registered.`);
      const properties = klass.serialize ? (
        // (Temporary workaround) allow a class to provide static
        // `serialize()` and `deserialize()` methods to bypass the generic
        // approach.
        // This temporary workaround lets us use the generic serialization
        // approach for objects whose members include instances of dynamic
        // StructArray types. Once we refactor StructArray to be static,
        // we can remove this complexity.
        klass.serialize(input, transferables)
      ) : {};
      if (!klass.serialize) {
        for (const key in input) {
          if (!input.hasOwnProperty(key))
            continue;
          if (registry[name].omit.indexOf(key) >= 0)
            continue;
          const property = input[key];
          properties[key] = registry[name].shallow.indexOf(key) >= 0 ? property : serialize(property, transferables);
        }
        if (input instanceof Error) {
          properties.message = input.message;
        }
      } else if (transferables && properties === transferables[transferables.length - 1]) {
        throw new Error("statically serialized object won't survive transfer of $name property");
      }
      if (properties.$name) {
        throw new Error("$name property is reserved for worker serialization logic.");
      }
      if (name !== "Object") {
        properties.$name = name;
      }
      return properties;
    }
    throw new Error(`can't serialize object of type ${typeof input}`);
  }
  function deserialize(input) {
    if (input === null || input === void 0 || typeof input === "boolean" || typeof input === "number" || typeof input === "string" || input instanceof Boolean || input instanceof Number || input instanceof String || input instanceof Date || input instanceof RegExp || input instanceof Blob || isArrayBuffer(input) || isImageBitmap2(input) || ArrayBuffer.isView(input) || input instanceof ImageData) {
      return input;
    }
    if (Array.isArray(input)) {
      return input.map(deserialize);
    }
    if (typeof input === "object") {
      const name = input.$name || "Object";
      if (!registry[name]) {
        throw new Error(`can't deserialize unregistered class ${name}`);
      }
      const { klass } = registry[name];
      if (!klass) {
        throw new Error(`can't deserialize unregistered class ${name}`);
      }
      if (klass.deserialize) {
        return klass.deserialize(input);
      }
      const result = Object.create(klass.prototype);
      for (const key of Object.keys(input)) {
        if (key === "$name")
          continue;
        const value = input[key];
        result[key] = registry[name].shallow.indexOf(key) >= 0 ? value : deserialize(value);
      }
      return result;
    }
    throw new Error(`can't deserialize object of type ${typeof input}`);
  }
  class ThrottledInvoker {
    constructor(callback) {
      this.callback = callback;
      this.triggered = false;
      if (typeof MessageChannel !== "undefined") {
        this.channel = new MessageChannel();
        this.channel.port2.onmessage = () => {
          this.triggered = false;
          this.callback();
        };
      }
    }
    trigger() {
      if (!this.triggered) {
        this.triggered = true;
        if (this.channel) {
          this.channel.port1.postMessage(true);
        } else {
          setTimeout(() => {
            this.triggered = false;
            this.callback();
          }, 0);
        }
      }
    }
    remove() {
      this.channel = null;
      this.callback = nullFunction;
    }
  }
  class Actor {
    constructor(target, parent, dispatcherId) {
      this.target = target;
      this.parent = parent;
      this.id = uid("actor");
      this.dispatcherId = dispatcherId;
      this.callbacks = {};
      this.tasks = {};
      this.taskQueue = [];
      this.cancelCallbacks = {};
      this.receive = this.receive.bind(this);
      this.process = this.process.bind(this);
      this.invoker = new ThrottledInvoker(this.process);
      this.target.addEventListener("message", this.receive, false);
      this.globalScope = isWorker() ? target : window;
    }
    /**
     * Sends a message from a main-thread map to a Worker or from a Worker back to
     * a main-thread map instance.
     *
     * @param type The name of the target method to invoke or '[source-type].[source-name].name' for a method on a WorkerSource.
     * @param data
     * @param callback
     * @param targetId A particular mapId to which to send this message.
     * @param mustQueue
     * @private
     */
    send(type, data, callback, targetId, mustQueue = false) {
      const id = Math.round(Math.random() * 1e18).toString(36).substring(0, 10);
      if (callback) {
        this.callbacks[id] = callback;
      }
      const buffers = isSafari(this.globalScope) ? void 0 : [];
      this.target.postMessage(
        {
          id,
          type,
          hasCallback: !!callback,
          targetId,
          mustQueue,
          dispatcherId: this.dispatcherId,
          data: serialize(data, buffers)
        },
        buffers
      );
      return {
        cancel: () => {
          if (callback) {
            delete this.callbacks[id];
          }
          this.target.postMessage({
            id,
            type: "<cancel>",
            targetId,
            dispatcherId: this.dispatcherId
          });
        }
      };
    }
    receive(message) {
      const { data } = message;
      const { id } = data;
      if (!id) {
        return;
      }
      if (data.targetId && this.dispatcherId !== data.targetId) {
        return;
      }
      if (data.type === "<cancel>") {
        delete this.tasks[id];
        const cancel = this.cancelCallbacks[id];
        delete this.cancelCallbacks[id];
        if (cancel) {
          cancel();
        }
      } else if (isWorker() || data.mustQueue) {
        this.tasks[id] = data;
        this.taskQueue.push(id);
        this.invoker.trigger();
      } else {
        this.processTask(id, data);
      }
    }
    process() {
      if (!this.taskQueue.length) {
        return;
      }
      const id = this.taskQueue.shift();
      if (id === void 0)
        return;
      const task = this.tasks[id];
      delete this.tasks[id];
      if (this.taskQueue.length) {
        this.invoker.trigger();
      }
      if (!task) {
        return;
      }
      this.processTask(id, task);
    }
    processTask(id, task) {
      var _a2, _b;
      if (task.type === "<response>") {
        const callback = this.callbacks[id];
        delete this.callbacks[id];
        if (callback) {
          if (task.error) {
            callback(deserialize(task.error));
          } else {
            callback(null, deserialize(task.data));
          }
        }
      } else {
        let completed = false;
        const buffers = isSafari(this.globalScope) ? void 0 : [];
        const done = task.hasCallback ? (err, data) => {
          completed = true;
          delete this.cancelCallbacks[id];
          this.target.postMessage(
            {
              id,
              type: "<response>",
              dispatcherId: this.dispatcherId,
              error: err ? serialize(err) : null,
              data: serialize(data, buffers)
            },
            buffers
          );
        } : () => {
          completed = true;
        };
        let callback = null;
        const params = deserialize(task.data);
        if (this.parent[task.type]) {
          callback = (_b = (_a2 = this.parent)[task.type]) == null ? void 0 : _b.call(_a2, task.dispatcherId, params, done);
        } else {
          done(new Error(`Could not find function ${task.type}`));
        }
        if (!completed && callback && callback.cancel) {
          this.cancelCallbacks[id] = callback.cancel;
        }
      }
    }
    remove() {
      this.invoker.remove();
      this.target.removeEventListener("message", this.receive, false);
    }
  }
  exports.Actor = Actor;
  exports.RequestScheduler = RequestScheduler;
  exports.ThrottledInvoker = ThrottledInvoker;
  exports.asyncAll = asyncAll;
  exports.getReferrer = getReferrer;
  exports.getRequest = getRequest;
  exports.isWorker = isWorker;
  exports.nullFunction = nullFunction;
  exports.register = register;
  exports.uid = uid;
  exports.utils = utils;
});
define(["./shared"], function(Actor) {
  class Worker2 {
    constructor(self2) {
      this.cancelMap = /* @__PURE__ */ new Map();
      this.self = self2;
      this.actor = new Actor.Actor(self2, this);
      this.request = Actor.getRequest();
    }
    setReferrer(dispatcherId, referrer) {
      this.referrer = referrer;
    }
    configDeps(dispatcherId, deps, callback) {
      if (deps && Array.isArray(deps) && deps.length > 0) {
        try {
          self.importScripts(...deps);
          callback(null, true);
        } catch (e) {
          Actor.asyncAll(
            deps,
            (d, done) => {
              this.request.fetch(
                {
                  url: d,
                  type: "arrayBuffer"
                },
                (err, data) => {
                  if (err) {
                    done(err, false);
                    return console.error(err);
                  }
                  const url = URL.createObjectURL(new Blob([data], { type: "application/javascript" }));
                  self.importScripts(url);
                  setTimeout(() => {
                    URL.revokeObjectURL(url);
                  });
                  done(null, true);
                }
              );
            },
            callback
          );
        }
      } else {
        callback(null, true);
      }
    }
    loadData(dispatcherId, params, callback) {
      const cancelId = params == null ? void 0 : params.cancelId;
      const { cancel } = this.request.fetch(params, (err, data) => {
        this.cancelMap.delete(cancelId);
        if (err) {
          callback(err);
        } else {
          if ((params == null ? void 0 : params.decodeType) === 0) {
            this.request.arrayBuffer2Image(data, callback);
          } else if ((params == null ? void 0 : params.decodeType) === 1) {
            this.request.arrayBuffer2unit8(data, callback);
          } else if ((params == null ? void 0 : params.decodeType) === 2) {
            this.request.arrayBuffer2tiff(data, callback);
          } else if ((params == null ? void 0 : params.decodeType) === 3) {
            this.request.parseExif(data, callback);
          }
        }
      });
      this.cancelMap.set(cancelId, cancel);
    }
    cancel(dispatcherId, params, callback) {
      const cancelId = params == null ? void 0 : params.cancelId;
      const c = this.cancelMap.get(cancelId);
      if (c) {
        c();
        callback(null, true);
      } else {
        callback(new Error("无相关的可取消请求！"));
      }
    }
  }
  if (Actor.isWorker()) {
    self.worker = new Worker2(self);
  }
  return Worker2;
});
define(["./shared"], function(Actor) {
  let u = "";
  function setWorkerUrl(url) {
    u = url;
  }
  function getWorkerUrl() {
    return u;
  }
  let deps = [];
  function configDeps2(d) {
    deps = d;
  }
  function getConfigDeps() {
    return deps;
  }
  function workerFactory() {
    return new Worker(getWorkerUrl());
  }
  const PRELOAD_POOL_ID = "__wind_layer_preloaded_worker_pool__";
  class WorkerPool {
    constructor() {
      this.active = {};
    }
    /**
     * 获取 `Worker` 实例
     * @param id
     */
    acquire(id) {
      if (!this.workers) {
        this.workers = [];
        for (let i = 0; i < WorkerPool.workerCount; i++) {
          const worker2 = workerFactory();
          if (worker2) {
            this.workers.push(worker2);
          }
        }
      }
      this.active[id] = true;
      return this.workers.slice();
    }
    /**
     * 释放所有 `Worker`
     * @param id
     */
    release(id) {
      delete this.active[id];
      if (this.numActive() === 0 && this.workers) {
        this.workers.forEach((w) => {
          w.terminate();
        });
        this.workers = null;
      }
    }
    isPreloaded() {
      return !!this.active[PRELOAD_POOL_ID];
    }
    /**
     * 获取激活的`Worker` 数量
     */
    numActive() {
      return Object.keys(this.active).length;
    }
  }
  const hardwareConcurrency = typeof navigator !== "undefined" && navigator.hardwareConcurrency || 4;
  const availableLogicalProcessors = Math.floor(hardwareConcurrency / 2);
  WorkerPool.workerCount = Math.max(Math.min(availableLogicalProcessors, 6), 1);
  class Dispatcher {
    constructor(workerPool, parent, dispatcherId) {
      this.workerPool = workerPool;
      this.actors = [];
      this.currentActor = 0;
      this.id = Actor.uid("dispatcher");
      this.dispatcherId = dispatcherId;
      const workers = this.workerPool.acquire(this.dispatcherId);
      for (let i = 0; i < workers.length; i++) {
        const worker2 = workers[i];
        const actor = new Actor.Actor(worker2, parent, this.dispatcherId);
        actor.name = `Worker ${i}`;
        this.actors.push(actor);
      }
      if (!this.actors.length)
        throw new Error("No actors found");
    }
    /**
     * 广播到所有 Actor
     * @param type
     * @param data
     * @param cb
     */
    broadcast(type, data, cb) {
      cb = cb || Actor.nullFunction;
      Actor.asyncAll(
        this.actors,
        (actor, done) => {
          actor.send(type, data, done);
        },
        cb
      );
    }
    send(type, data, cb, id) {
      const actor = this.getActor(id);
      if (actor) {
        actor.send(type, data, cb);
      }
    }
    /**
     * 获取要发送消息的 `Actor`
     * TIP: 是否需要实现 `Actor` 是否占用判断
     */
    getActor(id) {
      if (id !== void 0) {
        const index2 = this.actors.findIndex((a) => a.id === id);
        if (index2 > -1) {
          this.currentActor = index2;
        } else {
          this.currentActor = (this.currentActor + 1) % this.actors.length;
        }
      } else {
        this.currentActor = (this.currentActor + 1) % this.actors.length;
      }
      return this.actors[this.currentActor];
    }
    remove(removed = true) {
      this.actors.forEach((actor) => {
        actor.remove();
      });
      this.actors = [];
      if (removed)
        this.workerPool.release(this.id);
    }
  }
  let globalWorkerPool;
  function getGlobalWorkerPool() {
    if (!globalWorkerPool) {
      globalWorkerPool = new WorkerPool();
    }
    return globalWorkerPool;
  }
  function prewarm() {
    const workerPool = getGlobalWorkerPool();
    workerPool.acquire(PRELOAD_POOL_ID);
  }
  const exported = {
    utils: Actor.utils,
    request: Actor.getRequest,
    register: Actor.register,
    configDeps: configDeps2,
    getConfigDeps,
    prewarm,
    getReferrer: Actor.getReferrer,
    setWorkerUrl,
    getGlobalWorkerPool,
    Actor: Actor.Actor,
    WorkerPool,
    Dispatcher,
    RequestScheduler: Actor.RequestScheduler,
    ThrottledInvoker: Actor.ThrottledInvoker
  };
  return exported;
});
var wgw$1 = wgw;
var _passes;
var Pipelines = class {
  constructor(renderer) {
    __privateAdd(this, _passes, []);
    this.enabled = true;
    this.renderer = renderer;
  }
  get passes() {
    return __privateGet(this, _passes);
  }
  get length() {
    return this.passes.length;
  }
  resize(width, height) {
    var _a2;
    const len = __privateGet(this, _passes).length;
    for (let i = 0; i < len; i++) {
      const pass = __privateGet(this, _passes)[i];
      (_a2 = pass.resize) == null ? void 0 : _a2.call(pass, width, height);
    }
  }
  addPass(pass) {
    __privateGet(this, _passes).push(pass);
  }
  removePass(pass) {
    const idx = __privateGet(this, _passes).indexOf(pass);
    if (idx > -1) {
      __privateGet(this, _passes).splice(pass, 1);
      pass.destroy();
    }
  }
  removePasses() {
    __privateGet(this, _passes).forEach((pass) => pass.destroy());
    __privateSet(this, _passes, []);
  }
  getPass(id) {
    return __privateGet(this, _passes).find((pass) => pass.id === id);
  }
  prerender(rendererParams, rendererState) {
    const passes = __privateGet(this, _passes).filter((p) => p.enabled && p.prerender === true);
    if (passes.length > 0) {
      const len = passes.length;
      for (let i = 0; i < len; i++) {
        const pass = passes[i];
        pass.render(rendererParams, rendererState);
      }
      this.renderer.resetState();
    }
  }
  render(rendererParams, rendererState) {
    const passes = __privateGet(this, _passes).filter((p) => p.enabled && p.prerender !== true);
    if (passes.length > 0) {
      const len = passes.length;
      for (let i = 0; i < len; i++) {
        const pass = passes[i];
        pass.render(rendererParams, rendererState);
      }
      this.renderer.resetState();
    }
  }
  destroy() {
    __privateGet(this, _passes).forEach((pass) => pass.destroy());
  }
};
_passes = new WeakMap();
var ERR_PASS_METHOD_UNDEFINED = "Pass subclass must define virtual methods";
var _enabled;
var Pass = class {
  constructor(id, renderer, options = {}) {
    __privateAdd(this, _enabled, true);
    this.id = id;
    this.renderer = renderer;
    this.options = options;
    this.setMaskPass(this.options.maskPass);
  }
  get enabled() {
    return __privateGet(this, _enabled);
  }
  set enabled(state) {
    __privateSet(this, _enabled, state);
  }
  setMaskPass(pass) {
    this.maskPass = pass;
  }
  render(rendererParams, rendererState, cb) {
    throw new Error(ERR_PASS_METHOD_UNDEFINED);
  }
  destroy() {
    throw new Error(ERR_PASS_METHOD_UNDEFINED);
  }
};
_enabled = new WeakMap();
var vert$4 = "#define GLSLIFY 1\nattribute vec2 uv;attribute vec3 position;uniform vec3 cameraPosition;uniform mat4 viewMatrix;uniform mat4 modelMatrix;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;varying vec2 vUv;void main(){vUv=vec2(uv.x,1.0-uv.y);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
var frag$8 = "#defines\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D u_image0;uniform sampler2D u_image1;\n#include <decodeFloat>\n#if RENDER_TYPE == 1\nuniform vec4 dataRange;vec4 getColor(const vec2 uv){vec2 rg=texture2D(u_image0,uv).rg;vec2 data=rg*(dataRange.yw-dataRange.xz)+dataRange.xz;return vec4(data.xy,0.0,1.0);}\n#elif RENDER_TYPE == 0\nuniform vec2 dataRange;vec4 getColor(const vec2 uv){float r=texture2D(u_image0,uv).r;float rf=r*(dataRange.y-dataRange.x)+dataRange.x;return vec4(rf,0.0,0.0,1.0);}\n#elif RENDER_TYPE == 2\nvec4 getColor(const vec2 uv){vec4 rgba=texture2D(u_image0,uv).rgba;float r=decode_float(rgba,LITTLE_ENDIAN);return vec4(r,0.0,0.0,1.0);}\n#else\nvec4 getColor(const vec2 uv){return texture2D(u_image0,uv).rgba;}\n#endif\nvoid main(){gl_FragColor=getColor(vUv);}";
var random = "#define GLSLIFY 1\nhighp float rand(vec2 co){highp float a=12.9898;highp float b=78.233;highp float c=43758.5453;highp float dt=dot(co.xy,vec2(a,b));highp float sn=mod(dt,3.14);return fract(sin(sn)*c);}";
var encode = "#define GLSLIFY 1\nconst vec2 bitEnc=vec2(1.0,255.0);const vec2 bitDec=1.0/bitEnc;vec4 toRGBA(const vec2 pos){vec2 rg=bitEnc*pos.x;rg=fract(rg);rg-=rg.yy*vec2(1.0/255.0,0.0);vec2 ba=bitEnc*pos.y;ba=fract(ba);ba-=ba.yy*vec2(1.0/255.0,0.0);return vec4(rg,ba);}";
var encodeFloat = "#define GLSLIFY 1\n#define FLOAT_MAX 1.70141184e38\n#define FLOAT_MIN 1.17549435e-38\nlowp vec4 encode_float(highp float v){highp float av=abs(v);if(av<FLOAT_MIN){return vec4(0.0,0.0,0.0,0.0);}else if(v>FLOAT_MAX){return vec4(127.0,128.0,0.0,0.0)/255.0;}else if(v<-FLOAT_MAX){return vec4(255.0,128.0,0.0,0.0)/255.0;}highp vec4 c=vec4(0,0,0,0);highp float e=floor(log2(av));highp float m=av*pow(2.0,-e)-1.0;c[1]=floor(128.0*m);m-=c[1]/128.0;c[2]=floor(32768.0*m);m-=c[2]/32768.0;c[3]=floor(8388608.0*m);highp float ebias=e+127.0;c[0]=floor(ebias/2.0);ebias-=c[0]*2.0;c[1]+=floor(ebias)*128.0;c[0]+=128.0*step(0.0,-v);return c/255.0;}";
var decode = "#define GLSLIFY 1\nconst vec2 bitEnc=vec2(1.0,255.0);const vec2 bitDec=1.0/bitEnc;vec2 fromRGBA(const vec4 color){vec4 rounded_color=floor(color*255.0+0.5)/255.0;float x=dot(rounded_color.rg,bitDec);float y=dot(rounded_color.ba,bitDec);return vec2(x,y);}";
var decodeFloat = "#define GLSLIFY 1\nvec4 floatsToBytes(vec4 inputFloats,bool littleEndian){vec4 bytes=vec4(inputFloats*255.0);return(littleEndian? bytes.abgr: bytes);}float decode_float(vec4 v,bool littleEndian){vec4 bits=floatsToBytes(v,littleEndian);float sign=mix(-1.0,1.0,step(bits[3],128.0));float expo=floor(mod(bits[3]+0.2,128.0))*2.0+floor((bits[2]+0.2)/128.0)-127.0;float sig=bits[0]+bits[1]*256.0+floor(mod(bits[2]+0.2,128.0))*256.0*256.0;return sign*(1.0+sig/8388607.0)*pow(2.0,expo);}";
var shaderLib = Object.freeze({
  __proto__: null,
  decode,
  decodeFloat,
  encode,
  encodeFloat,
  random
});
function calcMinMax(array) {
  let min = Infinity;
  let max = Infinity;
  for (let i = 0; i < array.length; i++) {
    const val = array[i];
    if (min === Infinity) {
      min = val;
    } else if (max === Infinity) {
      max = val;
      min = Math.min(min, max);
      max = Math.max(min, max);
    } else {
      min = Math.min(val, min);
      max = Math.max(val, max);
    }
  }
  return [min, max];
}
function isFunction(val) {
  return index.typeOf(val) === "function";
}
function findStopLessThanOrEqualTo(stops, input) {
  const lastIndex = stops.length - 1;
  let lowerIndex = 0;
  let upperIndex = lastIndex;
  let currentIndex = 0;
  let currentValue;
  let nextValue;
  while (lowerIndex <= upperIndex) {
    currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
    currentValue = stops[currentIndex];
    nextValue = stops[currentIndex + 1];
    if (currentValue <= input) {
      if (currentIndex === lastIndex || input < nextValue) {
        return currentIndex;
      }
      lowerIndex = currentIndex + 1;
    } else if (currentValue > input) {
      upperIndex = currentIndex - 1;
    } else {
      throw new Error("Input is not a number.");
    }
  }
  return 0;
}
var linkEl;
function resolveURL(path) {
  if (!linkEl)
    linkEl = document.createElement("a");
  linkEl.href = path;
  return linkEl.href;
}
var littleEndian = function machineIsLittleEndian() {
  const uint8Array = new Uint8Array([170, 187]);
  const uint16array = new Uint16Array(uint8Array.buffer);
  return uint16array[0] === 48042;
}();
function isImageBitmap(image) {
  return typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
}
function parseRange(exif) {
  const string = (exif == null ? void 0 : exif.ImageDescription) || "";
  const group = string.split(";");
  const gs = group.filter((item) => item !== "");
  return gs.map((item) => item.split(",").map((v) => parseFloat(v)));
}
function keysDifference(obj, other) {
  const difference = [];
  for (const i in obj) {
    if (!(i in other)) {
      difference.push(i);
    }
  }
  return difference;
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function inRange(value, start, end) {
  return value >= start && value < end;
}
function mod(x, y) {
  return (x % y + y) % y;
}
function containTile(a, b) {
  return containsExtent(a, b) || intersects(a, b);
}
function flattenForPolygons(features) {
  if (!features || features.length === 0)
    return [];
  const len = features.length;
  let i = 0;
  const data = [];
  for (; i < len; i++) {
    const feature = features[i];
    const coordinates = feature.geometry.coordinates;
    const type = feature.geometry.type;
    if (type === "Polygon") {
      data.push(feature);
    } else if (type === "MultiPolygon") {
      for (let k = 0; k < coordinates.length; k++) {
        const coordinate = coordinates[k];
        data.push({
          ...feature,
          geometry: {
            type: "Polygon",
            coordinates: coordinate
          }
        });
      }
    }
  }
  return data;
}
function polygon2buffer(features) {
  const len = features.length;
  let i = 0;
  const geometries = [];
  for (; i < len; i++) {
    const feature = features[i];
    const coordinates = feature.geometry.coordinates;
    const type = feature.geometry.type;
    if (type === "Polygon") {
      const polygon = import_earcut.default.flatten(feature.geometry.coordinates);
      const positions = new Float32Array(polygon.vertices);
      const indexData = (0, import_earcut.default)(polygon.vertices, polygon.holes, polygon.dimensions);
      geometries.push({
        index: {
          data: indexData.length < 65536 ? new Uint16Array(indexData) : new Uint32Array(indexData)
        },
        position: {
          data: positions,
          size: 2
        }
      });
    } else if (type === "MultiPolygon") {
      for (let k = 0; k < coordinates.length; k++) {
        const coordinate = coordinates[k];
        const polygon = import_earcut.default.flatten(coordinate);
        const positions = new Float32Array(polygon.vertices);
        const indexData = (0, import_earcut.default)(polygon.vertices, polygon.holes, polygon.dimensions);
        geometries.push({
          index: {
            data: indexData.length < 65536 ? new Uint16Array(indexData) : new Uint32Array(indexData)
          },
          position: {
            data: positions,
            size: 2
          }
        });
      }
    }
  }
  return geometries;
}
var _program, _current, _next, _uid, _a;
var ComposePass$1 = (_a = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program);
    __privateAdd(this, _current);
    __privateAdd(this, _next);
    __privateAdd(this, _uid);
    this.prerender = true;
    __privateSet(this, _uid, index.uid("ColorComposePass"));
    __privateSet(this, _program, new Program(renderer, {
      vertexShader: vert$4,
      fragmentShader: frag$8,
      uniforms: {
        u_image0: {
          value: void 0
        },
        dataRange: {
          value: void 0
        }
      },
      defines: [`RENDER_TYPE ${this.options.bandType}`, `LITTLE_ENDIAN ${littleEndian}`],
      includes: shaderLib
    }));
    const opt = {
      width: this.renderer.width,
      height: this.renderer.height,
      minFilter: renderer.gl.NEAREST,
      magFilter: renderer.gl.NEAREST,
      type: this.renderer.gl.FLOAT,
      format: this.renderer.gl.RGBA,
      // generateMipmaps: false,
      internalFormat: this.renderer.isWebGL2 ? this.renderer.gl.RGBA32F : this.renderer.gl.RGBA,
      stencil: true
    };
    __privateSet(this, _current, new RenderTarget(renderer, {
      ...opt,
      name: "currentRenderTargetTexture"
    }));
    __privateSet(this, _next, new RenderTarget(renderer, {
      ...opt,
      name: "nextRenderTargetTexture"
    }));
  }
  resize(width, height) {
    var _a2, _b;
    (_a2 = __privateGet(this, _current)) == null ? void 0 : _a2.resize(width, height);
    (_b = __privateGet(this, _next)) == null ? void 0 : _b.resize(width, height);
  }
  get renderTarget() {
    return {
      current: __privateGet(this, _current),
      next: __privateGet(this, _next)
    };
  }
  get textures() {
    var _a2, _b;
    return {
      current: (_a2 = __privateGet(this, _current)) == null ? void 0 : _a2.texture,
      next: (_b = __privateGet(this, _next)) == null ? void 0 : _b.texture
    };
  }
  renderTexture(renderTarget, rendererParams, rendererState, sourceCache) {
    var _a2, _b, _c, _d, _e, _f;
    if (renderTarget) {
      renderTarget.clear();
      renderTarget.bind();
      const attr = this.renderer.attributes;
      if (attr.depth && renderTarget.depth) {
        this.renderer.state.enable(this.renderer.gl.DEPTH_TEST);
        this.renderer.state.setDepthMask(true);
      }
      this.renderer.setViewport(renderTarget.width, renderTarget.height);
    }
    const { stencilConfigForOverlap } = this.options;
    const camera = rendererParams.cameras.camera;
    if (sourceCache) {
      const coordsAscending = sourceCache.getVisibleCoordinates();
      const coordsDescending = coordsAscending.slice().reverse();
      if (!coordsDescending.length)
        return;
      let stencil;
      if (this.maskPass) {
        stencil = this.maskPass.render(rendererParams, rendererState);
      }
      const [stencilModes, coords] = stencilConfigForOverlap(coordsDescending);
      for (let i = 0; i < coords.length; i++) {
        const coord = coords[i];
        const tile = sourceCache.getTile(coord);
        if (!(tile && tile.hasData()))
          continue;
        const bbox = coord.getTileProjBounds();
        if (!bbox)
          continue;
        const tileMesh = tile.createMesh(__privateGet(this, _uid), bbox, this.renderer, __privateGet(this, _program));
        const mesh = tileMesh.getMesh();
        const dataRange = [];
        for (const [index2, texture] of tile.textures) {
          if (((_a2 = texture.userData) == null ? void 0 : _a2.dataRange) && Array.isArray((_b = texture.userData) == null ? void 0 : _b.dataRange)) {
            dataRange.push(...texture.userData.dataRange);
          }
          if (((_d = (_c = this.options).isRasterize) == null ? void 0 : _d.call(_c)) && (texture.options.minFilter !== this.renderer.gl.NEAREST || texture.options.magFilter !== this.renderer.gl.NEAREST)) {
            texture.setOptions({
              minFilter: this.renderer.gl.NEAREST,
              magFilter: this.renderer.gl.NEAREST
            });
          }
          mesh.program.setUniform(`u_image${index2}`, texture);
        }
        if (dataRange.length > 0) {
          mesh.program.setUniform("dataRange", dataRange);
        }
        mesh.updateMatrix();
        mesh.worldMatrixNeedsUpdate = false;
        mesh.worldMatrix.multiply(rendererParams.scene.worldMatrix, mesh.localMatrix);
        stencilModes[coord.overscaledZ];
        mesh.draw({
          ...rendererParams,
          camera
        });
        if ((_f = (_e = this.options).isRasterize) == null ? void 0 : _f.call(_e)) {
          for (const [_, texture] of tile.textures) {
            texture.setOptions({
              minFilter: this.renderer.gl.LINEAR,
              magFilter: this.renderer.gl.LINEAR
            });
          }
        }
      }
      this.renderer.clear(false, false, true);
      if (!stencil) {
        this.renderer.state.disable(this.renderer.gl.STENCIL_TEST);
      }
    }
    if (renderTarget) {
      renderTarget.unbind();
    }
  }
  /**
   * 此处绘制主要是合并瓦片
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    const { source } = this.options;
    const sourceCache = source.sourceCache;
    if (Array.isArray(sourceCache)) {
      if (sourceCache.length === 2) {
        this.renderTexture(__privateGet(this, _current), rendererParams, rendererState, sourceCache[0]);
        this.renderTexture(__privateGet(this, _next), rendererParams, rendererState, sourceCache[1]);
      } else {
        this.renderTexture(__privateGet(this, _current), rendererParams, rendererState, sourceCache[0]);
        this.renderTexture(__privateGet(this, _next), rendererParams, rendererState, sourceCache[0]);
      }
    } else {
      this.renderTexture(__privateGet(this, _current), rendererParams, rendererState, sourceCache);
      this.renderTexture(__privateGet(this, _next), rendererParams, rendererState, sourceCache);
    }
  }
  destroy() {
    if (__privateGet(this, _program)) {
      __privateGet(this, _program).destroy();
      __privateSet(this, _program, null);
    }
    if (__privateGet(this, _current)) {
      __privateGet(this, _current).destroy();
      __privateSet(this, _current, null);
    }
    if (__privateGet(this, _next)) {
      __privateGet(this, _next).destroy();
      __privateSet(this, _next, null);
    }
  }
}, _program = new WeakMap(), _current = new WeakMap(), _next = new WeakMap(), _uid = new WeakMap(), _a);
var vert$3 = "#define GLSLIFY 1\n#defines\nattribute vec2 uv;attribute vec3 position;uniform vec2 resolution;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
var frag$7 = "#defines\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_textureNext;uniform sampler2D colorRampTexture;uniform float u_fade_t;uniform vec2 u_image_res;uniform vec2 colorRange;uniform bool useDisplayRange;uniform vec2 displayRange;uniform float opacity;varying vec2 vUv;\n#include <decodeFloat>\nvec4 calcTexture(const vec2 puv){vec4 color0=texture2D(u_texture,puv);vec4 color1=texture2D(u_textureNext,puv);return mix(color0,color1,u_fade_t);}\n#if RENDER_TYPE == 1\nvec2 decodeValue(const vec2 vc){vec4 rgba=calcTexture(vc);return rgba.rg;}\n#else\nfloat decodeValue(const vec2 vc){return calcTexture(vc).r;}\n#endif\n#if RENDER_TYPE == 1\nvec2 bilinear(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);vec2 tl=decodeValue(vc);vec2 tr=decodeValue(vc+vec2(px.x,0));vec2 bl=decodeValue(vc+vec2(0,px.y));vec2 br=decodeValue(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}\n#else\nfloat bilinear(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);float tl=decodeValue(vc);float tr=decodeValue(vc+vec2(px.x,0));float bl=decodeValue(vc+vec2(0,px.y));float br=decodeValue(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}\n#endif\n#if RENDER_TYPE == 1\nfloat getValue(const vec2 uv){vec2 rg=bilinear(uv);return length(rg);}\n#else\nfloat getValue(const vec2 uv){return bilinear(uv);}\n#endif\nvoid main(){vec2 uv=vUv;if(calcTexture(uv).a==0.0){discard;}float value=getValue(uv);float value_t=(value-colorRange.x)/(colorRange.y-colorRange.x);vec2 ramp_pos=vec2(value_t,0.5);vec4 color=texture2D(colorRampTexture,ramp_pos);bool display=true;if(useDisplayRange){display=value<=displayRange.y&&value>=displayRange.x;}if(display){gl_FragColor=vec4(floor(255.0*color*opacity)/255.0);}else{gl_FragColor=vec4(0.0,0.0,0.0,0.0);}}";
var _program2, _mesh, _geometry;
var ColorizePass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program2);
    __privateAdd(this, _mesh);
    __privateAdd(this, _geometry);
    this.prerender = false;
    __privateSet(this, _program2, new Program(renderer, {
      vertexShader: vert$3,
      fragmentShader: frag$7,
      uniforms: {
        opacity: {
          value: 1
        },
        u_fade_t: {
          value: 0
        },
        displayRange: {
          value: new Vector2(-Infinity, Infinity)
        },
        u_texture: {
          value: this.options.texture
        },
        u_textureNext: {
          value: this.options.textureNext
        },
        colorRampTexture: {
          value: null
        }
      },
      defines: [`RENDER_TYPE ${this.options.bandType}`, `LITTLE_ENDIAN ${littleEndian}`],
      includes: shaderLib,
      transparent: true
    }));
    __privateSet(this, _geometry, new Geometry(renderer, {
      position: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      uv: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      index: {
        size: 1,
        data: new Uint16Array([0, 1, 2, 2, 1, 3])
      }
    }));
    __privateSet(this, _mesh, new Mesh(renderer, {
      mode: renderer.gl.TRIANGLES,
      program: __privateGet(this, _program2),
      geometry: __privateGet(this, _geometry)
    }));
  }
  /**
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    var _a2, _b;
    const attr = this.renderer.attributes;
    this.renderer.setViewport(this.renderer.width * attr.dpr, this.renderer.height * attr.dpr);
    const camera = rendererParams.cameras.planeCamera;
    if (rendererState && __privateGet(this, _mesh)) {
      const uniforms = index.pick(rendererState, [
        "opacity",
        "colorRange",
        "dataRange",
        "colorRampTexture",
        "useDisplayRange",
        "displayRange"
      ]);
      Object.keys(uniforms).forEach((key) => {
        var _a3;
        if (uniforms[key] !== void 0) {
          (_a3 = __privateGet(this, _mesh)) == null ? void 0 : _a3.program.setUniform(key, uniforms[key]);
        }
      });
      const fade = ((_b = (_a2 = this.options.source) == null ? void 0 : _a2.getFadeTime) == null ? void 0 : _b.call(_a2)) || 0;
      __privateGet(this, _mesh).program.setUniform(
        "u_image_res",
        new Vector2(this.options.texture.width, this.options.texture.height)
      );
      __privateGet(this, _mesh).program.setUniform("u_fade_t", fade);
      __privateGet(this, _mesh).updateMatrix();
      __privateGet(this, _mesh).worldMatrixNeedsUpdate = false;
      __privateGet(this, _mesh).worldMatrix.multiply(camera.worldMatrix, __privateGet(this, _mesh).localMatrix);
      __privateGet(this, _mesh).draw({
        ...rendererParams,
        camera
      });
    }
  }
  destroy() {
    if (__privateGet(this, _mesh)) {
      __privateGet(this, _mesh).destroy();
      __privateSet(this, _mesh, null);
    }
    if (__privateGet(this, _program2)) {
      __privateGet(this, _program2).destroy();
      __privateSet(this, _program2, null);
    }
    if (__privateGet(this, _geometry)) {
      __privateGet(this, _geometry).destroy();
      __privateSet(this, _geometry, null);
    }
  }
};
_program2 = new WeakMap();
_mesh = new WeakMap();
_geometry = new WeakMap();
var frag$6 = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_textureNext;uniform float u_fade_t;uniform float opacity;varying vec2 vUv;void main(){vec2 uv=vUv;vec4 color0=texture2D(u_texture,vUv);vec4 color1=texture2D(u_textureNext,vUv);vec4 color=mix(color0,color1,u_fade_t);gl_FragColor=vec4(floor(255.0*color*opacity)/255.0);}";
var _program3, _mesh2, _geometry2;
var RasterPass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program3);
    __privateAdd(this, _mesh2);
    __privateAdd(this, _geometry2);
    this.prerender = false;
    __privateSet(this, _program3, new Program(renderer, {
      vertexShader: vert$3,
      fragmentShader: frag$6,
      uniforms: {
        opacity: {
          value: 1
        },
        u_fade_t: {
          value: 0
        },
        u_texture: {
          value: this.options.texture
        },
        u_textureNext: {
          value: this.options.textureNext
        }
      },
      includes: shaderLib,
      transparent: true
    }));
    __privateSet(this, _geometry2, new Geometry(renderer, {
      position: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      uv: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      index: {
        size: 1,
        data: new Uint16Array([0, 1, 2, 2, 1, 3])
      }
    }));
    __privateSet(this, _mesh2, new Mesh(renderer, {
      mode: renderer.gl.TRIANGLES,
      program: __privateGet(this, _program3),
      geometry: __privateGet(this, _geometry2)
    }));
  }
  /**
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    var _a2, _b;
    const attr = this.renderer.attributes;
    this.renderer.setViewport(this.renderer.width * attr.dpr, this.renderer.height * attr.dpr);
    const camera = rendererParams.cameras.planeCamera;
    if (rendererState && __privateGet(this, _mesh2)) {
      const fade = ((_b = (_a2 = this.options.source) == null ? void 0 : _a2.getFadeTime) == null ? void 0 : _b.call(_a2)) || 0;
      const uniforms = index.pick(rendererState, ["opacity"]);
      Object.keys(uniforms).forEach((key) => {
        var _a3;
        if (uniforms[key] !== void 0) {
          (_a3 = __privateGet(this, _mesh2)) == null ? void 0 : _a3.program.setUniform(key, uniforms[key]);
        }
      });
      __privateGet(this, _mesh2).program.setUniform("u_fade_t", fade);
      __privateGet(this, _mesh2).updateMatrix();
      __privateGet(this, _mesh2).worldMatrixNeedsUpdate = false;
      __privateGet(this, _mesh2).worldMatrix.multiply(camera.worldMatrix, __privateGet(this, _mesh2).localMatrix);
      __privateGet(this, _mesh2).draw({
        ...rendererParams,
        camera
      });
    }
  }
  destroy() {
    if (__privateGet(this, _mesh2)) {
      __privateGet(this, _mesh2).destroy();
      __privateSet(this, _mesh2, null);
    }
    if (__privateGet(this, _program3)) {
      __privateGet(this, _program3).destroy();
      __privateSet(this, _program3, null);
    }
    if (__privateGet(this, _geometry2)) {
      __privateGet(this, _geometry2).destroy();
      __privateSet(this, _geometry2, null);
    }
  }
};
_program3 = new WeakMap();
_mesh2 = new WeakMap();
_geometry2 = new WeakMap();
var frag$5 = "precision highp float;\n#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D u_image0;vec4 getColor(const vec2 uv){return texture2D(u_image0,uv).rgba;}void main(){gl_FragColor=getColor(vUv);}";
var _program4, _current2, _next2, _uid2;
var ComposePass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program4);
    __privateAdd(this, _current2);
    __privateAdd(this, _next2);
    __privateAdd(this, _uid2);
    this.prerender = true;
    __privateSet(this, _uid2, index.uid("ComposePass"));
    __privateSet(this, _program4, new Program(renderer, {
      vertexShader: vert$4,
      fragmentShader: frag$5,
      uniforms: {
        u_image0: {
          value: void 0
        }
      },
      includes: shaderLib
    }));
    const opt = {
      width: this.renderer.width,
      height: this.renderer.height,
      minFilter: renderer.gl.NEAREST,
      magFilter: renderer.gl.NEAREST,
      type: this.renderer.gl.UNSIGNED_BYTE,
      format: this.renderer.gl.RGBA,
      generateMipmaps: true,
      internalFormat: this.renderer.gl.RGBA,
      stencil: true
    };
    __privateSet(this, _current2, new RenderTarget(renderer, {
      ...opt,
      name: "currentRenderTargetTexture"
    }));
    __privateSet(this, _next2, new RenderTarget(renderer, {
      ...opt,
      name: "nextRenderTargetTexture"
    }));
  }
  resize(width, height) {
    var _a2, _b;
    (_a2 = __privateGet(this, _current2)) == null ? void 0 : _a2.resize(width, height);
    (_b = __privateGet(this, _next2)) == null ? void 0 : _b.resize(width, height);
  }
  get textures() {
    var _a2, _b;
    return {
      current: (_a2 = __privateGet(this, _current2)) == null ? void 0 : _a2.texture,
      next: (_b = __privateGet(this, _next2)) == null ? void 0 : _b.texture
    };
  }
  renderTexture(renderTarget, rendererParams, rendererState, sourceCache) {
    if (renderTarget) {
      renderTarget.clear();
      renderTarget.bind();
      const attr = this.renderer.attributes;
      if (attr.depth && renderTarget.depth) {
        this.renderer.state.enable(this.renderer.gl.DEPTH_TEST);
        this.renderer.state.setDepthMask(true);
      }
      this.renderer.setViewport(renderTarget.width, renderTarget.height);
    }
    const { stencilConfigForOverlap } = this.options;
    const camera = rendererParams.cameras.camera;
    if (sourceCache) {
      const coordsAscending = sourceCache.getVisibleCoordinates();
      const coordsDescending = coordsAscending.slice().reverse();
      if (!coordsDescending.length)
        return;
      let stencil;
      if (this.maskPass) {
        stencil = this.maskPass.render(rendererParams, rendererState);
      }
      const [stencilModes, coords] = stencilConfigForOverlap(coordsDescending);
      for (let i = 0; i < coords.length; i++) {
        const coord = coords[i];
        const tile = sourceCache.getTile(coord);
        if (!(tile && tile.hasData()))
          continue;
        const bbox = coord.getTileProjBounds();
        if (!bbox)
          continue;
        const tileMesh = tile.createMesh(__privateGet(this, _uid2), bbox, this.renderer, __privateGet(this, _program4));
        const mesh = tileMesh.getMesh();
        for (const [index2, texture] of tile.textures) {
          mesh.program.setUniform(`u_image${index2}`, texture);
        }
        mesh.updateMatrix();
        mesh.worldMatrixNeedsUpdate = false;
        mesh.worldMatrix.multiply(rendererParams.scene.worldMatrix, mesh.localMatrix);
        stencilModes[coord.overscaledZ];
        mesh.draw({
          ...rendererParams,
          camera
        });
      }
      this.renderer.clear(false, false, true);
      if (!stencil) {
        this.renderer.state.disable(this.renderer.gl.STENCIL_TEST);
      }
    }
    if (renderTarget) {
      renderTarget.unbind();
    }
  }
  /**
   * 此处绘制主要是合并瓦片
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    const { source } = this.options;
    const sourceCache = source.sourceCache;
    if (Array.isArray(sourceCache)) {
      if (sourceCache.length === 2) {
        this.renderTexture(__privateGet(this, _current2), rendererParams, rendererState, sourceCache[0]);
        this.renderTexture(__privateGet(this, _next2), rendererParams, rendererState, sourceCache[1]);
      } else {
        this.renderTexture(__privateGet(this, _current2), rendererParams, rendererState, sourceCache[0]);
      }
    } else {
      this.renderTexture(__privateGet(this, _current2), rendererParams, rendererState, sourceCache);
    }
  }
  destroy() {
    if (__privateGet(this, _current2)) {
      __privateGet(this, _current2).destroy();
      __privateSet(this, _current2, null);
    }
    if (__privateGet(this, _next2)) {
      __privateGet(this, _next2).destroy();
      __privateSet(this, _next2, null);
    }
    if (__privateGet(this, _program4)) {
      __privateGet(this, _program4).destroy();
      __privateSet(this, _program4, null);
    }
  }
};
_program4 = new WeakMap();
_current2 = new WeakMap();
_next2 = new WeakMap();
_uid2 = new WeakMap();
var defaultSize = 256;
var _program5, _current3, _next3, _uid3, _width, _height;
var ParticlesComposePass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program5);
    __privateAdd(this, _current3);
    __privateAdd(this, _next3);
    __privateAdd(this, _uid3);
    __privateAdd(this, _width);
    __privateAdd(this, _height);
    this.prerender = true;
    __privateSet(this, _width, defaultSize);
    __privateSet(this, _height, defaultSize);
    __privateSet(this, _uid3, options.id);
    __privateSet(this, _program5, new Program(renderer, {
      vertexShader: vert$3,
      fragmentShader: frag$8,
      uniforms: {
        u_image0: {
          value: void 0
        },
        dataRange: {
          value: void 0
        }
      },
      defines: [`RENDER_TYPE ${this.options.bandType}`, `LITTLE_ENDIAN ${littleEndian}`],
      includes: shaderLib
    }));
    const opt = {
      width: __privateGet(this, _width),
      height: __privateGet(this, _height),
      minFilter: renderer.gl.NEAREST,
      magFilter: renderer.gl.NEAREST,
      type: this.renderer.gl.FLOAT,
      format: this.renderer.gl.RGBA,
      // generateMipmaps: false,
      internalFormat: this.renderer.isWebGL2 ? this.renderer.gl.RGBA32F : this.renderer.gl.RGBA,
      stencil: true
    };
    __privateSet(this, _current3, new RenderTarget(renderer, {
      ...opt,
      name: "currentRenderTargetTexture"
    }));
    __privateSet(this, _next3, new RenderTarget(renderer, {
      ...opt,
      name: "nextRenderTargetTexture"
    }));
  }
  resize(width, height) {
    var _a2, _b;
    if (width !== __privateGet(this, _width) || height !== __privateGet(this, _height)) {
      (_a2 = __privateGet(this, _current3)) == null ? void 0 : _a2.resize(width, height);
      (_b = __privateGet(this, _next3)) == null ? void 0 : _b.resize(width, height);
      __privateSet(this, _width, width);
      __privateSet(this, _height, height);
    }
  }
  get textures() {
    var _a2, _b;
    return {
      current: (_a2 = __privateGet(this, _current3)) == null ? void 0 : _a2.texture,
      next: (_b = __privateGet(this, _next3)) == null ? void 0 : _b.texture
    };
  }
  renderTexture(renderTarget, rendererParams, rendererState, sourceCache) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    if (!sourceCache) {
      return;
    }
    const { stencilConfigForOverlap } = this.options;
    const camera = rendererParams.cameras.planeCamera;
    const coordsAscending = sourceCache.getVisibleCoordinates();
    const coordsDescending = coordsAscending.slice().reverse();
    if (!coordsDescending.length)
      return;
    let xmin = Infinity;
    let ymin = Infinity;
    let xmax = -Infinity;
    let ymax = -Infinity;
    let zmin = Infinity;
    let zmax = -Infinity;
    for (let n = 0; n < coordsDescending.length; n++) {
      const tileId = coordsDescending[n];
      const bounds = tileId.getTileProjBounds();
      xmin = Math.min(bounds.left, xmin);
      xmax = Math.max(bounds.right, xmax);
      zmin = Math.min(tileId.z, zmin);
      zmax = Math.max(tileId.z, zmax);
      if (!rendererState.u_flip_y) {
        ymin = Math.min(bounds.top, ymin);
        ymax = Math.max(bounds.bottom, ymax);
      } else {
        ymin = Math.min(bounds.bottom, ymin);
        ymax = Math.max(bounds.top, ymax);
      }
    }
    const zz = this.options.getTileProjSize(zmax, coordsDescending);
    const dx = xmax - xmin;
    const dy = ymax - ymin;
    const w = dx / zz[0];
    const h = dy / zz[1];
    rendererState.sharedState.u_data_bbox = [xmin, ymin, xmax, ymax];
    rendererState.sharedState.u_data_zooms = [zmin, zmax];
    if (renderTarget) {
      renderTarget.clear();
      renderTarget.bind();
      const attr = this.renderer.attributes;
      if (attr.depth && renderTarget.depth) {
        this.renderer.state.enable(this.renderer.gl.DEPTH_TEST);
        this.renderer.state.setDepthMask(true);
      }
      let width = w * (this.options.source.tileSize ?? defaultSize);
      let height = h * (this.options.source.tileSize ?? defaultSize);
      rendererState.sharedState.u_tiles_size = [width, height];
      const maxTextureSize = this.renderer.gl.getParameter(this.renderer.gl.MAX_TEXTURE_SIZE) * 0.5;
      const maxRenderBufferSize = this.renderer.gl.getParameter(this.renderer.gl.MAX_RENDERBUFFER_SIZE) * 0.5;
      const maxSize = Math.max(width, height);
      if (maxSize > maxTextureSize) {
        width = maxTextureSize / maxSize * width;
        height = maxTextureSize / maxSize * height;
      } else if (maxSize > maxRenderBufferSize) {
        width = maxRenderBufferSize / maxSize * width;
        height = maxRenderBufferSize / maxSize * height;
      }
      this.resize(width, height);
      this.renderer.setViewport(width, height);
    }
    const [stencilModes, coords] = stencilConfigForOverlap(coordsDescending);
    for (let k = 0; k < coords.length; k++) {
      const coord = coords[k];
      if (coord) {
        const tile = sourceCache.getTile(coord);
        if (!(tile && tile.hasData()))
          continue;
        const tileBBox = coord.getTileProjBounds();
        if (!tileBBox)
          continue;
        const tileMesh = tile.createMesh(__privateGet(this, _uid3), tileBBox, this.renderer, __privateGet(this, _program5));
        const mesh = tileMesh.planeMesh;
        const scale = Math.pow(2, zmax - coord.z);
        mesh.scale.set(1 / w * scale, 1 / h * scale, 1);
        if (!rendererState.u_flip_y) {
          mesh.position.set((tileBBox.left - xmin) / dx, (tileBBox.top - ymin) / dy, 0);
        } else {
          mesh.position.set((tileBBox.left - xmin) / dx, 1 - (tileBBox.top - ymin) / dy, 0);
        }
        const dataRange = [];
        for (const [index2, texture] of tile.textures) {
          if (((_a2 = texture.userData) == null ? void 0 : _a2.dataRange) && Array.isArray((_b = texture.userData) == null ? void 0 : _b.dataRange)) {
            dataRange.push(...texture.userData.dataRange);
          }
          mesh.program.setUniform(`u_image${index2}`, texture);
        }
        if (dataRange.length > 0) {
          mesh.program.setUniform("dataRange", dataRange);
        }
        mesh.updateMatrix();
        mesh.worldMatrixNeedsUpdate = false;
        mesh.worldMatrix.multiply(camera.worldMatrix, mesh.localMatrix);
        const stencilMode = stencilModes[coord.overscaledZ];
        if (stencilMode) {
          if (stencilMode.stencil) {
            this.renderer.state.enable(this.renderer.gl.STENCIL_TEST);
            this.renderer.state.setStencilFunc((_c = stencilMode.func) == null ? void 0 : _c.cmp, (_d = stencilMode.func) == null ? void 0 : _d.ref, (_e = stencilMode.func) == null ? void 0 : _e.mask);
            this.renderer.state.setStencilOp((_f = stencilMode.op) == null ? void 0 : _f.fail, (_g = stencilMode.op) == null ? void 0 : _g.zfail, (_h = stencilMode.op) == null ? void 0 : _h.zpass);
          } else {
            this.renderer.state.disable(this.renderer.gl.STENCIL_TEST);
          }
        }
        mesh.draw({
          ...rendererParams,
          camera
        });
      }
    }
    if (renderTarget) {
      renderTarget.unbind();
    }
  }
  /**
   * 此处绘制主要是合并瓦片
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    const { source } = this.options;
    const sourceCache = source.sourceCache;
    if (Array.isArray(sourceCache)) {
      if (sourceCache.length === 2) {
        this.renderTexture(__privateGet(this, _current3), rendererParams, rendererState, sourceCache[0]);
        this.renderTexture(__privateGet(this, _next3), rendererParams, rendererState, sourceCache[1]);
      } else {
        this.renderTexture(__privateGet(this, _current3), rendererParams, rendererState, sourceCache[0]);
        this.renderTexture(__privateGet(this, _next3), rendererParams, rendererState, sourceCache[0]);
      }
    } else {
      this.renderTexture(__privateGet(this, _current3), rendererParams, rendererState, sourceCache);
      this.renderTexture(__privateGet(this, _next3), rendererParams, rendererState, sourceCache);
    }
  }
  destroy() {
    if (__privateGet(this, _program5)) {
      __privateGet(this, _program5).destroy();
      __privateSet(this, _program5, null);
    }
    if (__privateGet(this, _current3)) {
      __privateGet(this, _current3).destroy();
      __privateSet(this, _current3, null);
    }
    if (__privateGet(this, _next3)) {
      __privateGet(this, _next3).destroy();
      __privateSet(this, _next3, null);
    }
  }
};
_program5 = new WeakMap();
_current3 = new WeakMap();
_next3 = new WeakMap();
_uid3 = new WeakMap();
_width = new WeakMap();
_height = new WeakMap();
var frag$4 = "#defines\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_textureNext;uniform sampler2D u_particles;uniform float u_fade_t;uniform vec2 u_image_res;uniform vec4 u_bbox;uniform vec4 u_data_bbox;uniform float u_rand_seed;uniform float u_drop_rate;uniform float u_drop_rate_bump;uniform float u_speed_factor;uniform bool u_initialize;uniform bool u_flip_y;uniform float u_gl_scale;varying vec2 vUv;\n#include <random>\nvec4 calcTexture(const vec2 puv){vec4 color0=texture2D(u_texture,puv);vec4 color1=texture2D(u_textureNext,puv);return mix(color0,color1,u_fade_t);}vec2 decodeValue(const vec2 vc){vec4 rgba=calcTexture(vc);return rgba.rg;}vec2 bilinear(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);vec2 tl=decodeValue(vc);vec2 tr=decodeValue(vc+vec2(px.x,0));vec2 bl=decodeValue(vc+vec2(0,px.y));vec2 br=decodeValue(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}vec2 randomPosToGlobePos(vec2 pos){vec2 min_bbox=u_bbox.xy;vec2 max_bbox=u_bbox.zw;return mix(min_bbox,max_bbox,pos);}bool containsXY(vec2 pos,vec4 bbox){float x=pos.x;return(bbox.x<=x&&x<=bbox.z&&bbox.y<=pos.y&&pos.y<=bbox.w);}vec2 update(vec2 pos){vec2 uv=(pos.xy-u_data_bbox.xy)/(u_data_bbox.zw-u_data_bbox.xy);if(u_flip_y){uv=vec2(uv.x,1.0-uv.y);}vec2 velocity=bilinear(uv);float speed=length(velocity);vec2 v=vec2(velocity.x,-velocity.y);if(u_flip_y){v=vec2(velocity.x,velocity.y);}vec2 offset=v*0.0001*u_speed_factor*u_gl_scale;pos=pos+offset;vec2 seed=(pos.xy+vUv)*u_rand_seed;float drop_rate=u_drop_rate+speed*u_drop_rate_bump;float drop=step(1.0-drop_rate,rand(seed));vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));random_pos=randomPosToGlobePos(random_pos);if(!containsXY(pos.xy,u_data_bbox)||!containsXY(pos.xy,u_bbox)||calcTexture(uv).a==0.0){drop=1.0;}pos=mix(pos,random_pos,drop);return pos;}void main(){vec2 pos=texture2D(u_particles,vUv).xy;pos=update(pos);if(u_initialize){pos=randomPosToGlobePos(pos);for(int i=0;i<25;i++){pos=update(pos);}}gl_FragColor=vec4(pos.xy,0.0,1.0);}";
var _program6, _mesh3, _geometry3, _current4, _next4, _initialize, _particleRes, _UpdatePass_instances, getParticleRes_fn;
var UpdatePass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _UpdatePass_instances);
    __privateAdd(this, _program6);
    __privateAdd(this, _mesh3);
    __privateAdd(this, _geometry3);
    __privateAdd(this, _current4);
    __privateAdd(this, _next4);
    __privateAdd(this, _initialize);
    __privateAdd(this, _particleRes);
    this.prerender = true;
    __privateSet(this, _initialize, true);
    this.initializeRenderTarget();
    __privateSet(this, _program6, new Program(renderer, {
      vertexShader: vert$3,
      fragmentShader: frag$4,
      uniforms: {
        u_fade_t: {
          value: 0
        },
        displayRange: {
          value: new Vector2(-Infinity, Infinity)
        },
        u_texture: {
          value: this.options.texture
        },
        u_textureNext: {
          value: this.options.textureNext
        },
        u_particles: {
          value: null
        }
      },
      defines: [`RENDER_TYPE ${this.options.bandType}`, `LITTLE_ENDIAN ${littleEndian}`],
      includes: shaderLib,
      blending: BlendType.NoBlending,
      transparent: true
    }));
    __privateSet(this, _geometry3, new Geometry(renderer, {
      position: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      uv: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      index: {
        size: 1,
        data: new Uint16Array([0, 1, 2, 2, 1, 3])
      }
    }));
    __privateSet(this, _mesh3, new Mesh(renderer, {
      mode: renderer.gl.TRIANGLES,
      program: __privateGet(this, _program6),
      geometry: __privateGet(this, _geometry3)
    }));
  }
  resize() {
    var _a2, _b;
    const particleRes = __privateMethod(this, _UpdatePass_instances, getParticleRes_fn).call(this);
    (_a2 = __privateGet(this, _current4)) == null ? void 0 : _a2.resize(particleRes, particleRes);
    (_b = __privateGet(this, _next4)) == null ? void 0 : _b.resize(particleRes, particleRes);
  }
  get textures() {
    var _a2, _b;
    return {
      currentParticles: (_a2 = __privateGet(this, _current4)) == null ? void 0 : _a2.texture,
      nextParticles: (_b = __privateGet(this, _next4)) == null ? void 0 : _b.texture
    };
  }
  setInitialize(state) {
    __privateSet(this, _initialize, state);
  }
  /**
   * 创建 RenderTarget
   */
  initializeRenderTarget() {
    const particleRes = __privateMethod(this, _UpdatePass_instances, getParticleRes_fn).call(this);
    const particleState = new Float32Array(particleRes ** 2 * 4);
    const s = this.options.glScale;
    for (let i = 0; i < particleState.length; i++) {
      particleState[i] = Math.random() * s;
    }
    const opt = {
      data: particleState,
      width: particleRes,
      height: particleRes,
      minFilter: this.renderer.gl.NEAREST,
      magFilter: this.renderer.gl.NEAREST,
      type: this.renderer.gl.FLOAT,
      format: this.renderer.gl.RGBA,
      internalFormat: this.renderer.isWebGL2 ? this.renderer.gl.RGBA32F : this.renderer.gl.RGBA,
      stencil: false
    };
    __privateSet(this, _current4, new RenderTarget(this.renderer, {
      ...opt,
      name: "currentUpdateTexture"
    }));
    __privateSet(this, _next4, new RenderTarget(this.renderer, {
      ...opt,
      name: "nextUpdateTexture"
    }));
  }
  /**
   * 交换 RenderTarget
   */
  swapRenderTarget() {
    [__privateWrapper(this, _current4)._, __privateWrapper(this, _next4)._] = [__privateGet(this, _next4), __privateGet(this, _current4)];
  }
  /**
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    var _a2, _b, _c;
    const attr = this.renderer.attributes;
    const camera = rendererParams.cameras.planeCamera;
    const particleRes = __privateMethod(this, _UpdatePass_instances, getParticleRes_fn).call(this);
    if (!__privateGet(this, _particleRes) || __privateGet(this, _particleRes) !== particleRes) {
      __privateSet(this, _particleRes, particleRes);
      this.initializeRenderTarget();
    }
    if (__privateGet(this, _next4)) {
      __privateGet(this, _next4).bind();
      if (attr.depth && __privateGet(this, _next4).depth) {
        this.renderer.state.enable(this.renderer.gl.DEPTH_TEST);
        this.renderer.state.setDepthMask(true);
      }
      this.renderer.setViewport(__privateGet(this, _next4).width, __privateGet(this, _next4).height);
    }
    if (rendererState && __privateGet(this, _mesh3)) {
      const uniforms = index.pick(rendererState, [
        "dataRange",
        "useDisplayRange",
        "displayRange",
        "u_drop_rate",
        "u_drop_rate_bump",
        "u_speed_factor",
        "u_flip_y",
        "u_gl_scale"
      ]);
      Object.keys(uniforms).forEach((key) => {
        var _a3;
        if (uniforms[key] !== void 0) {
          (_a3 = __privateGet(this, _mesh3)) == null ? void 0 : _a3.program.setUniform(key, uniforms[key]);
        }
      });
      const fade = ((_b = (_a2 = this.options.source) == null ? void 0 : _a2.getFadeTime) == null ? void 0 : _b.call(_a2)) || 0;
      __privateGet(this, _mesh3).program.setUniform(
        "u_image_res",
        new Vector2(this.options.texture.width, this.options.texture.height)
      );
      __privateGet(this, _mesh3).program.setUniform("u_fade_t", fade);
      __privateGet(this, _mesh3).program.setUniform("u_rand_seed", Math.random());
      __privateGet(this, _mesh3).program.setUniform("u_particles", (_c = __privateGet(this, _current4)) == null ? void 0 : _c.texture);
      __privateGet(this, _mesh3).program.setUniform("u_bbox", rendererState.extent);
      __privateGet(this, _mesh3).program.setUniform("u_initialize", __privateGet(this, _initialize));
      __privateGet(this, _mesh3).program.setUniform("u_data_bbox", rendererState.sharedState.u_data_bbox);
      __privateGet(this, _mesh3).updateMatrix();
      __privateGet(this, _mesh3).worldMatrixNeedsUpdate = false;
      __privateGet(this, _mesh3).worldMatrix.multiply(camera.worldMatrix, __privateGet(this, _mesh3).localMatrix);
      __privateGet(this, _mesh3).draw({
        ...rendererParams,
        camera
      });
    }
    if (__privateGet(this, _next4)) {
      __privateGet(this, _next4).unbind();
    }
    __privateSet(this, _initialize, false);
    this.swapRenderTarget();
  }
  destroy() {
    if (__privateGet(this, _mesh3)) {
      __privateGet(this, _mesh3).destroy();
      __privateSet(this, _mesh3, null);
    }
    if (__privateGet(this, _program6)) {
      __privateGet(this, _program6).destroy();
      __privateSet(this, _program6, null);
    }
    if (__privateGet(this, _geometry3)) {
      __privateGet(this, _geometry3).destroy();
      __privateSet(this, _geometry3, null);
    }
    if (__privateGet(this, _current4)) {
      __privateGet(this, _current4).destroy();
      __privateSet(this, _current4, null);
    }
    if (__privateGet(this, _next4)) {
      __privateGet(this, _next4).destroy();
      __privateSet(this, _next4, null);
    }
  }
};
_program6 = new WeakMap();
_mesh3 = new WeakMap();
_geometry3 = new WeakMap();
_current4 = new WeakMap();
_next4 = new WeakMap();
_initialize = new WeakMap();
_particleRes = new WeakMap();
_UpdatePass_instances = new WeakSet();
getParticleRes_fn = function() {
  return Math.ceil(Math.sqrt(this.options.getParticleNumber()));
};
var frag$3 = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_screen;uniform float u_opacity;uniform float u_fade;varying vec2 vUv;void main(){vec4 color=texture2D(u_screen,vUv);gl_FragColor=vec4(floor(255.0*color*u_opacity*u_fade)/255.0);}";
var _program7, _mesh4, _geometry4;
var ScreenPass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program7);
    __privateAdd(this, _mesh4);
    __privateAdd(this, _geometry4);
    this.prerender = Boolean(options.prerender);
    __privateSet(this, _program7, new Program(renderer, {
      vertexShader: vert$3,
      fragmentShader: frag$3,
      uniforms: {
        opacity: {
          value: 1
        },
        u_fade: {
          value: 1
        },
        u_screen: {
          value: null
        }
      },
      defines: [`RENDER_TYPE ${this.options.bandType}`, `LITTLE_ENDIAN ${littleEndian}`],
      includes: shaderLib,
      transparent: true,
      blending: options.enableBlend ? BlendType.CustomBlending : BlendType.NoBlending,
      blendFunc: {
        src: this.renderer.gl.ONE,
        dst: this.renderer.gl.ONE_MINUS_SRC_ALPHA
      },
      blendEquation: {
        modeAlpha: this.renderer.gl.FUNC_ADD,
        modeRGB: this.renderer.gl.FUNC_ADD
      }
    }));
    __privateSet(this, _geometry4, new Geometry(renderer, {
      position: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      uv: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      index: {
        size: 1,
        data: new Uint16Array([0, 1, 2, 2, 1, 3])
      }
    }));
    __privateSet(this, _mesh4, new Mesh(renderer, {
      mode: renderer.gl.TRIANGLES,
      program: __privateGet(this, _program7),
      geometry: __privateGet(this, _geometry4)
    }));
  }
  get renderTarget() {
    if (this.options.particlesPass && this.prerender) {
      return this.options.particlesPass.renderTarget;
    }
  }
  /**
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    var _a2, _b, _c;
    if (this.renderTarget) {
      this.renderTarget.bind();
      this.renderer.setViewport(this.renderTarget.width, this.renderTarget.height);
    } else {
      const attr = this.renderer.attributes;
      this.renderer.setViewport(this.renderer.width * attr.dpr, this.renderer.height * attr.dpr);
    }
    if (rendererState && __privateGet(this, _mesh4)) {
      const camera = rendererParams.cameras.planeCamera;
      __privateGet(this, _mesh4).program.setUniform("u_fade", 1);
      __privateGet(this, _mesh4).program.setUniform("u_opacity", this.prerender ? rendererState.fadeOpacity : rendererState.opacity);
      __privateGet(this, _mesh4).program.setUniform(
        "u_screen",
        this.prerender ? (_a2 = this.options.particlesPass) == null ? void 0 : _a2.textures.backgroundTexture : (_b = this.options.particlesPass) == null ? void 0 : _b.textures.screenTexture
      );
      __privateGet(this, _mesh4).updateMatrix();
      __privateGet(this, _mesh4).worldMatrixNeedsUpdate = false;
      __privateGet(this, _mesh4).worldMatrix.multiply(camera.worldMatrix, __privateGet(this, _mesh4).localMatrix);
      __privateGet(this, _mesh4).draw({
        ...rendererParams,
        camera
      });
    }
    if (this.renderTarget) {
      this.renderTarget.unbind();
    }
    if (this.options.particlesPass && !this.prerender) {
      (_c = this.options.particlesPass) == null ? void 0 : _c.swapRenderTarget();
    }
  }
  destroy() {
    if (__privateGet(this, _mesh4)) {
      __privateGet(this, _mesh4).destroy();
      __privateSet(this, _mesh4, null);
    }
    if (__privateGet(this, _program7)) {
      __privateGet(this, _program7).destroy();
      __privateSet(this, _program7, null);
    }
    if (__privateGet(this, _geometry4)) {
      __privateGet(this, _geometry4).destroy();
      __privateSet(this, _geometry4, null);
    }
  }
};
_program7 = new WeakMap();
_mesh4 = new WeakMap();
_geometry4 = new WeakMap();
var vert$2 = "#define GLSLIFY 1\nattribute vec2 reference;attribute float a_index;uniform vec2 resolution;uniform mat4 modelViewMatrix;uniform mat4 viewMatrix;uniform mat4 modelMatrix;uniform mat4 projectionMatrix;uniform sampler2D u_particles;uniform sampler2D u_particles_next;uniform float u_particleSize;uniform float u_particlesRes;varying vec2 v_particle_pos;void main(){float v_index=floor(a_index/6.0);vec2 uv=reference;vec4 color=texture2D(u_particles,uv);vec4 color1=texture2D(u_particles_next,uv);v_particle_pos=mix(color.rg,color1.rg,0.0);gl_PointSize=u_particleSize;gl_Position=projectionMatrix*modelViewMatrix*vec4(v_particle_pos,0.0,1.0);}";
var frag$2 = "#defines\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_textureNext;uniform vec2 u_colorRange;uniform sampler2D u_colorRamp;uniform vec4 u_bbox;uniform vec4 u_data_bbox;uniform float u_fade_t;uniform vec2 u_image_res;varying vec2 v_particle_pos;vec4 calcTexture(const vec2 puv){vec4 color0=texture2D(u_texture,puv);vec4 color1=texture2D(u_textureNext,puv);return mix(color0,color1,u_fade_t);}\n#if RENDER_TYPE == 1\nvec2 decodeValue(const vec2 vc){vec4 rgba=calcTexture(vc);return rgba.rg;}\n#else\nfloat decodeValue(const vec2 vc){return calcTexture(vc).r;}\n#endif\nvec2 bilinear(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);vec2 tl=decodeValue(vc);vec2 tr=decodeValue(vc+vec2(px.x,0));vec2 bl=decodeValue(vc+vec2(0,px.y));vec2 br=decodeValue(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}bool containsXY(vec2 pos,vec4 bbox){float x=pos.x;return(bbox.x<x&&x<bbox.z&&bbox.y<pos.y&&pos.y<bbox.w);}void main(){vec2 pos=v_particle_pos;if(!containsXY(pos.xy,u_data_bbox)||!containsXY(pos.xy,u_bbox)||calcTexture(pos).a==0.0){discard;}vec2 velocity=bilinear(pos);float value=length(velocity);float value_t=(value-u_colorRange.x)/(u_colorRange.y-u_colorRange.x);vec2 ramp_pos=vec2(value_t,0.5);vec4 color=texture2D(u_colorRamp,ramp_pos);float distance=length(2.0*gl_PointCoord-1.0);if(distance>1.0){discard;}gl_FragColor=vec4(floor(255.0*color*color.a)/255.0);}";
var _prerender, _privateNumParticles, _program8, _mesh5, _geometry5, _screenTexture, _backgroundTexture;
var Particles = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _prerender, true);
    __privateAdd(this, _privateNumParticles);
    __privateAdd(this, _program8);
    __privateAdd(this, _mesh5);
    __privateAdd(this, _geometry5);
    __privateAdd(this, _screenTexture);
    __privateAdd(this, _backgroundTexture);
    this.initializeRenderTarget();
    __privateSet(this, _program8, new Program(renderer, {
      vertexShader: vert$2,
      fragmentShader: frag$2,
      uniforms: {
        u_fade_t: {
          value: 0
        },
        displayRange: {
          value: new Vector2(-Infinity, Infinity)
        },
        u_texture: {
          value: this.options.texture
        },
        u_textureNext: {
          value: this.options.textureNext
        },
        u_particles: {
          value: null
        },
        u_particleSize: {
          value: 2
        },
        u_particlesRes: {
          value: 0
        }
      },
      defines: [`RENDER_TYPE ${this.options.bandType}`, `LITTLE_ENDIAN ${littleEndian}`],
      includes: shaderLib,
      transparent: true,
      blending: BlendType.NoBlending,
      blendFunc: {
        src: this.renderer.gl.ONE,
        dst: this.renderer.gl.ONE_MINUS_SRC_ALPHA
      },
      blendEquation: {
        modeAlpha: this.renderer.gl.FUNC_ADD,
        modeRGB: this.renderer.gl.FUNC_ADD
      }
    }));
    const { particleIndices, particleReferences } = this.getParticleBuffer();
    __privateSet(this, _geometry5, new Geometry(renderer, {
      a_index: {
        size: 1,
        data: particleIndices
      },
      reference: {
        size: 2,
        data: particleReferences
      }
    }));
    __privateSet(this, _mesh5, new Mesh(renderer, {
      mode: renderer.gl.POINTS,
      program: __privateGet(this, _program8),
      geometry: __privateGet(this, _geometry5)
    }));
  }
  get prerender() {
    return __privateGet(this, _prerender);
  }
  set prerender(prerender) {
    __privateSet(this, _prerender, prerender);
  }
  get textures() {
    var _a2, _b;
    return {
      screenTexture: (_a2 = __privateGet(this, _screenTexture)) == null ? void 0 : _a2.texture,
      backgroundTexture: (_b = __privateGet(this, _backgroundTexture)) == null ? void 0 : _b.texture
    };
  }
  get renderTarget() {
    return __privateGet(this, _prerender) && __privateGet(this, _screenTexture);
  }
  resetParticles() {
    var _a2, _b;
    (_a2 = __privateGet(this, _screenTexture)) == null ? void 0 : _a2.clear();
    (_b = __privateGet(this, _backgroundTexture)) == null ? void 0 : _b.clear();
  }
  getParticleBuffer() {
    const particleRes = Math.ceil(Math.sqrt(this.options.getParticleNumber()));
    this.particleStateResolution = particleRes;
    __privateSet(this, _privateNumParticles, particleRes * particleRes);
    const indexCount = __privateGet(this, _privateNumParticles);
    const particleIndices = new Float32Array(indexCount);
    const particleReferences = new Float32Array(indexCount * 2);
    for (let i = 0; i < indexCount; i++) {
      const t = i % particleRes / particleRes;
      const a = Math.trunc(i / particleRes) / particleRes;
      particleReferences.set([t, a], 2 * i);
      particleIndices[i] = i;
    }
    return { particleIndices, particleReferences };
  }
  /**
   * 创建 RenderTarget
   */
  initializeRenderTarget() {
    const opt = {
      width: this.renderer.width,
      height: this.renderer.height,
      minFilter: this.renderer.gl.LINEAR,
      magFilter: this.renderer.gl.LINEAR,
      type: this.renderer.gl.UNSIGNED_BYTE,
      format: this.renderer.gl.RGBA,
      stencil: true,
      premultipliedAlpha: false
    };
    __privateSet(this, _screenTexture, new RenderTarget(this.renderer, {
      ...opt,
      name: "screenTexture"
    }));
    __privateSet(this, _backgroundTexture, new RenderTarget(this.renderer, {
      ...opt,
      name: "backgroundTexture"
    }));
  }
  /**
   * 交换 RenderTarget
   */
  swapRenderTarget() {
    [__privateWrapper(this, _screenTexture)._, __privateWrapper(this, _backgroundTexture)._] = [__privateGet(this, _backgroundTexture), __privateGet(this, _screenTexture)];
  }
  /**
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    var _a2, _b;
    if (this.renderTarget) {
      this.renderTarget.bind();
      this.renderer.setViewport(this.renderTarget.width, this.renderTarget.height);
    } else {
      const attr = this.renderer.attributes;
      this.renderer.setViewport(this.renderer.width * attr.dpr, this.renderer.height * attr.dpr);
    }
    const { camera } = rendererParams.cameras;
    let stencil;
    if (this.maskPass) {
      stencil = this.maskPass.render(rendererParams, rendererState);
    }
    if (rendererState && __privateGet(this, _mesh5)) {
      __privateGet(this, _mesh5).program.setUniform(
        "u_image_res",
        new Vector2(this.options.texture.width, this.options.texture.height)
      );
      const fade = ((_b = (_a2 = this.options.source) == null ? void 0 : _a2.getFadeTime) == null ? void 0 : _b.call(_a2)) || 0;
      __privateGet(this, _mesh5).program.setUniform("u_fade_t", fade);
      __privateGet(this, _mesh5).program.setUniform("u_colorRamp", rendererState.colorRampTexture);
      __privateGet(this, _mesh5).program.setUniform("u_colorRange", rendererState.colorRange);
      const particleTextures = this.options.getParticles();
      __privateGet(this, _mesh5).program.setUniform("u_particles", particleTextures.currentParticles);
      __privateGet(this, _mesh5).program.setUniform("u_particles_next", particleTextures.nextParticles);
      __privateGet(this, _mesh5).program.setUniform("u_particlesRes", __privateGet(this, _privateNumParticles));
      const sharedState = rendererState.sharedState;
      __privateGet(this, _mesh5).program.setUniform("u_bbox", rendererState.extent);
      __privateGet(this, _mesh5).program.setUniform("u_data_bbox", sharedState.u_data_bbox);
      __privateGet(this, _mesh5).program.setUniform("u_flip_y", rendererState.u_flip_y);
      __privateGet(this, _mesh5).program.setUniform("u_gl_scale", rendererState.u_gl_scale);
      __privateGet(this, _mesh5).updateMatrix();
      __privateGet(this, _mesh5).worldMatrixNeedsUpdate = false;
      __privateGet(this, _mesh5).worldMatrix.multiply(rendererParams.scene.worldMatrix, __privateGet(this, _mesh5).localMatrix);
      __privateGet(this, _mesh5).draw({
        ...rendererParams,
        camera
      });
    }
    if (!stencil) {
      this.renderer.state.disable(this.renderer.gl.STENCIL_TEST);
    }
    if (this.renderTarget) {
      this.renderTarget.unbind();
    }
  }
  destroy() {
    if (__privateGet(this, _mesh5)) {
      __privateGet(this, _mesh5).destroy();
      __privateSet(this, _mesh5, null);
    }
    if (__privateGet(this, _program8)) {
      __privateGet(this, _program8).destroy();
      __privateSet(this, _program8, null);
    }
    if (__privateGet(this, _geometry5)) {
      __privateGet(this, _geometry5).destroy();
      __privateSet(this, _geometry5, null);
    }
    if (__privateGet(this, _screenTexture)) {
      __privateGet(this, _screenTexture).destroy();
      __privateSet(this, _screenTexture, null);
    }
    if (__privateGet(this, _backgroundTexture)) {
      __privateGet(this, _backgroundTexture).destroy();
      __privateSet(this, _backgroundTexture, null);
    }
  }
};
_prerender = new WeakMap();
_privateNumParticles = new WeakMap();
_program8 = new WeakMap();
_mesh5 = new WeakMap();
_geometry5 = new WeakMap();
_screenTexture = new WeakMap();
_backgroundTexture = new WeakMap();
var vert$1 = "#define GLSLIFY 1\n#defines\nattribute vec2 uv;attribute vec3 position;uniform vec2 resolution;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;varying vec2 vUv;void main(){vUv=vec2(uv.x,1.0-uv.y);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}";
var frag$1 = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_textureNext;uniform float u_fade_t;varying vec2 vUv;void main(){vec2 uv=vUv;vec4 color0=texture2D(u_texture,vUv);vec4 color1=texture2D(u_textureNext,vUv);vec4 color=mix(color0,color1,u_fade_t);gl_FragColor=color;}";
var _program9, _mesh6, _geometry6, _picker, _rendererParams, _rendererState;
var PickerPass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program9);
    __privateAdd(this, _mesh6);
    __privateAdd(this, _geometry6);
    __privateAdd(this, _picker);
    __privateAdd(this, _rendererParams);
    __privateAdd(this, _rendererState);
    this.prerender = true;
    __privateSet(this, _program9, new Program(renderer, {
      vertexShader: vert$1,
      fragmentShader: frag$1,
      uniforms: {
        u_fade_t: {
          value: 0
        },
        u_texture: {
          value: this.options.texture
        },
        u_textureNext: {
          value: this.options.textureNext
        }
      },
      includes: shaderLib,
      transparent: true
    }));
    __privateSet(this, _geometry6, new Geometry(renderer, {
      position: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      uv: {
        size: 2,
        data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
      },
      index: {
        size: 1,
        data: new Uint16Array([0, 1, 2, 2, 1, 3])
      }
    }));
    __privateSet(this, _mesh6, new Mesh(renderer, {
      mode: renderer.gl.TRIANGLES,
      program: __privateGet(this, _program9),
      geometry: __privateGet(this, _geometry6)
    }));
    const opt = {
      width: this.renderer.width,
      height: this.renderer.height,
      minFilter: renderer.gl.NEAREST,
      magFilter: renderer.gl.NEAREST,
      type: this.renderer.gl.UNSIGNED_BYTE,
      format: this.renderer.gl.RGBA,
      generateMipmaps: true,
      internalFormat: this.renderer.gl.RGBA,
      stencil: false
    };
    if (options.useFloatTexture) {
      opt.type = this.renderer.gl.FLOAT;
      opt.internalFormat = this.renderer.isWebGL2 ? this.renderer.gl.RGBA32F : this.renderer.gl.RGBA;
    }
    __privateSet(this, _picker, new RenderTarget(renderer, {
      ...opt,
      name: "pickerRenderTargetTexture"
    }));
  }
  resize(width, height) {
    var _a2;
    (_a2 = __privateGet(this, _picker)) == null ? void 0 : _a2.resize(width, height);
  }
  /**
   * @param rendererParams
   * @param rendererState
   * @param pixel
   */
  render(rendererParams = __privateGet(this, _rendererParams), rendererState = __privateGet(this, _rendererState), pixel) {
    return new Promise((resolve) => {
      var _a2, _b;
      if (!__privateGet(this, _picker) || !__privateGet(this, _mesh6))
        return resolve(null);
      __privateSet(this, _rendererParams, __privateGet(this, _rendererParams) !== rendererParams ? rendererParams : __privateGet(this, _rendererParams));
      __privateSet(this, _rendererState, __privateGet(this, _rendererState) !== rendererState ? rendererState : __privateGet(this, _rendererState));
      const camera = rendererParams.cameras.planeCamera;
      __privateGet(this, _picker).clear();
      __privateGet(this, _picker).bind();
      this.renderer.setViewport(__privateGet(this, _picker).width, __privateGet(this, _picker).height);
      if (rendererState) {
        const fade = ((_b = (_a2 = this.options.source) == null ? void 0 : _a2.getFadeTime) == null ? void 0 : _b.call(_a2)) || 0;
        __privateGet(this, _mesh6).program.setUniform("u_fade_t", fade);
        __privateGet(this, _mesh6).updateMatrix();
        __privateGet(this, _mesh6).worldMatrixNeedsUpdate = false;
        __privateGet(this, _mesh6).worldMatrix.multiply(camera.worldMatrix, __privateGet(this, _mesh6).localMatrix);
        __privateGet(this, _mesh6).draw({
          ...rendererParams,
          camera
        });
        if (pixel) {
          const a = this.options.useFloatTexture ? new Float32Array(4) : new Uint8Array(4);
          this.renderer.gl.readPixels(
            pixel[0],
            pixel[1],
            1,
            1,
            this.renderer.gl.RGBA,
            this.options.useFloatTexture ? this.renderer.gl.FLOAT : this.renderer.gl.UNSIGNED_BYTE,
            a
          );
          resolve(a);
        } else {
          resolve(null);
        }
      } else {
        resolve(null);
      }
      __privateGet(this, _picker).unbind();
    });
  }
  destroy() {
    if (__privateGet(this, _mesh6)) {
      __privateGet(this, _mesh6).destroy();
      __privateSet(this, _mesh6, null);
    }
    if (__privateGet(this, _program9)) {
      __privateGet(this, _program9).destroy();
      __privateSet(this, _program9, null);
    }
    if (__privateGet(this, _geometry6)) {
      __privateGet(this, _geometry6).destroy();
      __privateSet(this, _geometry6, null);
    }
    if (__privateGet(this, _picker)) {
      __privateGet(this, _picker).destroy();
      __privateSet(this, _picker, null);
    }
  }
};
_program9 = new WeakMap();
_mesh6 = new WeakMap();
_geometry6 = new WeakMap();
_picker = new WeakMap();
_rendererParams = new WeakMap();
_rendererState = new WeakMap();
function parseColorStyle(styleAttrField) {
  if (Array.isArray(styleAttrField) && styleAttrField.length > 3) {
    const type = styleAttrField[0];
    const action = styleAttrField[1];
    const interpolateColor = [];
    for (let i = 3; i < styleAttrField.length; i += 2) {
      const val = styleAttrField[i];
      const color = styleAttrField[i + 1];
      interpolateColor.push({
        key: val,
        value: color
      });
    }
    return {
      operator: type,
      interpolation: {
        name: action[0],
        base: action[1]
      },
      input: interpolateColor
    };
  } else {
    console.warn("[wind-core]: style-parser style config invalid");
    return {};
  }
}
function parseZoomStyle(styleAttrField) {
  if (Array.isArray(styleAttrField) && styleAttrField.length > 3) {
    const type = styleAttrField[0];
    const action = styleAttrField[1];
    const interpolateZoom = [];
    for (let i = 3; i < styleAttrField.length; i += 2) {
      const val = styleAttrField[i];
      const color = styleAttrField[i + 1];
      interpolateZoom.push({
        key: val,
        value: color
      });
    }
    return {
      operator: type,
      interpolation: {
        name: action[0],
        base: action[1]
      },
      input: interpolateZoom
    };
  } else {
    console.warn("[wind-core]: style-parser style config invalid");
    return {};
  }
}
function createGradient(interpolateColor, min, max, w, h, gradient, ctx) {
  for (let i = 0; i < interpolateColor.length; i += 1) {
    const key = interpolateColor[i].key;
    const color = interpolateColor[i].value;
    gradient.addColorStop((key - min) / (max - min), color);
  }
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, w, h);
}
function createStepGradient(interpolateColor, min, max, w, h, ctx) {
  for (let i = 0; i < interpolateColor.length; i += 1) {
    const key = interpolateColor[i].key;
    let keyNext = key;
    if (i < interpolateColor.length - 1) {
      keyNext = interpolateColor[i + 1].key;
    } else {
      keyNext = max;
    }
    const color = interpolateColor[i].value;
    const current = (key - min) / (max - min) * w;
    const next = (keyNext - min) / (max - min) * w;
    ctx.fillStyle = color;
    ctx.fillRect(current, 0, next - current, 1);
  }
}
function createLinearGradient(range, styleAttrField) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  const { input: interpolateColor, interpolation } = parseColorStyle(styleAttrField);
  if (ctx && interpolateColor && Array.isArray(interpolateColor)) {
    const keys = interpolateColor.map((d) => parseFloat(d.key));
    const colorRange = [Math.min(...keys), Math.max(...keys)];
    const [min, max] = [range[0] || colorRange[0], range[1] || colorRange[1]];
    const w = 256;
    const h = 1;
    canvas.width = w;
    canvas.height = h;
    const gradient = ctx.createLinearGradient(0, 0, w, 0);
    if ((interpolation == null ? void 0 : interpolation.name) === "linear") {
      createGradient(interpolateColor, min, max, w, h, gradient, ctx);
    } else if ((interpolation == null ? void 0 : interpolation.name) === "step") {
      if ((interpolation == null ? void 0 : interpolation.base) === true || index.isNumber(interpolation == null ? void 0 : interpolation.base)) {
        const interval = Number(interpolation == null ? void 0 : interpolation.base);
        createGradient(interpolateColor, min, max, w, h, gradient, ctx);
        const len = Math.round((max - min) / interval);
        const canvas2 = document.createElement("canvas");
        const ctx2 = canvas2.getContext("2d", {
          willReadFrequently: true
        });
        canvas2.width = w;
        canvas2.height = h;
        for (let j = 0; j < len; j++) {
          let keyNext = j;
          if (j < len - 1) {
            keyNext = j + 1;
          } else {
            keyNext = len;
          }
          const current = Math.round(j / len * w);
          const color = ctx.getImageData(current, 0, 1, 1).data;
          const next = Math.round(keyNext / len * w);
          ctx2.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
          ctx2.fillRect(current, 0, next - current, h);
        }
        return {
          data: new Uint8Array(ctx2.getImageData(0, 0, w, h).data),
          colorRange
        };
      } else if ((interpolation == null ? void 0 : interpolation.base) === false) {
        createStepGradient(interpolateColor, min, max, w, h, ctx);
      }
    } else {
      console.warn(`[wind-core]: invalid action type: ${interpolation}`);
    }
    return {
      data: new Uint8Array(ctx.getImageData(0, 0, w, h).data),
      colorRange
    };
  } else {
    return {};
  }
}
function exponentialInterpolation(input, base, lowerValue, upperValue) {
  const difference = upperValue - lowerValue;
  const progress = input - lowerValue;
  if (difference === 0) {
    return 0;
  } else if (base === 1) {
    return progress / difference;
  } else {
    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
  }
}
function interpolationFactor(interpolation, input, lower, upper) {
  let t = 0;
  if (interpolation.name === "exponential") {
    t = exponentialInterpolation(input, interpolation.base, lower, upper);
  } else if (interpolation.name === "linear") {
    t = exponentialInterpolation(input, 1, lower, upper);
  } else if (interpolation.name === "cubic-bezier") {
    console.warn("interpolationFactor");
  }
  return t;
}
function interpolateNumber(a, b, t) {
  return a * (1 - t) + b * t;
}
var cachedStyle = {};
function isRasterize(styleAttrField) {
  if (Array.isArray(styleAttrField) && styleAttrField.length > 3) {
    const type = styleAttrField[0];
    return type === "rasterize";
  } else {
    console.warn("[wind-core]: style-parser style config invalid");
    return false;
  }
}
function createZoom(uid, zoom, key, styles, clearCache) {
  const ukey = `${uid}_${key}`;
  const styleAttrField = styles[key];
  if (index.isNumber(styleAttrField)) {
    if (cachedStyle[ukey]) {
      delete cachedStyle[ukey];
    }
    return styleAttrField;
  }
  if (styleAttrField && Array.isArray(styleAttrField) && (!cachedStyle[ukey] || clearCache)) {
    cachedStyle[ukey] = parseZoomStyle(styleAttrField);
  }
  if (cachedStyle[ukey]) {
    const { input: interpolateZoom, interpolation } = cachedStyle[ukey] || {};
    if (interpolateZoom && Array.isArray(interpolateZoom)) {
      const labels = interpolateZoom.map((i) => i.key);
      const outputs = interpolateZoom.map((i) => i.value);
      if (zoom <= labels[0]) {
        return outputs[0];
      }
      const stopCount = labels.length;
      if (zoom >= labels[stopCount - 1]) {
        return outputs[stopCount - 1];
      }
      const index2 = findStopLessThanOrEqualTo(labels, zoom);
      const idx = labels.length - 1;
      const lower = labels[index2];
      const upper = labels[index2 >= idx ? idx : index2 + 1];
      const t = interpolationFactor(interpolation, zoom, lower, upper);
      const outputLower = outputs[index2];
      const outputUpper = outputs[index2 >= idx ? idx : index2 + 1];
      return interpolateNumber(outputLower, outputUpper, t);
    } else {
      return 1;
    }
  }
  return 1;
}
var RenderType = ((RenderType2) => {
  RenderType2[RenderType2["image"] = 0] = "image";
  RenderType2[RenderType2["colorize"] = 1] = "colorize";
  RenderType2[RenderType2["particles"] = 2] = "particles";
  RenderType2[RenderType2["arrow"] = 3] = "arrow";
  RenderType2[RenderType2["barb"] = 4] = "barb";
  RenderType2[RenderType2["wave"] = 5] = "wave";
  return RenderType2;
})(RenderType || {});
var RenderFrom = ((RenderFrom2) => {
  RenderFrom2["r"] = "r";
  RenderFrom2["rg"] = "rg";
  RenderFrom2["rgba"] = "rgba";
  RenderFrom2["float"] = "float";
  return RenderFrom2;
})(RenderFrom || {});
function getBandType(renderFrom) {
  if (renderFrom === "rg") {
    return 1;
  }
  if (renderFrom === "rgba") {
    return 2;
  }
  if (renderFrom === "float") {
    return 3;
  }
  return 0;
}
var DecodeType = ((DecodeType2) => {
  DecodeType2[DecodeType2["image"] = 0] = "image";
  DecodeType2[DecodeType2["unit8"] = 1] = "unit8";
  DecodeType2[DecodeType2["tiff"] = 2] = "tiff";
  DecodeType2[DecodeType2["imageWithExif"] = 3] = "imageWithExif";
  return DecodeType2;
})(DecodeType || {});
var LayerSourceType = ((LayerSourceType2) => {
  LayerSourceType2["image"] = "image";
  LayerSourceType2["tile"] = "tile";
  LayerSourceType2["timeline"] = "timeline";
  return LayerSourceType2;
})(LayerSourceType || {});
var TileState = ((TileState2) => {
  TileState2["loading"] = "0";
  TileState2["loaded"] = "1";
  TileState2["errored"] = "2";
  TileState2["unloaded"] = "3";
  TileState2["reloading"] = "4";
  return TileState2;
})(TileState || {});
var MaskType = ((MaskType2) => {
  MaskType2[MaskType2["outside"] = 0] = "outside";
  MaskType2[MaskType2["inside"] = 1] = "inside";
  return MaskType2;
})(MaskType || {});
var maskVert = "#define GLSLIFY 1\nattribute vec3 position;uniform vec3 cameraPosition;uniform mat4 viewMatrix;uniform mat4 modelMatrix;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;uniform float u_offset;void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position+vec3(u_offset,0.0,0.0),1.0);}";
var maskFrag = "#defines\nprecision mediump float;\n#define GLSLIFY 1\nvoid main(){gl_FragColor=vec4(0.0,0.0,0.0,0.0);}";
var _program10, _meshes;
var MaskPass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _program10);
    __privateAdd(this, _meshes);
    this.prerender = true;
    __privateSet(this, _program10, new Program(renderer, {
      vertexShader: maskVert,
      fragmentShader: maskFrag,
      includes: shaderLib,
      transparent: true
    }));
    __privateSet(this, _meshes, []);
    this.updateGeometry();
  }
  updateGeometry() {
    const { mask } = this.options;
    if (!mask || mask.data.length === 0)
      return;
    const len = mask.data.length;
    let i = 0;
    for (let k = 0; k < __privateGet(this, _meshes).length; k++) {
      const mesh = __privateGet(this, _meshes)[k];
      if (mesh.geometry) {
        mesh.geometry.destroy();
      }
    }
    __privateSet(this, _meshes, []);
    for (; i < len; i++) {
      const attributes = mask.data[i];
      __privateGet(this, _meshes).push(
        new Mesh(this.renderer, {
          mode: this.renderer.gl.TRIANGLES,
          program: __privateGet(this, _program10),
          geometry: new Geometry(this.renderer, attributes)
        })
      );
    }
  }
  /**
   * @param rendererParams
   * @param rendererState
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(rendererParams, rendererState) {
    var _a2;
    const attr = this.renderer.attributes;
    this.renderer.setViewport(this.renderer.width * attr.dpr, this.renderer.height * attr.dpr);
    const { worlds = [0] } = rendererParams.cameras;
    const stencil = this.renderer.gl.getParameter(this.renderer.gl.STENCIL_TEST);
    if (!stencil) {
      this.renderer.state.enable(this.renderer.gl.STENCIL_TEST);
    }
    this.renderer.gl.stencilFunc(this.renderer.gl.ALWAYS, 1, 255);
    this.renderer.gl.stencilOp(this.renderer.gl.REPLACE, this.renderer.gl.REPLACE, this.renderer.gl.REPLACE);
    this.renderer.gl.stencilMask(255);
    this.renderer.gl.clearStencil(0);
    this.renderer.gl.clear(this.renderer.gl.STENCIL_BUFFER_BIT);
    for (let k = 0; k < __privateGet(this, _meshes).length; k++) {
      const mesh = __privateGet(this, _meshes)[k];
      for (let j = 0; j < worlds.length; j++) {
        mesh.program.setUniform("u_offset", worlds[j]);
        mesh.updateMatrix();
        mesh.worldMatrixNeedsUpdate = false;
        mesh.worldMatrix.multiply(rendererParams.scene.worldMatrix, mesh.localMatrix);
        mesh.draw({
          ...rendererParams,
          camera: rendererParams.cameras.camera
        });
      }
    }
    const ref = ((_a2 = this.options.mask) == null ? void 0 : _a2.type) === MaskType.outside ? 0 : 1;
    this.renderer.gl.stencilFunc(this.renderer.gl.EQUAL, ref, 255);
    this.renderer.gl.stencilOp(this.renderer.gl.KEEP, this.renderer.gl.KEEP, this.renderer.gl.KEEP);
    return stencil;
  }
};
_program10 = new WeakMap();
_meshes = new WeakMap();
var ArrowComposePass = class extends ParticlesComposePass {
};
var vert = "#define GLSLIFY 1\n#defines\nattribute vec2 uv;attribute vec2 position;attribute vec2 coords;uniform vec2 arrowSize;uniform float u_head;uniform vec2 resolution;uniform float u_devicePixelRatio;uniform vec2 pixelsToProjUnit;uniform vec3 cameraPosition;uniform mat4 viewMatrix;uniform mat4 modelMatrix;uniform mat4 projectionMatrix;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform sampler2D u_texture;uniform sampler2D u_textureNext;uniform sampler2D colorRampTexture;uniform float u_fade_t;uniform vec2 u_image_res;uniform vec2 colorRange;uniform bool useDisplayRange;uniform bool u_flip_y;uniform float u_zoomScale;uniform vec2 displayRange;uniform vec4 u_bbox;uniform vec4 u_data_bbox;uniform vec4 u_tile_bbox;varying vec2 vUv;varying float v_speed;varying float v_speed_t;varying float v_head;varying float v_body;varying float v_antialias;varying float v_linewidth;vec4 calcTexture(const vec2 puv){vec4 color0=texture2D(u_texture,puv);vec4 color1=texture2D(u_textureNext,puv);return mix(color0,color1,u_fade_t);}vec2 decodeValue(const vec2 vc){vec4 rgba=calcTexture(vc);return rgba.rg;}vec2 bilinear(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);vec2 tl=decodeValue(vc);vec2 tr=decodeValue(vc+vec2(px.x,0.0));vec2 bl=decodeValue(vc+vec2(0.0,px.y));vec2 br=decodeValue(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}float getValue(vec2 rg){return length(rg);}float getAngle(vec2 rg){float angle=atan(rg.y,rg.x);return angle;}void rotate2d(inout vec2 v,float a){mat2 m=mat2(cos(a),-sin(a),sin(a),cos(a));v=m*v;}void main(){vUv=uv;vec2 pos=u_tile_bbox.xy+coords.xy*(u_tile_bbox.zw-u_tile_bbox.xy);vec2 size=arrowSize*u_zoomScale*pixelsToProjUnit*u_devicePixelRatio;vec2 halfSize=size/2.0;vec2 worldPosition=vec2(-halfSize.x,-halfSize.y);if(position.x==1.0){worldPosition.x=halfSize.x;}if(position.y==1.0){worldPosition.y=halfSize.y;}worldPosition+=halfSize*vec2(1.0,0);vec2 textureCoord=(pos.xy-u_data_bbox.xy)/(u_data_bbox.zw-u_data_bbox.xy);if(u_flip_y){textureCoord=vec2(textureCoord.x,1.0-textureCoord.y);}vec2 rg=bilinear(textureCoord);float value=getValue(rg);float angle=getAngle(rg);angle=u_flip_y ? angle*-1. : angle;rotate2d(worldPosition,angle);worldPosition+=pos;v_speed=value;v_speed_t=(value-colorRange.x)/(colorRange.y-colorRange.x);v_linewidth=mix(0.18,0.12,v_speed_t);v_head=u_head;v_antialias=1.0/min(arrowSize.x,arrowSize.y);v_body=mix(0.15,4.0,v_speed_t)*3.0;gl_Position=projectionMatrix*viewMatrix*modelMatrix*vec4(worldPosition,0.0,1.0);}";
var frag = "#defines\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_textureNext;uniform sampler2D colorRampTexture;uniform float u_fade_t;uniform vec2 u_image_res;uniform vec2 colorRange;uniform bool useDisplayRange;uniform vec2 displayRange;uniform float opacity;varying vec2 vUv;varying float v_speed;varying float v_speed_t;varying float v_head;varying float v_body;varying float v_antialias;varying float v_linewidth;vec4 calcTexture(const vec2 puv){vec4 color0=texture2D(u_texture,puv);vec4 color1=texture2D(u_textureNext,puv);return mix(color0,color1,u_fade_t);}float disc(vec2 pos,float size){return length(pos)-size/2.0;}vec4 filled(float distance,float linewidth,float antialias,vec4 fill){vec4 frag_color=vec4(0.0);float t=linewidth/2.0-antialias;float signed_distance=distance;float border_distance=abs(signed_distance)-t;float alpha=border_distance/antialias;alpha=exp(-alpha*alpha);if(border_distance<0.0){frag_color=fill;}else if(signed_distance<0.0){frag_color=fill;}return frag_color;}float line_distance(vec2 p,vec2 p1,vec2 p2){vec2 center=(p1+p2)*0.5;float len=length(p2-p1);vec2 dir=(p2-p1)/len;vec2 rel_p=p-center;return dot(rel_p,vec2(dir.y,-dir.x));}float segment_distance(vec2 p,vec2 p1,vec2 p2){vec2 center=(p1+p2)*0.5;float len=length(p2-p1);vec2 dir=(p2-p1)/len;vec2 rel_p=p-center;float dist1=abs(dot(rel_p,vec2(dir.y,-dir.x)));float dist2=abs(dot(rel_p,dir))-0.5*len;return max(dist1,dist2);}float arrow_stealth(vec2 texcoord,float body,float head,float linewidth,float antialias){float w=linewidth/2.0+antialias;vec2 start=-vec2(body/2.0,0.0);vec2 end=+vec2(body/2.0,0.0);float height=0.5;float d1=line_distance(texcoord,end-head*vec2(+1.0,-height),end);float d2=line_distance(texcoord,end-head*vec2(+1.0,-height),end-vec2(3.0*head/4.0,0.0));float d3=line_distance(texcoord,end-head*vec2(+1.0,+height),end);float d4=line_distance(texcoord,end-head*vec2(+1.0,+0.5),end-vec2(3.0*head/4.0,0.0));float d5=segment_distance(texcoord,start,end-vec2(linewidth,0.0));return min(d5,max(max(-d1,d3),-max(-d2,d4)));}void main(){vec2 uv=vUv;if(calcTexture(uv).a==0.0||v_speed<0.0){discard;}vec2 pos=vUv-vec2(0.0,0.5);vec2 ramp_pos=vec2(v_speed_t,0.5);vec4 color=texture2D(colorRampTexture,ramp_pos);bool display=true;if(useDisplayRange){display=v_speed<=displayRange.y&&v_speed>=displayRange.x;}if(display){if(v_speed>0.2){float d=arrow_stealth(pos.xy,v_body,v_head,v_linewidth,v_antialias);vec4 rc=filled(d,0.15,0.01,color);gl_FragColor=vec4(floor(255.0*rc*opacity)/255.0);}else{float d=disc(pos,0.15);vec4 rc=filled(d,0.01,0.01,color);gl_FragColor=vec4(floor(255.0*rc*opacity)/255.0);}}else{gl_FragColor=vec4(0.0,0.0,0.0,0.0);}}";
var TILE_EXTENT = 4096;
var _mesh7, _program11, _geometry7, _vertexArray, _lastTileSize, _lastSpace;
var ArrowPass = class extends Pass {
  constructor(id, renderer, options = {}) {
    super(id, renderer, options);
    __privateAdd(this, _mesh7);
    __privateAdd(this, _program11);
    __privateAdd(this, _geometry7);
    __privateAdd(this, _vertexArray);
    __privateAdd(this, _lastTileSize);
    __privateAdd(this, _lastSpace);
    this.prerender = false;
    __privateSet(this, _program11, new Program(renderer, {
      vertexShader: vert,
      fragmentShader: frag,
      uniforms: {
        opacity: {
          value: 1
        },
        u_fade_t: {
          value: 0
        },
        displayRange: {
          value: new Vector2(-Infinity, Infinity)
        },
        u_texture: {
          value: this.options.texture
        },
        u_textureNext: {
          value: this.options.textureNext
        },
        colorRampTexture: {
          value: null
        }
      },
      defines: [`RENDER_TYPE ${this.options.bandType}`, `LITTLE_ENDIAN ${littleEndian}`],
      includes: shaderLib,
      transparent: true
    }));
    __privateSet(this, _mesh7, new Mesh(this.renderer, {
      mode: this.renderer.gl.TRIANGLES,
      program: __privateGet(this, _program11),
      geometry: new Geometry(this.renderer, {
        index: {
          size: 1,
          // data: new Uint16Array([0, 1, 2, 2, 1, 3]),
          data: new Uint16Array([0, 1, 2, 0, 2, 3])
        },
        position: {
          size: 2,
          // data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
          data: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1])
        },
        uv: {
          size: 2,
          data: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1])
        },
        coords: {
          divisor: 1,
          data: new Float32Array(2),
          offset: 0,
          size: 2,
          stride: 8
        }
      })
    }));
  }
  createTileVertexArray(tileSize, space = 20) {
    if (!__privateGet(this, _vertexArray) || tileSize !== __privateGet(this, _lastTileSize) || space !== __privateGet(this, _lastSpace)) {
      __privateSet(this, _lastTileSize, tileSize);
      __privateSet(this, _lastSpace, space);
      const column = Math.round(tileSize / space);
      const columnUnit = 1 / column;
      const halfUnit = columnUnit / 2;
      const points = [];
      for (let j = 0; j < column; j++) {
        for (let i = 0; i < column; i++) {
          points.push({
            x: TILE_EXTENT * (halfUnit + i * columnUnit),
            y: TILE_EXTENT * (halfUnit + j * columnUnit)
          });
        }
      }
      __privateSet(this, _vertexArray, new Float32Array(points.length * 2));
      for (let i = 0; i < points.length; i++) {
        const point = points[i];
        const pos = {
          x: Math.round(point.x),
          y: Math.round(point.y)
        };
        if (pos.x < 0 || pos.x >= TILE_EXTENT || pos.y < 0 || pos.y >= TILE_EXTENT)
          continue;
        __privateGet(this, _vertexArray)[2 * i] = pos.x / TILE_EXTENT;
        __privateGet(this, _vertexArray)[2 * i + 1] = pos.y / TILE_EXTENT;
      }
      const geometry = new Geometry(this.renderer, {
        index: {
          size: 1,
          data: new Uint16Array([0, 1, 2, 0, 2, 3])
        },
        position: {
          size: 2,
          data: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1])
        },
        uv: {
          size: 2,
          data: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1])
        },
        coords: {
          divisor: 1,
          data: __privateGet(this, _vertexArray),
          offset: 0,
          size: 2,
          stride: 8
        }
      });
      if (__privateGet(this, _mesh7)) {
        __privateGet(this, _mesh7).updateGeometry(geometry, true);
      }
    }
    return __privateGet(this, _vertexArray);
  }
  /**
   * @param rendererParams
   * @param rendererState
   */
  render(rendererParams, rendererState) {
    var _a2, _b;
    const attr = this.renderer.attributes;
    this.renderer.setViewport(this.renderer.width * attr.dpr, this.renderer.height * attr.dpr);
    const camera = rendererParams.cameras.camera;
    const tileSize = this.options.source.tileSize ?? 256;
    const tiles = this.options.getGridTiles(this.options.source);
    let stencil;
    if (this.maskPass) {
      stencil = this.maskPass.render(rendererParams, rendererState);
    }
    if (rendererState && __privateGet(this, _mesh7) && tiles && tiles.length > 0) {
      const uniforms = index.pick(rendererState, [
        "opacity",
        "colorRange",
        "dataRange",
        "colorRampTexture",
        "useDisplayRange",
        "displayRange"
      ]);
      const zoom = rendererState.zoom;
      const dataBounds = rendererState.sharedState.u_data_bbox;
      this.createTileVertexArray(tileSize, rendererState.symbolSpace);
      for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        const bounds = tile.getTileProjBounds();
        const scaleFactor = Math.pow(2, zoom - tile.overscaledZ);
        const max = Math.max(bounds.right - bounds.left, bounds.bottom - bounds.top);
        const scale = 1 / max;
        const pixelToUnits = 1 / (tileSize * scaleFactor) / scale;
        Object.keys(uniforms).forEach((key) => {
          var _a3;
          if (uniforms[key] !== void 0) {
            (_a3 = __privateGet(this, _mesh7)) == null ? void 0 : _a3.program.setUniform(key, uniforms[key]);
          }
        });
        const fade = ((_b = (_a2 = this.options.source) == null ? void 0 : _a2.getFadeTime) == null ? void 0 : _b.call(_a2)) || 0;
        __privateGet(this, _mesh7).program.setUniform(
          "u_image_res",
          new Vector2(this.options.texture.width, this.options.texture.height)
        );
        __privateGet(this, _mesh7).program.setUniform("u_fade_t", fade);
        __privateGet(this, _mesh7).program.setUniform("arrowSize", rendererState.symbolSize);
        __privateGet(this, _mesh7).program.setUniform("pixelsToProjUnit", new Vector2(pixelToUnits, pixelToUnits));
        __privateGet(this, _mesh7).program.setUniform("u_bbox", rendererState.extent);
        __privateGet(this, _mesh7).program.setUniform("u_data_bbox", dataBounds);
        __privateGet(this, _mesh7).program.setUniform(
          "u_tile_bbox",
          rendererState.u_flip_y ? [bounds.left, bounds.bottom, bounds.right, bounds.top] : [bounds.left, bounds.top, bounds.right, bounds.bottom]
        );
        __privateGet(this, _mesh7).program.setUniform("u_head", 0.1);
        __privateGet(this, _mesh7).program.setUniform("u_devicePixelRatio", attr.dpr);
        __privateGet(this, _mesh7).program.setUniform("u_texture", this.options.texture);
        __privateGet(this, _mesh7).program.setUniform("u_textureNext", this.options.textureNext);
        __privateGet(this, _mesh7).program.setUniform("u_flip_y", rendererState.u_flip_y);
        __privateGet(this, _mesh7).program.setUniform("u_zoomScale", rendererState.u_zoomScale);
        __privateGet(this, _mesh7).updateMatrix();
        __privateGet(this, _mesh7).worldMatrixNeedsUpdate = false;
        __privateGet(this, _mesh7).worldMatrix.multiply(rendererParams.scene.worldMatrix, __privateGet(this, _mesh7).localMatrix);
        __privateGet(this, _mesh7).draw({
          ...rendererParams,
          camera
        });
      }
    }
    if (!stencil) {
      this.renderer.state.disable(this.renderer.gl.STENCIL_TEST);
    }
  }
  destroy() {
    if (__privateGet(this, _mesh7)) {
      __privateGet(this, _mesh7).destroy();
      __privateSet(this, _mesh7, null);
    }
    if (__privateGet(this, _program11)) {
      __privateGet(this, _program11).destroy();
      __privateSet(this, _program11, null);
    }
    if (__privateGet(this, _geometry7)) {
      __privateGet(this, _geometry7).destroy();
      __privateSet(this, _geometry7, null);
    }
  }
};
_mesh7 = new WeakMap();
_program11 = new WeakMap();
_geometry7 = new WeakMap();
_vertexArray = new WeakMap();
_lastTileSize = new WeakMap();
_lastSpace = new WeakMap();
var defaultOptions = {
  getViewTiles: () => [],
  getGridTiles: () => [],
  getTileProjSize: (z) => [256, 256],
  // eslint-disable-line
  getPixelsToUnits: () => [1, 1],
  getPixelsToProjUnit: () => [1, 1],
  renderType: RenderType.colorize,
  renderFrom: RenderFrom.r,
  styleSpec: {
    "fill-color": [
      "interpolate",
      ["linear"],
      ["get", "value"],
      0,
      "#3288bd",
      10,
      "#66c2a5",
      20,
      "#abdda4",
      30,
      "#e6f598",
      40,
      "#fee08b",
      50,
      "#fdae61",
      60,
      "#f46d43",
      100,
      "#d53e4f"
    ],
    opacity: 1,
    numParticles: 65535,
    speedFactor: 1,
    fadeOpacity: 0.93,
    dropRate: 3e-3,
    dropRateBump: 2e-3,
    space: 20,
    size: [16, 16]
  },
  displayRange: [Infinity, Infinity],
  widthSegments: 1,
  heightSegments: 1,
  wireframe: false,
  flipY: false,
  glScale: () => 1,
  zoomScale: () => 1,
  onInit: () => void 0
};
var registerDeps = false;
var _opacity, _numParticles, _speedFactor, _fadeOpacity, _dropRate, _dropRateBump, _space, _size, _colorRange, _colorRampTexture, _nextStencilID, _maskPass, _isRasterize;
var BaseLayer = class {
  constructor(source, rs, options) {
    __privateAdd(this, _opacity);
    __privateAdd(this, _numParticles);
    __privateAdd(this, _speedFactor);
    __privateAdd(this, _fadeOpacity);
    __privateAdd(this, _dropRate);
    __privateAdd(this, _dropRateBump);
    __privateAdd(this, _space);
    __privateAdd(this, _size);
    __privateAdd(this, _colorRange);
    __privateAdd(this, _colorRampTexture);
    __privateAdd(this, _nextStencilID);
    __privateAdd(this, _maskPass);
    __privateAdd(this, _isRasterize);
    this.renderer = rs.renderer;
    this.scene = rs.scene;
    this.source = source;
    if (!this.renderer) {
      throw new Error("initialize error");
    }
    this.uid = index.uid("ScalarFill");
    if (!options) {
      options = {};
    }
    this.options = {
      ...defaultOptions,
      ...options,
      styleSpec: {
        ...defaultOptions.styleSpec,
        ...options.styleSpec
      }
    };
    __privateSet(this, _opacity, 1);
    __privateSet(this, _nextStencilID, 1);
    this.dispatcher = new wgw$1.Dispatcher(wgw$1.getGlobalWorkerPool(), this, this.uid);
    if (!registerDeps) {
      const deps = wgw$1.getConfigDeps();
      this.dispatcher.broadcast(
        "configDeps",
        deps.map((d) => resolveURL(d)),
        (err, data) => {
          var _a2, _b;
          (_b = (_a2 = this.options).onInit) == null ? void 0 : _b.call(_a2, err, data);
        }
      );
      registerDeps = true;
    }
    this.update = this.update.bind(this);
    this.onTileLoaded = this.onTileLoaded.bind(this);
    this.source.prepare(this.renderer, this.dispatcher, {
      renderFrom: this.options.renderFrom ?? RenderFrom.r
    });
    this.source.onAdd(this);
    if (Array.isArray(this.source.sourceCache)) {
      this.source.sourceCache.forEach((s) => {
        s.on("update", this.update);
        s.on("tileLoaded", this.onTileLoaded);
      });
    } else {
      this.source.sourceCache.on("update", this.update);
      this.source.sourceCache.on("tileLoaded", this.onTileLoaded);
    }
    this.initialize();
  }
  initialize() {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    this.updateOptions({});
    this.sharedState = {
      u_bbox: [0, 0, 1, 1],
      u_data_bbox: [0, 0, 1, 1],
      u_scale: [1, 1]
    };
    this.renderPipeline = new Pipelines(this.renderer);
    const bandType = getBandType(this.options.renderFrom ?? RenderFrom.r);
    if (this.options.mask) {
      __privateSet(this, _maskPass, new MaskPass("MaskPass", this.renderer, {
        mask: this.options.mask
      }));
    }
    if (this.options.renderType === RenderType.image) {
      const composePass = new ComposePass("RasterComposePass", this.renderer, {
        bandType,
        source: this.source,
        renderFrom: this.options.renderFrom ?? RenderFrom.r,
        maskPass: __privateGet(this, _maskPass),
        stencilConfigForOverlap: this.stencilConfigForOverlap.bind(this)
      });
      const rasterPass = new RasterPass("RasterPass", this.renderer, {
        bandType,
        source: this.source,
        texture: composePass.textures.current,
        textureNext: composePass.textures.next
      });
      (_a2 = this.renderPipeline) == null ? void 0 : _a2.addPass(composePass);
      if (this.options.picking) {
        const pickerPass = new PickerPass("PickerPass", this.renderer, {
          source: this.source,
          texture: composePass.textures.current,
          textureNext: composePass.textures.next,
          useFloatTexture: false
        });
        (_b = this.renderPipeline) == null ? void 0 : _b.addPass(pickerPass);
      }
      (_c = this.renderPipeline) == null ? void 0 : _c.addPass(rasterPass);
    } else if (this.options.renderType === RenderType.colorize) {
      const composePass = new ComposePass$1("ColorizeComposePass", this.renderer, {
        bandType,
        source: this.source,
        renderFrom: this.options.renderFrom ?? RenderFrom.r,
        maskPass: __privateGet(this, _maskPass),
        stencilConfigForOverlap: this.stencilConfigForOverlap.bind(this),
        isRasterize: () => __privateGet(this, _isRasterize)
      });
      const colorizePass = new ColorizePass("ColorizePass", this.renderer, {
        bandType,
        source: this.source,
        texture: composePass.textures.current,
        textureNext: composePass.textures.next
      });
      (_d = this.renderPipeline) == null ? void 0 : _d.addPass(composePass);
      if (this.options.picking) {
        const pickerPass = new PickerPass("PickerPass", this.renderer, {
          source: this.source,
          texture: composePass.textures.current,
          textureNext: composePass.textures.next,
          useFloatTexture: true
        });
        (_e = this.renderPipeline) == null ? void 0 : _e.addPass(pickerPass);
      }
      (_f = this.renderPipeline) == null ? void 0 : _f.addPass(colorizePass);
    } else if (this.options.renderType === RenderType.particles) {
      const composePass = new ParticlesComposePass("ParticlesComposePass", this.renderer, {
        id: index.uid("ParticlesComposePass"),
        bandType,
        source: this.source,
        renderFrom: this.options.renderFrom ?? RenderFrom.r,
        stencilConfigForOverlap: this.stencilConfigForOverlap.bind(this),
        getTileProjSize: this.options.getTileProjSize
      });
      (_g = this.renderPipeline) == null ? void 0 : _g.addPass(composePass);
      const updatePass = new UpdatePass("UpdatePass", this.renderer, {
        bandType,
        source: this.source,
        texture: composePass.textures.current,
        textureNext: composePass.textures.next,
        getParticleNumber: () => __privateGet(this, _numParticles),
        glScale: (_i = (_h = this.options).glScale) == null ? void 0 : _i.call(_h)
      });
      (_j = this.renderPipeline) == null ? void 0 : _j.addPass(updatePass);
      const particlesPass = new Particles("ParticlesPass", this.renderer, {
        bandType,
        source: this.source,
        texture: composePass.textures.current,
        textureNext: composePass.textures.next,
        getParticles: () => updatePass.textures,
        getParticleNumber: () => __privateGet(this, _numParticles),
        maskPass: __privateGet(this, _maskPass)
      });
      const particlesTexturePass = new ScreenPass("ParticlesTexturePass", this.renderer, {
        bandType,
        source: this.source,
        prerender: true,
        enableBlend: false,
        particlesPass
      });
      (_k = this.renderPipeline) == null ? void 0 : _k.addPass(particlesTexturePass);
      (_l = this.renderPipeline) == null ? void 0 : _l.addPass(particlesPass);
      const screenPass = new ScreenPass("ScreenPass", this.renderer, {
        bandType,
        source: this.source,
        prerender: false,
        enableBlend: true,
        particlesPass
      });
      (_m = this.renderPipeline) == null ? void 0 : _m.addPass(screenPass);
      this.raf = new Raf(
        () => {
          if (this.options.triggerRepaint) {
            this.options.triggerRepaint();
          }
        },
        { autoStart: true }
      );
    } else if (this.options.renderType === RenderType.arrow) {
      const composePass = new ArrowComposePass("ArrowComposePass", this.renderer, {
        id: index.uid("ArrowComposePass"),
        bandType,
        source: this.source,
        renderFrom: this.options.renderFrom ?? RenderFrom.r,
        stencilConfigForOverlap: this.stencilConfigForOverlap.bind(this),
        getTileProjSize: this.options.getTileProjSize
      });
      const arrowPass = new ArrowPass("ArrowPass", this.renderer, {
        bandType,
        source: this.source,
        texture: composePass.textures.current,
        textureNext: composePass.textures.next,
        getPixelsToUnits: this.options.getPixelsToUnits,
        getGridTiles: this.options.getGridTiles,
        maskPass: __privateGet(this, _maskPass)
      });
      (_n = this.renderPipeline) == null ? void 0 : _n.addPass(composePass);
      (_o = this.renderPipeline) == null ? void 0 : _o.addPass(arrowPass);
    }
  }
  updateOptions(options) {
    var _a2, _b;
    this.options = {
      ...this.options,
      ...options,
      styleSpec: {
        ...this.options.styleSpec,
        ...options == null ? void 0 : options.styleSpec
      }
    };
    this.buildColorRamp();
    this.parseStyleSpec(true);
    (_b = (_a2 = this.options) == null ? void 0 : _a2.triggerRepaint) == null ? void 0 : _b.call(_a2);
  }
  resize(width, height) {
    if (this.renderPipeline) {
      this.renderPipeline.resize(width, height);
    }
  }
  /**
   * 设置填色色阶
   */
  setFillColor() {
    this.buildColorRamp();
  }
  /**
   * 设置图层透明度
   * @param opacity
   */
  setOpacity(opacity) {
    __privateSet(this, _opacity, opacity);
  }
  /**
   * 设置粒子图层的粒子数量
   * @param numParticles
   */
  setNumParticles(numParticles) {
    __privateSet(this, _numParticles, numParticles);
  }
  /**
   * 设置粒子图层的粒子数量
   * @param speedFactor
   */
  setSpeedFactor(speedFactor) {
    __privateSet(this, _speedFactor, speedFactor);
  }
  /**
   * 设置粒子图层的粒子数量
   * @param fadeOpacity
   */
  setFadeOpacity(fadeOpacity) {
    __privateSet(this, _fadeOpacity, fadeOpacity);
  }
  /**
   * 设置粒子图层的粒子数量
   * @param dropRate
   */
  setDropRate(dropRate) {
    __privateSet(this, _dropRate, dropRate);
  }
  /**
   * 设置粒子图层的粒子数量
   * @param dropRateBump
   */
  setDropRateBump(dropRateBump) {
    __privateSet(this, _dropRateBump, dropRateBump);
  }
  /**
   * 设置 symbol 的间距
   * @param space
   */
  setSymbolSpace(space) {
    __privateSet(this, _space, space);
  }
  /**
   * 设置 symbol 的大小
   * @param size
   */
  setSymbolSize(size) {
    __privateSet(this, _size, size);
  }
  /**
   * 解析样式配置
   * @param clear
   */
  parseStyleSpec(clear) {
    var _a2;
    if (isFunction(this.options.getZoom)) {
      const zoom = this.options.getZoom();
      this.setOpacity(createZoom(this.uid, zoom, "opacity", this.options.styleSpec, clear));
      if (this.options.renderType === RenderType.particles) {
        this.setNumParticles(createZoom(this.uid, zoom, "numParticles", this.options.styleSpec, clear));
        this.setFadeOpacity(createZoom(this.uid, zoom, "fadeOpacity", this.options.styleSpec, clear));
        this.setSpeedFactor(createZoom(this.uid, zoom, "speedFactor", this.options.styleSpec, clear));
        this.setDropRate(createZoom(this.uid, zoom, "dropRate", this.options.styleSpec, clear));
        this.setDropRateBump(createZoom(this.uid, zoom, "dropRateBump", this.options.styleSpec, clear));
      }
      if (this.options.renderType === RenderType.arrow) {
        this.setSymbolSize((_a2 = this.options.styleSpec) == null ? void 0 : _a2.size);
        this.setSymbolSpace(createZoom(this.uid, zoom, "space", this.options.styleSpec, clear));
      }
    }
  }
  /**
   * 处理地图缩放事件
   */
  handleZoom() {
    this.parseStyleSpec(false);
  }
  /**
   * 构建渲染所需色带
   */
  buildColorRamp() {
    var _a2, _b, _c;
    if (!((_a2 = this.options.styleSpec) == null ? void 0 : _a2["fill-color"]))
      return;
    const { data, colorRange } = createLinearGradient([], (_b = this.options.styleSpec) == null ? void 0 : _b["fill-color"]);
    __privateSet(this, _isRasterize, isRasterize((_c = this.options.styleSpec) == null ? void 0 : _c["fill-color"]));
    if (colorRange) {
      __privateSet(this, _colorRange, new Vector2(...colorRange));
    }
    if (data) {
      __privateSet(this, _colorRampTexture, new DataTexture(this.renderer, {
        data,
        name: "colorRampTexture",
        magFilter: this.renderer.gl.NEAREST,
        minFilter: this.renderer.gl.NEAREST,
        width: 255,
        height: 1
      }));
    }
  }
  clearStencil() {
    __privateSet(this, _nextStencilID, 1);
  }
  stencilConfigForOverlap(tiles) {
    const coords = tiles.sort((a, b) => b.overscaledZ - a.overscaledZ);
    const minTileZ = coords[coords.length - 1].overscaledZ;
    const stencilValues = coords[0].overscaledZ - minTileZ + 1;
    if (stencilValues > 1) {
      if (__privateGet(this, _nextStencilID) + stencilValues > 256) {
        this.clearStencil();
      }
      const zToStencilMode = {};
      for (let i = 0; i < stencilValues; i++) {
        zToStencilMode[i + minTileZ] = {
          stencil: true,
          mask: 255,
          func: {
            cmp: this.renderer.gl.GEQUAL,
            ref: i + __privateGet(this, _nextStencilID),
            mask: 255
          },
          op: {
            fail: this.renderer.gl.KEEP,
            zfail: this.renderer.gl.KEEP,
            zpass: this.renderer.gl.REPLACE
          }
        };
      }
      __privateSet(this, _nextStencilID, __privateGet(this, _nextStencilID) + stencilValues);
      return [zToStencilMode, coords];
    }
    return [
      {
        [minTileZ]: {
          // 禁止写入
          stencil: false,
          mask: 0,
          func: {
            cmp: this.renderer.gl.ALWAYS,
            ref: 0,
            mask: 0
          },
          op: {
            fail: this.renderer.gl.KEEP,
            zfail: this.renderer.gl.KEEP,
            zpass: this.renderer.gl.KEEP
          }
        }
      },
      coords
    ];
  }
  moveStart() {
    if (this.renderPipeline && this.options.renderType === RenderType.particles) {
      const particlesPass = this.renderPipeline.getPass("ParticlesPass");
      if (particlesPass) {
        particlesPass.resetParticles();
      }
      this.renderPipeline.passes.forEach((pass) => {
        if (pass.id === "ParticlesTexturePass" || pass.id === "ScreenPass") {
          pass.enabled = false;
        }
        if (pass.id === "ParticlesPass") {
          pass.prerender = false;
        }
      });
    }
  }
  moveEnd() {
    if (this.renderPipeline && this.options.renderType === RenderType.particles) {
      const updatePass = this.renderPipeline.getPass("UpdatePass");
      if (updatePass) {
        updatePass.setInitialize(true);
      }
      this.renderPipeline.passes.forEach((pass) => {
        if (pass.id === "ParticlesTexturePass" || pass.id === "ScreenPass") {
          pass.enabled = true;
        }
        if (pass.id === "ParticlesPass") {
          pass.prerender = true;
        }
      });
    }
  }
  /**
   * 更新视野内的瓦片
   */
  update() {
    var _a2;
    const tiles = this.options.getViewTiles(this.source, this.options.renderType);
    if (Array.isArray(this.source.sourceCache)) {
      this.source.sourceCache.forEach((s) => {
        s == null ? void 0 : s.update(tiles);
      });
    } else {
      (_a2 = this.source.sourceCache) == null ? void 0 : _a2.update(tiles);
    }
  }
  onTileLoaded() {
    if (this.options.triggerRepaint && isFunction(this.options.triggerRepaint)) {
      this.options.triggerRepaint();
    }
  }
  setMask(mask) {
    var _a2, _b, _c, _d, _e, _f;
    this.options.mask = mask;
    if (this.options.mask) {
      if (!__privateGet(this, _maskPass)) {
        __privateSet(this, _maskPass, new MaskPass("MaskPass", this.renderer, {
          mask: this.options.mask
        }));
        const raster = (_a2 = this.renderPipeline) == null ? void 0 : _a2.getPass("RasterComposePass");
        if (raster) {
          raster.setMaskPass(__privateGet(this, _maskPass));
        }
        const colorize = (_b = this.renderPipeline) == null ? void 0 : _b.getPass("ColorizeComposePass");
        if (colorize) {
          colorize.setMaskPass(__privateGet(this, _maskPass));
        }
        const particles = (_c = this.renderPipeline) == null ? void 0 : _c.getPass("ParticlesPass");
        if (particles) {
          particles.setMaskPass(__privateGet(this, _maskPass));
        }
        const arrow = (_d = this.renderPipeline) == null ? void 0 : _d.getPass("ArrowPass");
        if (arrow) {
          arrow.setMaskPass(__privateGet(this, _maskPass));
        }
      }
      __privateGet(this, _maskPass).updateGeometry();
      (_f = (_e = this.options) == null ? void 0 : _e.triggerRepaint) == null ? void 0 : _f.call(_e);
    }
  }
  async picker(pixel = [0, 0]) {
    if (!this.renderPipeline)
      return null;
    const pickerPass = this.renderPipeline.getPass("PickerPass");
    if (!pickerPass)
      return null;
    return pickerPass.render(void 0, void 0, pixel);
  }
  prerender(cameras, renderTarget) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    if (this.renderPipeline) {
      this.renderPipeline.prerender(
        {
          scene: this.scene,
          cameras,
          ...renderTarget ? { target: renderTarget } : {}
        },
        {
          zoom: ((_b = (_a2 = this.options) == null ? void 0 : _a2.getZoom) == null ? void 0 : _b.call(_a2)) ?? 0,
          extent: (_d = (_c = this.options) == null ? void 0 : _c.getExtent) == null ? void 0 : _d.call(_c),
          opacity: __privateGet(this, _opacity),
          fadeOpacity: __privateGet(this, _fadeOpacity),
          numParticles: __privateGet(this, _numParticles),
          colorRange: __privateGet(this, _colorRange),
          colorRampTexture: __privateGet(this, _colorRampTexture),
          sharedState: this.sharedState,
          u_drop_rate: __privateGet(this, _dropRate),
          u_drop_rate_bump: __privateGet(this, _dropRateBump),
          u_speed_factor: __privateGet(this, _speedFactor),
          u_flip_y: this.options.flipY,
          u_gl_scale: (_f = (_e = this.options).glScale) == null ? void 0 : _f.call(_e),
          u_zoomScale: (_h = (_g = this.options).zoomScale) == null ? void 0 : _h.call(_g),
          symbolSize: __privateGet(this, _size),
          symbolSpace: __privateGet(this, _space),
          pixelsToProjUnit: this.options.getPixelsToProjUnit()
        }
      );
    }
  }
  render(cameras, renderTarget) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    if (this.renderPipeline) {
      const state = {
        zoom: ((_b = (_a2 = this.options) == null ? void 0 : _a2.getZoom) == null ? void 0 : _b.call(_a2)) ?? 0,
        extent: (_d = (_c = this.options) == null ? void 0 : _c.getExtent) == null ? void 0 : _d.call(_c),
        opacity: __privateGet(this, _opacity),
        fadeOpacity: __privateGet(this, _fadeOpacity),
        numParticles: __privateGet(this, _numParticles),
        colorRange: __privateGet(this, _colorRange),
        colorRampTexture: __privateGet(this, _colorRampTexture),
        displayRange: this.options.displayRange,
        useDisplayRange: Boolean(this.options.displayRange),
        sharedState: this.sharedState,
        u_drop_rate: __privateGet(this, _dropRate),
        u_drop_rate_bump: __privateGet(this, _dropRateBump),
        u_speed_factor: __privateGet(this, _speedFactor),
        u_flip_y: this.options.flipY,
        u_gl_scale: (_f = (_e = this.options).glScale) == null ? void 0 : _f.call(_e),
        u_zoomScale: (_h = (_g = this.options).zoomScale) == null ? void 0 : _h.call(_g),
        symbolSize: __privateGet(this, _size),
        symbolSpace: __privateGet(this, _space),
        pixelsToProjUnit: this.options.getPixelsToProjUnit()
      };
      this.renderPipeline.render(
        {
          scene: this.scene,
          cameras,
          ...renderTarget ? { target: renderTarget } : {}
        },
        state
      );
    }
  }
  /**
   * 销毁此 Renderer
   */
  destroy() {
    if (this.raf) {
      this.raf.stop();
    }
    if (this.renderPipeline) {
      this.renderPipeline.destroy();
      this.renderPipeline = null;
    }
    if (this.source) {
      if (Array.isArray(this.source.sourceCache)) {
        this.source.sourceCache.forEach((s) => {
          s.off("update", this.update);
          s.off("tileLoaded", this.onTileLoaded);
        });
      } else {
        this.source.sourceCache.off("update", this.update);
        this.source.sourceCache.off("tileLoaded", this.onTileLoaded);
      }
      this.source.destroy();
    }
  }
};
_opacity = new WeakMap();
_numParticles = new WeakMap();
_speedFactor = new WeakMap();
_fadeOpacity = new WeakMap();
_dropRate = new WeakMap();
_dropRateBump = new WeakMap();
_space = new WeakMap();
_size = new WeakMap();
_colorRange = new WeakMap();
_colorRampTexture = new WeakMap();
_nextStencilID = new WeakMap();
_maskPass = new WeakMap();
_isRasterize = new WeakMap();
var TileID = class _TileID {
  /**
   * @param overscaledZ 扩大的 z 值
   * @param wrap 所处世界
   * @param z 层级
   * @param x 列
   * @param y 行
   * @param options 瓦片其他配置
   */
  constructor(overscaledZ, wrap = 0, z, x, y, options = {}) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.wrap = wrap;
    this.tileKey = `${z}_${x}_${y}-${wrap}`;
    this.unWrappedTileKey = `${z}_${x}_${y}`;
    const max = Math.pow(2, this.z);
    this.wrapedX = max * wrap + this.x;
    this.wrapedY = this.y;
    this.overscaledZ = overscaledZ;
    this.options = options;
    this.getTileBounds();
  }
  /**
   * 获取瓦片范围
   */
  getTileBounds(tileID = this) {
    if (isFunction(this.options.getTileBounds)) {
      this.tileBounds = this.options.getTileBounds(tileID);
    } else {
      console.error("[TileID]: projection function must be provided");
    }
    return this.tileBounds;
  }
  /**
   * 获取瓦片投影后的范围
   */
  getTileProjBounds(tileID = this, force) {
    var _a2, _b;
    if (!this.projTileBounds || force) {
      this.projTileBounds = (_b = (_a2 = this.options).getTileProjBounds) == null ? void 0 : _b.call(_a2, tileID);
    }
    return this.projTileBounds;
  }
  overscaleFactor() {
    return Math.pow(2, this.overscaledZ - this.z);
  }
  /**
   * 缩放到目标层级
   * @param targetZ
   */
  scaledTo(targetZ) {
    const zDifference = this.z - targetZ;
    if (targetZ > this.z) {
      return new _TileID(targetZ, this.wrap, this.z, this.x, this.y, this.options);
    } else {
      return new _TileID(targetZ, this.wrap, targetZ, this.x >> zDifference, this.y >> zDifference, this.options);
    }
  }
  /**
   * 获取父级瓦片
   */
  parent() {
    if (this.z > 0)
      return new _TileID(this.z - 1, this.wrap, this.z - 1, this.x >> 1, this.y >> 1, this.options);
    else
      return new _TileID(this.z, this.wrap, this.z, this.x, this.y, this.options);
  }
  /**
   * 查找当前瓦片的子瓦片
   * @param sourceMaxZoom
   */
  children(sourceMaxZoom) {
    if (this.overscaledZ >= sourceMaxZoom) {
      return [new _TileID(this.overscaledZ + 1, this.wrap, this.z, this.x, this.y, this.options)];
    }
    const z = this.z + 1;
    const x = this.x * 2;
    const y = this.y * 2;
    return [
      new _TileID(z, this.wrap, z, x, y, this.options),
      new _TileID(z, this.wrap, z, x + 1, y, this.options),
      new _TileID(z, this.wrap, z, x, y + 1, this.options),
      new _TileID(z, this.wrap, z, x + 1, y + 1, this.options)
    ];
  }
  /**
   * 查找兄弟瓦片
   */
  siblings() {
    return this.z === 0 ? [] : this.parent().children(this.overscaledZ).filter((t) => !this.isEqual(t));
  }
  /**
   * 查找相临瓦片
   * @param hor 横向偏移
   * @param ver 纵向偏移
   */
  neighbor(hor, ver = 0) {
    if (this.z === 0) {
      return new _TileID(this.overscaledZ, this.wrap + hor, this.z, this.x, this.y, this.options);
    }
    const max = Math.pow(2, this.z);
    const w = this.x + hor;
    const dw = Math.floor(w / max);
    const wrap = this.wrap + dw;
    return new _TileID(
      this.overscaledZ,
      wrap,
      this.z,
      (this.x + hor - max * dw) % max,
      (this.y + ver + max) % max,
      this.options
    );
  }
  /**
   * 判断瓦片是否相同
   * 一般我们认为只要 xyz 和所处世界 wrap 相同就确认相同（即 tileKey 相同）
   * @param tile
   */
  isEqual(tile) {
    return tile.tileKey === this.tileKey;
  }
  /**
   * 判断是否是根节点
   * @returns {boolean}
   */
  isRoot() {
    return this.z === 0;
  }
};
var TileMesh = class {
  constructor(id, renderer, program, geometry) {
    this.id = id;
    this.program = program;
    this.mesh = new Mesh(renderer, {
      program,
      geometry
    });
    this.planeMesh = new Mesh(renderer, {
      program,
      geometry: new Geometry(renderer, {
        position: {
          size: 2,
          data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
        },
        uv: {
          size: 2,
          data: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1])
        },
        index: {
          size: 1,
          data: new Uint16Array([0, 1, 2, 2, 1, 3])
        }
      })
    });
  }
  setCenter(center) {
    this.mesh.position.set(center[0], center[1], center[2] || 0);
  }
  getMesh() {
    return this.mesh;
  }
  destroy() {
    this.mesh.destroy();
    this.planeMesh.destroy();
  }
};
var _textures;
var Tile = class {
  /**
   * @param tileID
   * @param options
   */
  constructor(tileID, options = {}) {
    __privateAdd(this, _textures);
    this.errorCount = 0;
    this.maxErrorCount = 3;
    this.uses = 0;
    this.tileMeshs = /* @__PURE__ */ new Map();
    this.geometries = /* @__PURE__ */ new Map();
    __privateSet(this, _textures, /* @__PURE__ */ new Map());
    this.tileID = tileID;
    this.tileSize = options.tileSize;
    this.request = /* @__PURE__ */ new Map();
    this.state = TileState.loading;
  }
  /**
   * 瓦片是否已经加载到数据
   */
  hasData() {
    return this.state === TileState.loaded || this.state === TileState.reloading;
  }
  /**
   * 瓦片是否已经请求过
   */
  wasRequested() {
    return this.state === TileState.errored || this.state === TileState.loaded;
  }
  /**
   * 瓦片是否加载完成
   */
  isLoaded() {
    return this.state === TileState.loaded || this.state === TileState.reloading || this.state === TileState.errored;
  }
  getMesh(passId) {
    return this.tileMeshs.get(passId);
  }
  get textures() {
    return __privateGet(this, _textures);
  }
  get tileCenter() {
    return [(this.tileBounds.left + this.tileBounds.right) / 2, (this.tileBounds.top + this.tileBounds.bottom) / 2, 0];
  }
  /**
   * 更新瓦片顶点信息
   * @param passId
   * @param bbox
   * @param renderer
   * @param force
   */
  updateGeometry(passId, bbox, renderer, force) {
    this.tileBounds = bbox;
    if (!this.geometries.get(passId) || force) {
      const position = [
        this.tileBounds.left,
        this.tileBounds.top,
        0,
        this.tileBounds.right,
        this.tileBounds.top,
        0,
        this.tileBounds.left,
        this.tileBounds.bottom,
        0,
        this.tileBounds.right,
        this.tileBounds.bottom,
        0
      ];
      let i = 0;
      const len = position.length;
      for (; i < len; i += 3) {
        position[i] = position[i] - this.tileCenter[0];
        position[i + 1] = position[i + 1] - this.tileCenter[1];
        position[i + 2] = position[i + 2] - this.tileCenter[2];
      }
      this.geometries.set(
        passId,
        new Geometry(renderer, {
          position: {
            size: 3,
            data: new Float32Array(position)
          },
          normal: {
            size: 3,
            data: new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1])
          },
          uv: {
            size: 2,
            data: new Float32Array([0, 1, 1, 1, 0, 0, 1, 0])
          },
          index: {
            data: new Uint16Array([0, 2, 1, 2, 3, 1])
          }
        })
      );
    }
    return this.geometries.get(passId);
  }
  /**
   * 创建 `TileMesh`
   * @param passId 在多个 render pass 共享 tile 时我们可能需要针对多个 pass 创建渲染资源
   * 在 mapbox 这种共享 gl 上下文的一般我们不需要重建，但是对于 maptalks 这种每个图层一个 gl
   * 上下文的我们需要针对每个 gl上下文绑定资源
   * @param bbox
   * @param renderer
   * @param program
   * @param force
   */
  createMesh(passId, bbox, renderer, program, force) {
    const geometry = this.updateGeometry(passId, bbox, renderer, force);
    if (!this.tileMeshs.get(passId) || force) {
      this.uses++;
      const uid = passId + "_" + this.tileID.tileKey;
      const tileMesh = new TileMesh(uid, renderer, program, geometry);
      tileMesh.setCenter(this.tileCenter);
      this.tileMeshs.set(passId, tileMesh);
    }
    return this.tileMeshs.get(passId);
  }
  /**
   * 创建纹理
   * @param renderer
   * @param index
   * @param image
   * @param parseOptions
   * @param userData
   */
  setTextures(renderer, index2, image, parseOptions, userData) {
    const texture = __privateGet(this, _textures).get(index2);
    const iib = isImageBitmap(image) || image instanceof Image;
    let dataRange;
    if (userData == null ? void 0 : userData.dataRange) {
      dataRange = userData == null ? void 0 : userData.dataRange;
    } else if (image.withExif) {
      dataRange = parseRange(image.exif);
    }
    if (texture) {
      if (texture.userData) {
        texture.userData.dataRange = dataRange;
      }
      texture.setData(iib ? image : image.data);
    } else {
      __privateGet(this, _textures).set(
        index2,
        new Texture(renderer, {
          userData: dataRange ? {
            dataRange
          } : void 0,
          image: iib ? image : image.data,
          width: image.width,
          height: image.height,
          minFilter: renderer.gl.LINEAR,
          magFilter: renderer.gl.LINEAR,
          wrapS: renderer.gl.CLAMP_TO_EDGE,
          wrapT: renderer.gl.CLAMP_TO_EDGE,
          flipY: false,
          // 注意，对 ImageBitmap 无效
          premultiplyAlpha: false,
          // 禁用 `Alpha` 预乘
          type: parseOptions.renderFrom === RenderFrom.float ? renderer.gl.FLOAT : renderer.gl.UNSIGNED_BYTE,
          format: parseOptions.renderFrom === RenderFrom.float ? renderer.isWebGL2 ? renderer.gl.RED : renderer.gl.LUMINANCE : renderer.gl.RGBA,
          internalFormat: parseOptions.renderFrom === RenderFrom.float ? renderer.isWebGL2 ? renderer.gl.R32F : renderer.gl.LUMINANCE : renderer.gl.RGBA
        })
      );
    }
  }
  /**
   * 获取瓦片世界坐标系下的范围
   */
  getBounds() {
    return this.tileBounds;
  }
  copy(tile) {
    __privateSet(this, _textures, tile.textures);
    this.actor = tile.actor;
    this.state = tile.state !== TileState.errored ? TileState.loaded : TileState.errored;
    this.request = tile.request;
    this.reloadCallback = tile.reloadCallback;
    return this;
  }
  /**
   * 释放瓦片资源
   */
  destroy() {
    for (const [, value] of __privateGet(this, _textures)) {
      if (value) {
        value == null ? void 0 : value.destroy();
      }
    }
    __privateGet(this, _textures).clear();
    for (const [, value] of this.geometries) {
      if (value) {
        value == null ? void 0 : value.destroy();
      }
    }
    for (const [, value] of this.tileMeshs) {
      if (value) {
        value == null ? void 0 : value.destroy();
      }
    }
    this.tileMeshs.clear();
  }
};
_textures = new WeakMap();
var DoubleQueueNode = class {
  constructor(key, val) {
    this.key = key;
    this.val = val;
  }
};
var LRUCache = class {
  constructor(max, onRemove) {
    this.max = max;
    this.onRemove = onRemove;
    this.reset();
  }
  /**
   * 当前容量
   */
  get size() {
    return this.map.size;
  }
  reset() {
    if (this.map) {
      const iterator = this.map.entries();
      for (let i = 0; i < this.map.size; i++) {
        const [, value] = iterator.next().value;
        this.onRemove(value.val);
      }
    }
    this.map = /* @__PURE__ */ new Map();
    this.head = new DoubleQueueNode(0, 0);
    this.tail = new DoubleQueueNode(0, 0);
    this.head.next = this.tail;
    return this;
  }
  clear() {
    this.reset();
    this.onRemove = () => void 0;
  }
  has(key) {
    const node = this.map.get(key);
    return node !== void 0;
  }
  get(key) {
    const node = this.map.get(key);
    if (node === void 0) {
      return null;
    }
    this.moveToHead(node);
    return node.val;
  }
  getAndRemove(key) {
    if (!this.has(key)) {
      return null;
    }
    return this.remove(key);
  }
  add(key, value) {
    let oldValue;
    const node = this.map.get(key);
    if (node === void 0) {
      this.eliminate();
      const newNode = new DoubleQueueNode(key, value);
      const temp = this.head.next;
      this.head.next = newNode;
      newNode.next = temp;
      newNode.pre = this.head;
      temp.pre = newNode;
      this.map.set(key, newNode);
      oldValue = null;
    } else {
      this.moveToHead(node);
      oldValue = node.val;
      node.val = value;
    }
    return oldValue;
  }
  remove(key) {
    const deletedNode = this.map.get(key);
    if (deletedNode === void 0) {
      return null;
    }
    deletedNode.pre.next = deletedNode.next;
    deletedNode.next.pre = deletedNode.pre;
    this.onRemove(deletedNode.val);
    this.map.delete(key);
    return deletedNode.val;
  }
  /**
   * 设置最大缓存大小
   * @param max
   */
  setMaxSize(max) {
    this.max = max;
    while (this.size > this.max) {
      this.eliminate();
    }
  }
  // 将节点插入至头部节点
  moveToHead(node) {
    node.pre.next = node.next;
    node.next.pre = node.pre;
    const temp = this.head.next;
    this.head.next = node;
    node.next = temp;
    node.pre = this.head;
    temp.pre = node;
  }
  /**
   * 如果超出缓存限制，那么移除未使用的数据
   * @private
   */
  eliminate() {
    if (this.size < this.max) {
      return;
    }
    const last = this.tail.pre;
    this.onRemove(last.val);
    this.map.delete(last.key);
    last.pre.next = this.tail;
    this.tail.pre = last.pre;
  }
};
function compareTileId(a, b) {
  const aWrap = Math.abs(a.wrap * 2) - +(a.wrap < 0);
  const bWrap = Math.abs(b.wrap * 2) - +(b.wrap < 0);
  return a.overscaledZ - b.overscaledZ || bWrap - aWrap || b.y - a.y || b.x - a.x;
}
var _cache;
var _SourceCache = class _SourceCache extends EventEmitter {
  constructor(id, source) {
    super();
    __privateAdd(this, _cache);
    this.id = id;
    this.source = source;
    this.cacheTiles = {};
    this.coveredTiles = {};
    this.loadedParentTiles = {};
    __privateSet(this, _cache, new LRUCache(0, this.unloadTile.bind(this)));
  }
  /**
   * 判断当前 source 瓦片是否全部加载完毕（成功加载或者加载错误）
   */
  loaded() {
    if (!this.source.loaded()) {
      return false;
    }
    for (const t in this.cacheTiles) {
      const tile = this.cacheTiles[t];
      if (tile.state !== TileState.loaded && tile.state !== TileState.errored)
        return false;
    }
    return true;
  }
  /**
   * 调用 `Source` 的瓦片加载方法
   * 具体由各个`Source` 实现
   * @param tile
   * @param callback
   */
  loadTile(tile, callback) {
    return this.source.loadTile(tile, callback);
  }
  /**
   * 移除已加载的瓦片
   * @param tile
   */
  unloadTile(tile) {
    if (this.source.unloadTile) {
      return this.source.unloadTile(tile, () => void 0);
    }
  }
  /**
   * 取消正在加载中的瓦片
   * @param tile
   */
  abortTile(tile) {
    if (this.source.abortTile) {
      return this.source.abortTile(tile, () => void 0);
    }
  }
  /**
   * 获取所有的可渲染的瓦片 id 并且排序（从 0 世界向两边排序）
   */
  getRenderableIds() {
    const renderables = [];
    for (const id in this.cacheTiles) {
      if (this._isIdRenderable(id))
        renderables.push(this.cacheTiles[id]);
    }
    return renderables.map((tile) => tile.tileID).sort(compareTileId).map((tile) => tile.tileKey);
  }
  _isIdRenderable(id) {
    return this.cacheTiles[id] && this.cacheTiles[id].hasData() && !this.coveredTiles[id];
  }
  /**
   * 获取已经加载的瓦片
   */
  getVisibleCoordinates() {
    return this.getRenderableIds().map((id) => this.cacheTiles[id].tileID);
  }
  /**
   * 瓦片加载完成回调
   * @param tile
   * @param id
   * @param previousState
   * @param err
   * @param disableUpdate
   */
  tileLoaded(tile, id, previousState, err, disableUpdate = false) {
    if (err) {
      tile.state = TileState.errored;
      if (err.status !== 404) ;
      else {
        this.emit("update");
      }
      return;
    }
    tile.timeAdded = Date.now();
    if (!disableUpdate) {
      this.emit("update");
    }
    this.emit("tileLoaded");
    if (this.loaded()) {
      this.emit("tilesLoadEnd");
    }
  }
  _addTile(tileID) {
    let tile = this.cacheTiles[tileID.tileKey];
    if (tile)
      return tile;
    tile = __privateGet(this, _cache).getAndRemove(tileID.tileKey);
    if (tile) {
      tile.tileID = tileID;
    }
    const cached = Boolean(tile);
    if (!cached) {
      tile = new Tile(tileID, {
        tileSize: this.source.tileSize * tileID.overscaleFactor()
      });
      this.loadTile(tile, this.tileLoaded.bind(this, tile, tileID.tileKey, tile.state));
    }
    if (!tile)
      return null;
    tile.uses++;
    this.cacheTiles[tileID.tileKey] = tile;
    return tile;
  }
  /**
   * 根据 `tileKey` 移除瓦片
   * @param id
   */
  _removeTile(id) {
    const tile = this.cacheTiles[id];
    if (!tile)
      return;
    tile.uses--;
    delete this.cacheTiles[id];
    if (tile.uses > 0)
      return;
    if (tile.hasData() && tile.state !== TileState.reloading) {
      __privateGet(this, _cache).add(tile.tileID.tileKey, tile);
    } else {
      tile.aborted = true;
      this.abortTile(tile);
      this.unloadTile(tile);
    }
  }
  /**
   * 根据 `TileID` 获取瓦片
   * @param tileID
   */
  getTile(tileID) {
    return this.cacheTiles[tileID == null ? void 0 : tileID.tileKey];
  }
  /**
   * 该策略会在内存中保留当前层级的瓦片的所有子瓦片（children），直到一直保留到最大覆盖缩放级别（maxCoveringZoom）为止。
   * 简单来说，当当前地图缩放等级超过了当前图层的最大缩放级别时，Mapbox GL JS 会自动加载当前瓦片的所有子瓦片来填充当前视图的空白部分。而 retain any loaded children of ideal tiles up to maxCoveringZoom 这个选项会保留这些子瓦片的缓存，以便在缩放到更高层级时直接使用，而不需要重新加载。
   * 举个例子，假设当前地图缩放等级是 10，最大缩放级别是 14，而 maxCoveringZoom 设置为 12。地图将会加载当前缩放级别为 10 的瓦片，并将其所有子瓦片缓存到内存中，包括缩放级别为 11、12、13 的所有瓦片。但是，因为 maxCoveringZoom 设置为 12，所以缩放到 13 级时，只会使用缓存中缩放级别为 11、12 的子瓦片。当缩放到 14 级时，则不再使用缓存，而是重新加载新的瓦片数据。
   * 需要注意的是，这个选项可能会占用大量内存，因此在使用时需要根据实际情况进行设置。如果需要优化内存使用，可以将 maxCoveringZoom 设置为一个较小的值，以减少缓存的瓦片数量。
   * @param idealTiles
   * @param zoom
   * @param maxCoveringZoom
   * @param retain
   */
  retainLoadedChildren(idealTiles, zoom, maxCoveringZoom, retain) {
    for (const id in this.cacheTiles) {
      let tile = this.cacheTiles[id];
      if (retain[id] || !tile.hasData() || tile.tileID.overscaledZ <= zoom || tile.tileID.overscaledZ > maxCoveringZoom)
        continue;
      let topmostLoadedID = tile.tileID;
      while (tile && tile.tileID.overscaledZ > zoom + 1) {
        const parentID = tile.tileID.scaledTo(tile.tileID.overscaledZ - 1);
        tile = this.cacheTiles[parentID.tileKey];
        if (tile && tile.hasData()) {
          topmostLoadedID = parentID;
        }
      }
      let tileID = topmostLoadedID;
      while (tileID.overscaledZ > zoom) {
        tileID = tileID.scaledTo(tileID.overscaledZ - 1);
        if (idealTiles[tileID.tileKey]) {
          retain[topmostLoadedID.tileKey] = topmostLoadedID;
          break;
        }
      }
    }
  }
  updateLoadedParentTileCache() {
    this.loadedParentTiles = {};
    for (const tileKey in this.cacheTiles) {
      const path = [];
      let parentTile;
      let currentId = this.cacheTiles[tileKey].tileID;
      while (currentId.overscaledZ > 0) {
        if (currentId.tileKey in this.loadedParentTiles) {
          parentTile = this.loadedParentTiles[currentId.tileKey];
          break;
        }
        path.push(currentId.tileKey);
        const parentId = currentId.scaledTo(currentId.overscaledZ - 1);
        parentTile = this.getLoadedTile(parentId);
        if (parentTile) {
          break;
        }
        currentId = parentId;
      }
      for (const key of path) {
        this.loadedParentTiles[key] = parentTile;
      }
    }
  }
  updateRetainedTiles(wrapTiles) {
    const retain = {};
    if (wrapTiles.length === 0) {
      return retain;
    }
    const checked = {};
    const minZoom = wrapTiles.reduce((min, id) => Math.min(min, id.overscaledZ), Infinity);
    const maxZoom = wrapTiles[0].overscaledZ;
    console.assert(minZoom <= maxZoom);
    const minCoveringZoom = Math.max(maxZoom - _SourceCache.maxOverzooming, this.source.minZoom);
    const maxCoveringZoom = Math.max(maxZoom + _SourceCache.maxUnderzooming, this.source.minZoom);
    const missingTiles = {};
    for (const tileID of wrapTiles) {
      const tile = this._addTile(tileID);
      retain[tileID.tileKey] = tileID;
      if (tile == null ? void 0 : tile.hasData())
        continue;
      if (minZoom < this.source.maxZoom) {
        missingTiles[tileID.tileKey] = tileID;
      }
    }
    this.retainLoadedChildren(missingTiles, minZoom, maxCoveringZoom, retain);
    for (const tileID of wrapTiles) {
      let tile = this.cacheTiles[tileID.tileKey];
      if (tile.hasData())
        continue;
      if (tileID.z >= this.source.maxZoom) {
        const childTileLike = tileID.children(this.source.maxZoom)[0];
        const childTile = this.getTile(childTileLike);
        if (!!childTile && childTile.hasData()) {
          retain[childTileLike.tileKey] = childTileLike;
          continue;
        }
      } else {
        const children = tileID.children(this.source.maxZoom);
        if (retain[children[0].tileKey] && retain[children[1].tileKey] && retain[children[2].tileKey] && retain[children[3].tileKey])
          continue;
      }
      let parentWasRequested = tile.wasRequested();
      for (let overscaledZ = tileID.overscaledZ - 1; overscaledZ >= minCoveringZoom; --overscaledZ) {
        const parentId = tileID.scaledTo(overscaledZ);
        if (checked[parentId.tileKey])
          break;
        checked[parentId.tileKey] = true;
        tile = this.getTile(parentId);
        if (!tile && parentWasRequested) {
          tile = this._addTile(parentId);
        }
        if (tile) {
          retain[parentId.tileKey] = parentId;
          parentWasRequested = tile.wasRequested();
          if (tile.hasData())
            break;
        }
      }
    }
    return retain;
  }
  /**
   * 获取已经加载的缓存瓦片
   * @param tileID
   * @return {*}
   */
  getLoadedTile(tileID) {
    const tile = this.cacheTiles[tileID.tileKey];
    if (tile && tile.hasData()) {
      return tile;
    }
    return __privateGet(this, _cache).get(tileID.tileKey);
  }
  /**
   * 查找已经加载的父级瓦片
   * @param tileID
   * @param minCoveringZoom
   */
  findLoadedParent(tileID, minCoveringZoom) {
    if (tileID.tileKey in this.loadedParentTiles) {
      const parent = this.loadedParentTiles[tileID.tileKey];
      if (parent && parent.tileID.overscaledZ >= minCoveringZoom) {
        return parent;
      } else {
        return null;
      }
    }
    for (let z = tileID.overscaledZ - 1; z >= minCoveringZoom; z--) {
      const parentTileID = tileID.scaledTo(z);
      const tile = this.getLoadedTile(parentTileID);
      if (tile) {
        return tile;
      }
    }
  }
  /**
   * 更新当前的缓存大小
   */
  updateCacheSize() {
    const tileSize = this.source.tileSize;
    const { width, height } = this.source.renderer.size;
    const widthInTiles = Math.ceil((width || 4 * tileSize) / tileSize) + 1;
    const heightInTiles = Math.ceil((height || 4 * tileSize) / tileSize) + 1;
    const approxTilesInView = widthInTiles * heightInTiles;
    const commonZoomRange = 5;
    const viewDependentMaxSize = Math.floor(approxTilesInView * commonZoomRange);
    const maxSize = typeof this.source.options.maxTileCacheSize === "number" ? Math.max(this.source.options.maxTileCacheSize, viewDependentMaxSize) : viewDependentMaxSize;
    __privateGet(this, _cache).setMaxSize(maxSize);
  }
  update(wrapTiles) {
    this.coveredTiles = {};
    let tiles = wrapTiles;
    this.updateCacheSize();
    if (this.source.hasTile) {
      tiles = wrapTiles.filter((coord) => this.source.hasTile(coord));
    }
    const retain = this.updateRetainedTiles(tiles);
    if (tiles.length !== 0) {
      const parentsForFading = {};
      const ids = Object.keys(retain);
      for (const id of ids) {
        const tileID = retain[id];
        const tile = this.cacheTiles[id];
        if (!tile)
          continue;
        const parentTile = this.findLoadedParent(
          tileID,
          Math.max(tileID.overscaledZ - _SourceCache.maxOverzooming, this.source.minZoom)
        );
        if (parentTile) {
          this._addTile(parentTile.tileID);
          parentsForFading[parentTile.tileID.tileKey] = parentTile.tileID;
        }
      }
      for (const id in parentsForFading) {
        if (!retain[id]) {
          this.coveredTiles[id] = true;
          retain[id] = parentsForFading[id];
        }
      }
    }
    this.emit("tilesLoadStart", {
      retain
    });
    const remove = keysDifference(this.cacheTiles, retain);
    for (const tileKey of remove) {
      this._removeTile(tileKey);
    }
    this.updateLoadedParentTileCache();
    const currentLength = Object.keys(this.cacheTiles).filter((k) => {
      var _a2;
      return (_a2 = this.cacheTiles[k]) == null ? void 0 : _a2.wasRequested();
    }).length;
    const retainLength = Object.keys(retain).length;
    if (currentLength < retainLength) {
      this.emit("tilesLoading", {
        progress: currentLength / retainLength
      });
    }
  }
  /**
   * 重载当前视野内的瓦片（需要移除缓存）
   */
  reload() {
    __privateGet(this, _cache).reset();
    for (const key in this.cacheTiles) {
      this._reloadTile(key, TileState.reloading);
    }
  }
  _reloadTile(id, state) {
    const tile = this.cacheTiles[id];
    if (!tile)
      return;
    if (tile.state !== TileState.loading) {
      tile.state = state;
    }
    this.loadTile(tile, this.tileLoaded.bind(this, tile, id, state));
  }
  clearTiles() {
    for (const id in this.cacheTiles) {
      this._removeTile(id);
    }
    __privateGet(this, _cache).reset();
  }
  /**
   * 查找覆盖 queryGeometry 的瓦片
   * @param {QueryGeometry} queryGeometry
   * @param {boolean} [visualizeQueryGeometry=false]
   * @param {boolean} use3DQuery
   * @returns
   * @private
   */
  tilesIn(queryGeometry) {
    const tileResults = [];
    for (const tileID in this.cacheTiles) {
      const tile = this.cacheTiles[tileID];
      const tilesToCheck = [0];
      for (const wrap of tilesToCheck) {
        const tileResult = queryGeometry.containsTile(this.source, tile, wrap);
        if (tileResult) {
          tileResults.push(tileResult);
        }
      }
    }
    return tileResults;
  }
  destroy() {
    for (const id in this.cacheTiles) {
      this._removeTile(id);
    }
    __privateGet(this, _cache).reset();
  }
};
_cache = new WeakMap();
_SourceCache.maxOverzooming = 10;
_SourceCache.maxUnderzooming = 3;
var SourceCache = _SourceCache;
var URL_PATTERN = /\{ *([\w_]+) *\}/g;
function formatUrl(url, data) {
  return url.replace(URL_PATTERN, (str, key) => {
    let value = data[key];
    if (value === void 0) {
      throw new Error(`No value provided for variable ${str}`);
    } else if (typeof value === "function") {
      value = value(data);
    }
    return value;
  });
}
var _loaded, _sourceCache, _tileWorkers;
var TileSource = class extends EventEmitter {
  constructor(id, options) {
    super();
    __privateAdd(this, _loaded);
    __privateAdd(this, _sourceCache);
    __privateAdd(this, _tileWorkers);
    this.roundZoom = false;
    __privateSet(this, _loaded, false);
    __privateSet(this, _tileWorkers, /* @__PURE__ */ new Map());
    this.id = id;
    this.type = LayerSourceType.tile;
    this.minZoom = options.minZoom ?? 0;
    this.maxZoom = options.maxZoom ?? 22;
    this.roundZoom = Boolean(options.roundZoom);
    this.scheme = options.scheme || "xyz";
    this.tileSize = options.tileSize || 512;
    this.tileBounds = options.tileBounds;
    this.wrapX = Boolean(options.wrapX);
    const decodeType = options.decodeType || DecodeType.image;
    const maxTileCacheSize = options.maxTileCacheSize;
    this.options = {
      ...options,
      decodeType,
      maxTileCacheSize,
      type: this.type
    };
    __privateSet(this, _sourceCache, new SourceCache(this.id, this));
  }
  get sourceCache() {
    return __privateGet(this, _sourceCache);
  }
  onAdd(layer, cb) {
    this.layer = layer;
    this.load(cb);
  }
  update(data, clear = true) {
    this.options.url = data.url;
    this.reload(clear);
    return this;
  }
  prepare(renderer, dispatcher, parseOptions) {
    this.renderer = renderer;
    this.dispatcher = dispatcher;
    this.parseOptions = parseOptions;
  }
  /**
   * 兼容 TileJSON 加载，需要具体实现
   * @param cb
   */
  load(cb) {
    __privateSet(this, _loaded, true);
    this.url = this.options.url;
    if (cb) {
      cb(null);
    }
  }
  loaded() {
    return __privateGet(this, _loaded);
  }
  reload(clear) {
    __privateSet(this, _loaded, false);
    this.load(() => {
      var _a2;
      if (clear) {
        __privateGet(this, _sourceCache).clearTiles();
      } else {
        __privateGet(this, _sourceCache).reload();
      }
      (_a2 = this.layer) == null ? void 0 : _a2.update();
    });
  }
  hasTile(coord) {
    return !this.tileBounds || containTile(this.tileBounds, coord.getTileBounds());
  }
  getFadeTime() {
    return 0;
  }
  getUrl(x, y, z) {
    const { subdomains } = this.options;
    let domain = "";
    if (subdomains && Array.isArray(subdomains) && subdomains.length > 0) {
      const { length } = subdomains;
      let s = (x + y) % length;
      if (s < 0) {
        s = 0;
      }
      domain = subdomains[s];
    }
    const data = {
      x,
      y,
      z,
      s: domain
    };
    if (Array.isArray(this.url)) {
      if (this.url.length > 2) {
        console.warn(
          `[TileSource]: Only supports up to two urls, Now there are more than two urls-${this.url.toString()}, and only the first two are selected by default`
        );
      }
      return this.url.filter((item, index2) => index2 < 2).map((u) => formatUrl(u, data));
    }
    return formatUrl(this.url, data);
  }
  asyncActor(tile, url) {
    return new Promise((resolve, reject) => {
      const id = `${tile.tileID.tileKey}-${url}`;
      tile.actor.send(
        "loadData",
        {
          url: resolveURL(url),
          cancelId: id,
          type: "arrayBuffer",
          decodeType: this.options.decodeType
        },
        (e, data) => {
          if (e) {
            return reject(e);
          }
          resolve(data);
        }
      );
      tile.request.set(id, url);
    });
  }
  getTileUrl(tileID) {
    const z = tileID.z;
    const x = tileID.x;
    const y = this.scheme === "tms" ? Math.pow(2, tileID.z) - tileID.y - 1 : tileID.y;
    const url = this.getUrl(x, y, z);
    let urls = url;
    if (index.isString(url)) {
      urls = [url];
    }
    return urls;
  }
  loadTile(tile, callback) {
    try {
      if (!tile.actor || tile.state === TileState.reloading) {
        const urls = this.getTileUrl(tile.tileID);
        const key = urls.join(",");
        __privateGet(this, _tileWorkers).set(key, __privateGet(this, _tileWorkers).get(key) || this.dispatcher.getActor());
        tile.actor = __privateGet(this, _tileWorkers).get(key);
        const p = [];
        for (let i = 0; i < urls.length; i++) {
          p.push(this.asyncActor(tile, urls[i]));
        }
        Promise.all(p).then((data) => {
          tile.request.clear();
          if (tile.aborted) {
            tile.state = TileState.unloaded;
            return callback(null);
          }
          if (!data)
            return callback(null);
          data.forEach((d, index2) => {
            tile.setTextures(this.renderer, index2, d, this.parseOptions, this.options);
          });
          tile.state = TileState.loaded;
          callback(null);
        }).catch((e) => {
          tile.state = TileState.errored;
          console.log(e);
        });
      } else if (tile.state === TileState.loading) {
        tile.reloadCallback = callback;
      }
    } catch (e) {
      tile.state = TileState.errored;
      return callback(e);
    }
  }
  abortTile(tile, callback) {
    if (tile.request) {
      if (tile.request.size > 0 && tile.actor) {
        const iterator = tile.request.entries();
        for (let i = 0; i < tile.request.size; i++) {
          const [id, url] = iterator.next().value;
          if (id) {
            tile.actor.send(
              "cancel",
              {
                url,
                cancelId: id
              },
              (err) => {
                if (err) {
                  tile.state = TileState.unloaded;
                }
              }
            );
          }
        }
      }
      tile.request.clear();
    } else {
      tile.state = TileState.unloaded;
    }
    callback();
  }
  unloadTile(tile, callback) {
    if (tile.actor) ;
  }
  destroy() {
    this.layer = null;
    __privateSet(this, _loaded, false);
    __privateGet(this, _tileWorkers).clear();
    __privateGet(this, _sourceCache).clear();
  }
};
_loaded = new WeakMap();
_sourceCache = new WeakMap();
_tileWorkers = new WeakMap();
var _loaded2, _sourceCache2, _tileWorkers2;
var ImageSource = class extends EventEmitter {
  constructor(id, options) {
    super();
    __privateAdd(this, _loaded2);
    __privateAdd(this, _sourceCache2);
    __privateAdd(this, _tileWorkers2);
    this.roundZoom = false;
    __privateSet(this, _loaded2, false);
    __privateSet(this, _tileWorkers2, /* @__PURE__ */ new Map());
    this.id = id;
    this.type = LayerSourceType.image;
    this.minZoom = 0;
    this.maxZoom = 22;
    this.roundZoom = false;
    this.tileSize = 512;
    this.coordinates = options.coordinates;
    this.wrapX = Boolean(options.wrapX);
    this.url = options.url;
    const decodeType = options.decodeType || DecodeType.image;
    this.options = {
      ...options,
      decodeType,
      type: this.type
    };
    __privateSet(this, _sourceCache2, new SourceCache(this.id, this));
  }
  get sourceCache() {
    return __privateGet(this, _sourceCache2);
  }
  onAdd(layer, cb) {
    this.layer = layer;
    this.load(cb);
  }
  prepare(renderer, dispatcher, parseOptions) {
    this.renderer = renderer;
    this.dispatcher = dispatcher;
    this.parseOptions = parseOptions;
  }
  update(data, clear = true) {
    this.options.url = data.url;
    this.reload(clear);
  }
  updateImage(options, clear = true) {
    this.options = {
      ...this.options,
      ...options
    };
    this.reload(clear);
  }
  setCoordinates(coordinates) {
    this.coordinates = coordinates;
    this.reload(false);
  }
  asyncActor(tile, url) {
    return new Promise((resolve, reject) => {
      const id = `${tile.tileID.tileKey}-${url}`;
      tile.actor.send(
        "loadData",
        {
          url: resolveURL(url),
          cancelId: id,
          type: "arrayBuffer",
          decodeType: this.options.decodeType
        },
        (e, data) => {
          if (e) {
            return reject(e);
          }
          resolve(data);
        }
      );
      tile.request.set(id, url);
    });
  }
  /**
   * 兼容 TileJSON 加载，需要具体实现
   * @param cb
   */
  load(cb) {
    __privateSet(this, _loaded2, true);
    this.url = this.options.url;
    if (cb) {
      cb(null);
    }
  }
  loaded() {
    return __privateGet(this, _loaded2);
  }
  reload(clear) {
    __privateSet(this, _loaded2, false);
    this.load(() => {
      var _a2;
      if (clear) {
        __privateGet(this, _sourceCache2).clearTiles();
      } else {
        __privateGet(this, _sourceCache2).reload();
      }
      (_a2 = this.layer) == null ? void 0 : _a2.update();
    });
  }
  getTileUrl(tileID) {
    let urls = this.url;
    if (index.isString(this.url)) {
      urls = [this.url];
    }
    return urls;
  }
  loadTile(tile, callback) {
    try {
      if (!tile.actor || tile.state === TileState.reloading) {
        const urls = this.getTileUrl(tile.tileID);
        const key = urls.join(",");
        __privateGet(this, _tileWorkers2).set(key, __privateGet(this, _tileWorkers2).get(key) || this.dispatcher.getActor());
        tile.actor = __privateGet(this, _tileWorkers2).get(key);
        const p = [];
        for (let i = 0; i < urls.length; i++) {
          p.push(this.asyncActor(tile, urls[i]));
        }
        Promise.all(p).then((data) => {
          tile.request.clear();
          if (tile.aborted) {
            tile.state = TileState.unloaded;
            return callback(null);
          }
          if (!data)
            return callback(null);
          data.forEach((d, index2) => {
            tile.setTextures(this.renderer, index2, d, this.parseOptions, this.options);
          });
          tile.state = TileState.loaded;
          callback(null);
        }).catch((e) => {
          tile.state = TileState.errored;
          console.log(e);
        });
      } else if (tile.state === TileState.loading) {
        tile.reloadCallback = callback;
      } else {
      }
    } catch (e) {
      tile.state = TileState.errored;
      return callback(e);
    }
  }
  hasTile(coord) {
    return true;
  }
  getFadeTime() {
    return 0;
  }
  abortTile(tile, callback) {
    if (tile.request) {
      if (tile.request.size > 0 && tile.actor) {
        const iterator = tile.request.entries();
        for (let i = 0; i < tile.request.size; i++) {
          const [id, url] = iterator.next().value;
          if (id) {
            tile.actor.send(
              "cancel",
              {
                url,
                cancelId: id
              },
              (err) => {
                if (err) {
                  tile.state = TileState.unloaded;
                }
              }
            );
          }
        }
      }
      tile.request.clear();
    } else {
      tile.state = TileState.unloaded;
    }
    callback();
  }
  // eslint-disable-next-line
  unloadTile(tile, cb) {
  }
  destroy() {
    this.layer = null;
    __privateSet(this, _loaded2, false);
    __privateGet(this, _tileWorkers2).clear();
    __privateGet(this, _sourceCache2).clear();
  }
};
_loaded2 = new WeakMap();
_sourceCache2 = new WeakMap();
_tileWorkers2 = new WeakMap();
var TrackManger = class {
  constructor() {
    this.tracks = /* @__PURE__ */ new Set();
    this.run = this.run.bind(this);
    this.raf = new Raf(this.run);
  }
  add(track) {
    if (!this.tracks.has(track)) {
      this.tracks.add(track);
      this.raf.start();
    }
  }
  run(time) {
    this.tracks.forEach((t) => {
      t.tick(time);
    });
  }
  remove(track) {
    if (this.tracks.has(track)) {
      this.tracks.delete(track);
    }
    if (this.tracks.size === 0) {
      this.raf.stop();
    }
  }
};
var tm = null;
function getTrackManger() {
  if (!tm) {
    tm = new TrackManger();
  }
  return tm;
}
var defaultTrackOptions = {
  duration: 1e3,
  autoplay: true,
  repeat: true,
  delay: 0,
  endDelay: 0,
  track: (p) => void 0
  // eslint-disable-line
};
var trackManger = getTrackManger();
var _playing, _state, _elapsedTime, _lastTime, _options;
var Track = class extends EventEmitter {
  constructor(options) {
    super();
    __privateAdd(this, _playing, false);
    __privateAdd(this, _state, 0);
    __privateAdd(this, _elapsedTime, -1);
    __privateAdd(this, _lastTime, -1);
    __privateAdd(this, _options);
    __privateSet(this, _options, {
      ...defaultTrackOptions,
      ...options
    });
    if (__privateGet(this, _options).autoplay) {
      this.play();
    }
  }
  /**
   * 获取当前 Track 的状态
   */
  get state() {
    return __privateGet(this, _state);
  }
  /**
   * 获取总的过渡时间
   */
  get totalDuration() {
    return __privateGet(this, _options).delay + __privateGet(this, _options).duration + __privateGet(this, _options).endDelay;
  }
  get elapsedTime() {
    return __privateGet(this, _elapsedTime);
  }
  get totalPosition() {
    return Math.max(0, Math.min(1, __privateGet(this, _elapsedTime) / this.totalDuration));
  }
  /**
   * 是否在播放
   */
  get isPlaying() {
    return __privateGet(this, _state) === 1;
  }
  /**
   * 是否暂停
   */
  get isPaused() {
    return __privateGet(this, _state) === 2;
  }
  /**
   * 是否处于激活状态
   */
  get isActive() {
    return this.isPlaying || this.isPaused;
  }
  /**
   * 获取当前 Track 的 cursor 位置
   */
  get position() {
    if (__privateGet(this, _elapsedTime) < __privateGet(this, _options).delay) {
      return 0;
    }
    if (__privateGet(this, _elapsedTime) >= __privateGet(this, _options).delay + __privateGet(this, _options).duration) {
      return 1;
    }
    return Math.max(0, Math.min(1, (__privateGet(this, _elapsedTime) - __privateGet(this, _options).delay) / __privateGet(this, _options).duration));
  }
  /**
   * 开始播放
   */
  play() {
    __privateSet(this, _playing, true);
    __privateSet(this, _state, 1);
    this.advance(0);
    trackManger.add(this);
  }
  /**
   * 暂停
   */
  pause() {
    if (__privateGet(this, _state) === 1) {
      __privateSet(this, _state, 2);
    }
  }
  /**
   * 继续播放
   */
  resume() {
    if (__privateGet(this, _state) === 2) {
      __privateSet(this, _state, 1);
    }
  }
  /**
   * 停止
   */
  stop() {
    __privateSet(this, _playing, false);
    __privateSet(this, _state, 3);
    trackManger.remove(this);
  }
  /**
   * 重新开始
   */
  restart() {
    __privateSet(this, _elapsedTime, 0);
    trackManger.add(this);
  }
  /**
   * 重置
   */
  reset() {
    if (__privateGet(this, _state) === 1) {
      this.stop();
    } else {
      this.advance(0);
    }
  }
  /**
   * 在播放和暂停状态切换
   */
  toggle() {
    if (__privateGet(this, _playing)) {
      if (this.isPlaying) {
        this.pause();
      } else {
        this.resume();
      }
    }
  }
  /**
   * 步进
   * @param position
   * @param e
   */
  advance(position, e = true) {
    var _a2, _b;
    const p = index.clamp(position, 0, 1);
    __privateSet(this, _elapsedTime, e ? this.totalDuration * p : __privateGet(this, _options).delay + __privateGet(this, _options).duration * p);
    (_b = (_a2 = __privateGet(this, _options)) == null ? void 0 : _a2.track) == null ? void 0 : _b.call(_a2, this.position);
    this.emit("track", {
      position: this.position
    });
  }
  tick(time) {
    if (__privateGet(this, _lastTime) < 0) {
      __privateSet(this, _lastTime, time);
    }
    const lastTime = __privateGet(this, _lastTime);
    __privateSet(this, _lastTime, time);
    if (__privateGet(this, _state) !== 1)
      return;
    const delta = time - lastTime;
    __privateSet(this, _elapsedTime, __privateGet(this, _elapsedTime) + delta);
    __privateSet(this, _elapsedTime, Math.min(__privateGet(this, _elapsedTime), this.totalDuration));
    if (this.totalPosition === 1) {
      this.advance(this.totalPosition);
      __privateGet(this, _options).repeat ? this.restart() : this.stop();
    } else {
      this.advance(this.totalPosition);
    }
  }
};
_playing = new WeakMap();
_state = new WeakMap();
_elapsedTime = new WeakMap();
_lastTime = new WeakMap();
_options = new WeakMap();
var sourceImpl = {
  tile: TileSource,
  image: ImageSource
};
function generateKey(url) {
  let urls = [];
  if (index.isString(url)) {
    urls = [url];
  }
  return urls.join(",");
}
var _loaded3, _sourceCache3, _current5, _next5, _index, _fadeTime, _track, _cache2;
var TimelineSource = class extends EventEmitter {
  constructor(id, options) {
    super();
    __privateAdd(this, _loaded3);
    __privateAdd(this, _sourceCache3);
    __privateAdd(this, _current5);
    __privateAdd(this, _next5);
    __privateAdd(this, _index);
    __privateAdd(this, _fadeTime);
    __privateAdd(this, _track);
    __privateAdd(this, _cache2);
    this.roundZoom = false;
    __privateSet(this, _loaded3, false);
    __privateSet(this, _fadeTime, 0);
    __privateSet(this, _cache2, /* @__PURE__ */ new Map());
    this.id = id;
    this.type = LayerSourceType.timeline;
    this.minZoom = options.minZoom ?? 0;
    this.maxZoom = options.maxZoom ?? 22;
    this.roundZoom = Boolean(options.roundZoom);
    const scheme = options.scheme || "xyz";
    this.tileSize = options.tileSize || 512;
    this.tileBounds = options.tileBounds;
    this.wrapX = Boolean(options.wrapX);
    if (options.sourceType === LayerSourceType.image && !options.coordinates) {
      throw new Error("ImageSource must provide `coordinates`");
    }
    this.coordinates = options.coordinates;
    this.intervals = options.intervals;
    const decodeType = options.decodeType || DecodeType.image;
    const maxTileCacheSize = options.maxTileCacheSize;
    this.options = {
      ...defaultTrackOptions,
      ...options,
      decodeType,
      maxTileCacheSize,
      wrapX: this.wrapX,
      type: this.type
    };
    const current = this.intervals[0];
    __privateSet(this, _index, 0);
    this.animate = this.animate.bind(this);
    this.tilesLoadEnd = this.tilesLoadEnd.bind(this);
    const config = {};
    if (options.sourceType === LayerSourceType.image) {
      Object.assign(config, {
        url: current.url,
        coordinates: this.coordinates,
        maxTileCacheSize: this.options.maxTileCacheSize,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        decodeType
      });
    } else if (options.sourceType === LayerSourceType.tile) {
      Object.assign(config, {
        url: current.url,
        subdomains: this.options.subdomains,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        tileSize: this.tileSize,
        roundZoom: this.roundZoom,
        tileBounds: this.tileBounds,
        maxTileCacheSize: this.options.maxTileCacheSize,
        scheme,
        decodeType
      });
    } else {
      throw new Error("不支持的数据源类型！");
    }
    __privateSet(this, _current5, new sourceImpl[options.sourceType](`${this.id}_current`, config));
    __privateSet(this, _next5, new sourceImpl[options.sourceType](`${this.id}_next`, config));
    const currentLoadTile = __privateGet(this, _current5).loadTile;
    const nextLoadTile = __privateGet(this, _next5).loadTile;
    const that = this;
    function wrapCurrentLoadTile(tile, callback) {
      const key = `${tile.tileID.tileKey}-${generateKey(this.url)}`;
      const cacheTile = __privateGet(that, _cache2).get(key);
      if (cacheTile) {
        tile.copy(cacheTile);
        callback(null, true);
      } else {
        currentLoadTile.call(this, tile, (err, data) => {
          if (!err && !__privateGet(that, _cache2).has(key) && tile.state === TileState.loaded) {
            __privateGet(that, _cache2).set(key, tile);
          }
          callback(err, data);
        });
      }
    }
    function wrapNextLoadTile(tile, callback) {
      const key = `${tile.tileID.tileKey}-${generateKey(this.url)}`;
      const cacheTile = __privateGet(that, _cache2).get(key);
      if (cacheTile) {
        tile.copy(cacheTile);
        callback(null, true);
      } else {
        nextLoadTile.call(this, tile, (err, data) => {
          if (!err && !__privateGet(that, _cache2).has(key) && tile.state === TileState.loaded) {
            __privateGet(that, _cache2).set(key, tile);
          }
          callback(err, data);
        });
      }
    }
    __privateGet(this, _current5).loadTile = wrapCurrentLoadTile;
    __privateGet(this, _next5).loadTile = wrapNextLoadTile;
    __privateGet(this, _current5).sourceCache.on("tilesLoadEnd", this.tilesLoadEnd);
    __privateGet(this, _next5).sourceCache.on("tilesLoadEnd", this.tilesLoadEnd);
  }
  get track() {
    return __privateGet(this, _track);
  }
  get privateType() {
    return this.options.sourceType;
  }
  get cache() {
    return __privateGet(this, _cache2);
  }
  get source() {
    return [__privateGet(this, _current5), __privateGet(this, _next5)];
  }
  get sourceCache() {
    var _a2, _b;
    return [(_a2 = __privateGet(this, _current5)) == null ? void 0 : _a2.sourceCache, (_b = __privateGet(this, _next5)) == null ? void 0 : _b.sourceCache].filter(Boolean);
  }
  onAdd(layer) {
    this.layer = layer;
    if (__privateGet(this, _current5)) {
      __privateGet(this, _current5).onAdd(this.layer, (error) => {
        if (!error) {
          if (__privateGet(this, _next5)) {
            __privateGet(this, _next5).onAdd(this.layer, (err) => {
              if (!err) {
                this.load();
              }
            });
          }
        }
      });
    }
  }
  prepare(renderer, dispatcher, parseOptions) {
    this.renderer = renderer;
    this.dispatcher = dispatcher;
    this.parseOptions = parseOptions;
    if (__privateGet(this, _current5)) {
      __privateGet(this, _current5).prepare(renderer, dispatcher, parseOptions);
    }
    if (__privateGet(this, _next5)) {
      __privateGet(this, _next5).prepare(renderer, dispatcher, parseOptions);
    }
  }
  getFadeTime() {
    return __privateGet(this, _fadeTime);
  }
  tilesLoadEnd() {
    this.resume();
  }
  animate({ position }) {
    var _a2, _b;
    const len = this.intervals.length;
    const lastIndex = __privateGet(this, _index);
    __privateSet(this, _index, position * index.clamp(len - 1, 0, Infinity));
    const diff = Math.floor(__privateGet(this, _index)) - Math.floor(lastIndex);
    if (diff > 0 || diff < 0) {
      if (!((_a2 = __privateGet(this, _current5)) == null ? void 0 : _a2.sourceCache.loaded()) || !((_b = __privateGet(this, _next5)) == null ? void 0 : _b.sourceCache.loaded())) {
        this.pause();
      } else {
        __privateSet(this, _fadeTime, 0);
        [__privateWrapper(this, _current5)._, __privateWrapper(this, _next5)._] = [__privateGet(this, _next5), __privateGet(this, _current5)];
        this.pause();
        const item = this.intervals[index.clamp(Math.floor(__privateGet(this, _index)), 0, len - 1)];
        __privateGet(this, _next5).update(item, true);
      }
    } else {
      __privateSet(this, _fadeTime, __privateGet(this, _index) % 1);
    }
    if (this.layer) {
      this.layer.onTileLoaded();
    }
    this.emit("update", {
      position,
      index: __privateGet(this, _index),
      clampIndex: index.clamp(Math.floor(__privateGet(this, _index)), 0, len - 1)
    });
  }
  play() {
    __privateGet(this, _track).play();
    this.emit("play", { position: __privateGet(this, _track).position });
  }
  pause() {
    __privateGet(this, _track).pause();
    this.emit("pause", { position: __privateGet(this, _track).position });
  }
  resume() {
    __privateGet(this, _track).resume();
    this.emit("resume", { position: __privateGet(this, _track).position });
  }
  stop() {
    __privateGet(this, _track).stop();
    this.emit("stop", { position: __privateGet(this, _track).position });
  }
  restart() {
    __privateGet(this, _track).restart();
    this.emit("restart", { position: __privateGet(this, _track).position });
  }
  load(cb) {
    var _a2;
    __privateSet(this, _loaded3, true);
    __privateSet(this, _track, new Track({
      duration: this.options.duration * index.clamp(this.intervals.length - 1, 0, Infinity),
      endDelay: this.options.endDelay,
      repeat: this.options.repeat,
      autoplay: this.options.autoplay
    }));
    __privateGet(this, _track).on("track", this.animate);
    (_a2 = this.layer) == null ? void 0 : _a2.update();
    if (cb) {
      cb(null);
    }
    this.emit("loaded", { position: __privateGet(this, _track).position });
  }
  loaded() {
    return __privateGet(this, _loaded3);
  }
  destroy() {
    this.layer = null;
    __privateSet(this, _loaded3, false);
    __privateGet(this, _track).off("track", this.animate);
    if (__privateGet(this, _sourceCache3) && Array.isArray(__privateGet(this, _sourceCache3))) {
      __privateGet(this, _sourceCache3).forEach((s) => {
        s.clear();
      });
    }
    this.emit("destroy");
  }
};
_loaded3 = new WeakMap();
_sourceCache3 = new WeakMap();
_current5 = new WeakMap();
_next5 = new WeakMap();
_index = new WeakMap();
_fadeTime = new WeakMap();
_track = new WeakMap();
_cache2 = new WeakMap();
var configDeps = wgw$1.configDeps;
export {
  BaseLayer,
  DecodeType,
  ImageSource,
  LayerSourceType,
  MaskType,
  RenderFrom,
  RenderType,
  Tile,
  TileID,
  TileSource,
  TileState,
  TimelineSource,
  calcMinMax,
  configDeps,
  containTile,
  containsExtent,
  containsXY,
  defaultOptions,
  findStopLessThanOrEqualTo,
  flattenForPolygons,
  getBandType,
  inRange,
  intersects,
  isFunction,
  isImageBitmap,
  keysDifference,
  littleEndian,
  mod,
  parseRange,
  polygon2buffer,
  resolveURL
};
//# sourceMappingURL=wind-gl-core.js.map
