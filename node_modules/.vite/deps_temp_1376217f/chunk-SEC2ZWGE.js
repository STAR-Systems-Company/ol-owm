import {
  add,
  add2,
  add3,
  add4,
  add5,
  adjoint,
  adjoint2,
  angle,
  angle2,
  common_exports,
  conjugate,
  copy,
  copy2,
  copy3,
  cross,
  cross2,
  cross3,
  determinant,
  determinant2,
  distance,
  distance2,
  distance3,
  divide,
  divide2,
  divide3,
  dot,
  dot2,
  dot3,
  dot4,
  equals,
  equals2,
  equals3,
  equals4,
  equals5,
  frob,
  fromEuler,
  fromMat3,
  fromMat4,
  fromQuat,
  fromQuat2,
  fromRotation,
  fromRotation2,
  fromRotationTranslation,
  fromRotationTranslationScale,
  fromScaling,
  fromScaling2,
  fromTranslation,
  fromTranslation2,
  fromXRotation,
  fromYRotation,
  fromZRotation,
  frustum,
  getAngle,
  getAxisAngle,
  getRotation,
  getScaling,
  getTranslation,
  identity,
  identity2,
  inverse,
  inverse2,
  inverse3,
  invert,
  invert2,
  invert3,
  length,
  length2,
  length3,
  length4,
  lerp,
  lerp2,
  lerp3,
  lookAt,
  multiply,
  multiply2,
  multiply3,
  multiply4,
  multiply5,
  multiply6,
  multiplyScalar,
  negate,
  negate2,
  negate3,
  normalFromMat4,
  normalize,
  normalize2,
  normalize3,
  normalize4,
  ortho,
  perspective,
  rotate,
  rotate2,
  rotateX,
  rotateY,
  rotateZ,
  scale,
  scale2,
  scale3,
  scale4,
  scale5,
  scaleAndAdd,
  scaleAndAdd2,
  set,
  set2,
  set3,
  set4,
  set5,
  setAxisAngle,
  slerp,
  squaredDistance,
  squaredDistance2,
  squaredDistance3,
  subtract,
  subtract2,
  subtract3,
  subtract4,
  subtract5,
  transformMat3,
  transformMat32,
  transformMat4,
  transformMat42,
  transformMat43,
  transformQuat,
  transformQuat2,
  translate,
  translate2,
  transpose,
  transpose2
} from "./chunk-XR5TTCGL.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/colord/index.mjs
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t = function(r2) {
  return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
};
var n = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
};
var e = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
};
var u = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
};
var a = function(r2) {
  return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
};
var o = function(r2) {
  return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
};
var i = /^#([0-9a-f]{3,8})$/i;
var s = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
};
var h = function(r2) {
  var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
};
var b = function(r2) {
  var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
  var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
  return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
};
var g = function(r2) {
  return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
};
var d = function(r2) {
  return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
};
var f = function(r2) {
  return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
  var t2, n2, e2;
};
var c = function(r2) {
  return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e2, u2;
};
var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var y = { string: [[function(r2) {
  var t2 = i.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v.exec(r2) || m.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l.exec(t2) || p.exec(t2);
  if (!n2) return null;
  var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f(a2);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
  return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
  if (!t(n2) || !t(e2) || !t(u2)) return null;
  var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
  return f(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
  if (!t(n2) || !t(a2) || !t(o2)) return null;
  var h2 = function(r3) {
    return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
  }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
  return b(h2);
}, "hsv"]] };
var N = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e2 = t2[n2][0](r2);
    if (e2) return [e2, t2[n2][1]];
  }
  return [null, void 0];
};
var x = function(r2) {
  return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
};
var M = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
};
var H = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
};
var $ = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
};
var j = function() {
  function r2(r3) {
    this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return null !== this.parsed;
  }, r2.prototype.brightness = function() {
    return n(H(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
    var r3, t2, e2, u2, a2, i2;
  }, r2.prototype.toRgb = function() {
    return o(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsl = function() {
    return d(c(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w(M(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c(this.rgba);
    return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w(r3).toHex();
  }, r2;
}();
var w = function(r2) {
  return r2 instanceof j ? r2 : new j(r2);
};
var S = [];
var k = function(r2) {
  r2.forEach(function(r3) {
    S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
  });
};

// node_modules/@sakitam-gis/vis-engine/dist/index.esm.js
function parseShader(shader, defines = [], includes = []) {
  return shader.replace(/#defines/, defines.join("\n")).replace(/#includes/, includes.join("\n"));
}
function defineShader(shader, defines = {}) {
  return Object.keys(defines).reduce((str, key) => defines[key] ? `#define ${key} ${defines[key]}
${str}` : str, shader);
}
function getShaderName(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define\s*SHADER_NAME\s*([A-Za-z0-9_-]+)\s*/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
function getWireframeIndex(position, indices, numIndices, data) {
  const edges = /* @__PURE__ */ new Set();
  if (data) {
    for (let j2 = 0, l2 = numIndices; j2 < l2; j2 += 3) {
      const a2 = data[j2];
      const b2 = data[j2 + 1];
      const c2 = data[j2 + 2];
      const array = [a2, b2, b2, c2, c2, a2];
      for (let i2 = 0; i2 < array.length; i2 += 2) {
        if (isUniqueEdge(array[i2] * 3, array[i2 + 1] * 3, position, edges)) {
          indices.push(array[i2], array[i2 + 1]);
        }
      }
    }
  } else {
    for (let j2 = 0, l2 = numIndices; j2 < l2; j2 += 3) {
      const a2 = j2;
      const b2 = j2 + 1;
      const c2 = j2 + 2;
      const array = [a2, b2, b2, c2, c2, a2];
      for (let i2 = 0; i2 < array.length; i2 += 2) {
        if (isUniqueEdge(array[i2] * 3, array[i2 + 1] * 3, position, edges)) {
          indices.push(array[i2], array[i2 + 1]);
        }
      }
    }
  }
  return indices;
}
function isUniqueEdge(start, end, position, edges) {
  const hash1 = `${position[start]},${position[start + 1]},${position[start + 2]}-${position[end]},${position[end + 1]},${position[end + 2]}`;
  const hash2 = `${position[end]},${position[end + 1]},${position[end + 2]}-${position[start]},${position[start + 1]},${position[start + 2]}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var DEG_TO_RAD = Math.PI / 180;
var RAD_TO_DEG = 180 / Math.PI;
function degToRad(deg) {
  return deg * DEG_TO_RAD;
}
function radToDeg(a2) {
  return a2 * RAD_TO_DEG;
}
function clamp(val, min, max) {
  return Math.min(Math.max(val, min), max);
}
function isPowerOfTwo(value) {
  return Math.log(value) / Math.LN2 % 1 === 0;
}
var FloatArray = Float32Array;
function highPrecision(b2, notifyGlMatrix = true) {
  if (b2) {
    FloatArray = Float64Array;
  } else {
    FloatArray = Float32Array;
  }
  if (notifyGlMatrix) {
    common_exports.setMatrixArrayType(FloatArray);
  }
}
function getFloatArrayConstructor() {
  return FloatArray;
}
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  if ((gl == null ? void 0 : gl.gl) && (gl.gl instanceof WebGLRenderingContext || gl.gl instanceof WebGL2RenderingContext)) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  if ((gl == null ? void 0 : gl.gl) && gl.gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getContext(canvas, glOptions = {}, requestWebGl2 = false) {
  var _a, _b;
  const names = ["webgl2", "webgl", "experimental-webgl"];
  if (!requestWebGl2) {
    names.shift();
  }
  let context = null;
  function onContextCreationError(error) {
    console.error(error.statusMessage);
  }
  (_a = canvas == null ? void 0 : canvas.addEventListener) == null ? void 0 : _a.call(canvas, "webglcontextcreationerror", onContextCreationError, false);
  for (let ii = 0; ii < names.length; ++ii) {
    try {
      context = canvas.getContext(names[ii], glOptions);
    } catch (e2) {
    }
    if (context) {
      break;
    }
  }
  (_b = canvas == null ? void 0 : canvas.removeEventListener) == null ? void 0 : _b.call(canvas, "webglcontextcreationerror", onContextCreationError, false);
  return context;
}
var now = () => ("undefined" == typeof performance ? Date : performance).now();
function typeOf(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}
function isString(s2) {
  return typeOf(s2) === "string";
}
function isUndef(s2) {
  return typeOf(s2) === "undefined";
}
function isHex(string) {
  return isString(string) && string.includes("%");
}
function isNumber(s2) {
  return typeOf(s2) === "number";
}
function isRegexp(obj) {
  return typeOf(obj) === "regexp";
}
function isNull(value) {
  return value == null;
}
function isObject(value) {
  const type = typeof value;
  return value !== null && (type === "object" || type === "function");
}
function hasValue(v2, state) {
  if (isObject(v2)) {
    return !isNull(v2.value) && (isNull(state) || v2.value === state);
  } else {
    return !isNull(v2) && (isNull(state) || v2 === state);
  }
}
var uidCounters = {};
function uid(id = "id") {
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return `${id}-${count}`;
}
function omit(obj, keys = []) {
  return Object.keys(obj).filter((key) => keys.indexOf(key) < 0).reduce(
    (newObj, key) => Object.assign(newObj, {
      [key]: obj[key]
    }),
    {}
  );
}
function pick(obj, keys = []) {
  return Object.keys(obj).filter((key) => keys.indexOf(key) > -1).reduce(
    (newObj, key) => Object.assign(newObj, {
      [key]: obj[key]
    }),
    {}
  );
}
var callbacks = [];
var fpsInterval = 1e3 / 60;
var time = performance.now();
function requestAnimationFrameLoop() {
  const current = now();
  const delta = current - time;
  if (delta >= fpsInterval) {
    time = current - delta % fpsInterval;
    const funcs = callbacks.slice();
    callbacks.length = 0;
    for (let i2 = 0; i2 < funcs.length; i2++) {
      funcs[i2] && funcs[i2](current, delta);
    }
  } else {
    setImmediate(requestAnimationFrameLoop);
  }
}
function raf(func) {
  callbacks.push(func);
  if (callbacks.length === 1) {
    setImmediate(requestAnimationFrameLoop);
  }
  return callbacks.length - 1;
}
function caf(id) {
  callbacks[id] = void 0;
}
function requestAnimationFrame(cb) {
  if (typeof window !== "undefined" && window.requestAnimationFrame) {
    return window.requestAnimationFrame(cb);
  }
  return raf(cb);
}
function cancelAnimationFrame(cb) {
  if (typeof window !== "undefined" && window.cancelAnimationFrame) {
    return window.cancelAnimationFrame(cb);
  }
  return caf(cb);
}
var index = Object.freeze({
  __proto__: null,
  DEG_TO_RAD,
  RAD_TO_DEG,
  cancelAnimationFrame,
  clamp,
  defineShader,
  degToRad,
  getContext,
  getFloatArrayConstructor,
  getShaderName,
  getWireframeIndex,
  hasValue,
  highPrecision,
  isHex,
  isNull,
  isNumber,
  isObject,
  isPowerOfTwo,
  isRegexp,
  isString,
  isUndef,
  isUniqueEdge,
  isWebGL,
  isWebGL2,
  now,
  omit,
  parseShader,
  pick,
  radToDeg,
  requestAnimationFrame,
  typeOf,
  uid
});
var _lastTime, _elapsedTime, _start;
var Clock = class {
  constructor(running = true) {
    __privateAdd(this, _lastTime, 0);
    __privateAdd(this, _elapsedTime, 0);
    __privateAdd(this, _start, false);
    __publicField(this, "running");
    this.running = running;
  }
  start() {
    if (!__privateGet(this, _start)) {
      this.reset();
      __privateSet(this, _start, true);
    }
  }
  stop() {
    this.getElapsedTime();
    __privateSet(this, _start, false);
    this.running = false;
  }
  reset() {
    __privateSet(this, _lastTime, now());
    __privateSet(this, _elapsedTime, 0);
  }
  getElapsedTime() {
    this.getDelta();
    return __privateGet(this, _elapsedTime);
  }
  getDelta() {
    let deltaTime = 0;
    if (this.running && !__privateGet(this, _start)) {
      this.start();
      return 0;
    }
    if (__privateGet(this, _start)) {
      const time2 = now();
      deltaTime = (time2 - __privateGet(this, _lastTime)) / 1e3;
      __privateSet(this, _lastTime, time2);
      __privateSet(this, _elapsedTime, __privateGet(this, _elapsedTime) + deltaTime);
    }
    return deltaTime;
  }
};
_lastTime = new WeakMap();
_elapsedTime = new WeakMap();
_start = new WeakMap();
var defaultOptions = {
  autoStart: true
};
var _raf, _animating, _isVisible, _clock, _callback;
var Raf = class {
  constructor(cb, options = {}) {
    __publicField(this, "options");
    __privateAdd(this, _raf);
    __privateAdd(this, _animating);
    __privateAdd(this, _isVisible);
    __privateAdd(this, _clock);
    __privateAdd(this, _callback);
    this.options = {
      ...options,
      ...defaultOptions
    };
    __privateSet(this, _clock, new Clock());
    this.reset();
    this.onVisibilityChange = this.onVisibilityChange.bind(this);
    __privateSet(this, _callback, () => {
      const time2 = __privateGet(this, _clock).getElapsedTime();
      cb && cb(time2);
    });
    if (this.options.autoStart) {
      this.start();
    }
  }
  get visible() {
    return __privateGet(this, _isVisible);
  }
  get animating() {
    return __privateGet(this, _animating);
  }
  reset() {
    __privateSet(this, _animating, false);
    __privateSet(this, _isVisible, true);
    if (__privateGet(this, _raf) !== void 0) {
      cancelAnimationFrame(__privateGet(this, _raf));
    }
  }
  get elapsedTime() {
    return __privateGet(this, _clock).getElapsedTime();
  }
  start() {
    if (__privateGet(this, _animating))
      return;
    __privateSet(this, _animating, true);
    __privateGet(this, _clock).start();
    this.tick();
    if (typeof window !== "undefined" && window.document) {
      window.document.addEventListener("visibilitychange", this.onVisibilityChange, false);
    }
  }
  stop() {
    __privateGet(this, _clock).stop();
    this.reset();
    if (typeof window !== "undefined" && window.document) {
      window.document.removeEventListener("visibilitychange", this.onVisibilityChange, false);
    }
  }
  tick() {
    if (!__privateGet(this, _animating) || !__privateGet(this, _isVisible))
      return;
    __privateSet(this, _raf, requestAnimationFrame(() => {
      this.tick();
    }));
    __privateGet(this, _callback).call(this);
  }
  onVisibilityChange() {
    if (typeof window !== "undefined" && window.document) {
      __privateSet(this, _isVisible, !window.document.hidden);
    }
    if (__privateGet(this, _isVisible)) {
      this.reset();
      this.start();
    }
  }
};
_raf = new WeakMap();
_animating = new WeakMap();
_isVisible = new WeakMap();
_clock = new WeakMap();
_callback = new WeakMap();
var Event = class {
  constructor(type, params = {}) {
    __publicField(this, "type");
    this.type = type;
    (Object.getOwnPropertyNames(params) || []).forEach((key) => {
      this[key] = params[key];
    });
  }
};
var EventEmitter = class {
  constructor({ validEventTypes = [/.*/] } = {}) {
    __publicField(this, "fns");
    __publicField(this, "validateEventTypes");
    this.fns = /* @__PURE__ */ new Map();
    this.validateEventTypes = validEventTypes;
  }
  validateEventType(type) {
    let vs = this.validateEventTypes;
    if (!Array.isArray(this.validateEventTypes)) {
      vs = [this.validateEventTypes];
    }
    let isValid = true;
    vs.forEach((r2) => {
      if (isRegexp(r2) && !r2.test(type)) {
        isValid = false;
      }
    });
    if (!isValid) {
      throw new Error(`Invalid Event Type: '${type}'.
Event type should be any of: ${vs}.`);
    }
  }
  on(type, handler, context) {
    this.validateEventType(type);
    if (isString(type)) {
      const names = type.split(" ");
      if (names.length > 1) {
        names.forEach((t2) => {
          this.on(t2, handler, context);
        });
        return this;
      }
    }
    if (!this.has(type)) {
      this.fns.set(type, []);
    }
    this.fns.get(type).push(handler);
    return this;
  }
  once(type, handler, context) {
    this.validateEventType(type);
    if (isString(type)) {
      const names = type.split(" ");
      if (names.length > 1) {
        names.forEach((t2) => {
          this.once(t2, handler, context);
        });
        return this;
      }
    }
    const onceHandler = (...args) => {
      this.off(type, onceHandler);
      handler.call(context || this, ...args);
    };
    return this.on(type, onceHandler, context);
  }
  off(type, handler, context) {
    this.validateEventType(type);
    if (isString(type)) {
      const names = type.split(" ");
      if (names.length > 1) {
        names.forEach((t2) => {
          this.off(t2, handler, context);
        });
        return this;
      }
    }
    const handlers = this.has(type);
    if (handlers) {
      if (handler) {
        const fns = handlers.filter((h2) => h2 !== handler);
        this.fns.set(type, fns);
      } else {
        this.fns.delete(type);
      }
    }
    return this;
  }
  emit(type, args) {
    const eventObject = type instanceof Event ? type : new Event(type, args);
    this.validateEventType(eventObject.type);
    const fns = this.has(eventObject.type);
    if (fns) {
      return fns.map((fn) => fn.call(this, eventObject));
    }
  }
  has(type) {
    return this.fns.get(type);
  }
  clear() {
    this.fns.clear();
    return this;
  }
};
var Vector = class {
  constructor() {
    __publicField(this, "elements", new (getFloatArrayConstructor())(2));
  }
  fromArray(array, offset = 0) {
    let i2 = 0;
    for (; i2 < this.elements.length; i2++) {
      this.elements[i2] = array[offset + i2];
    }
    return this;
  }
  toArray(out = [], offset = 0) {
    let i2 = 0;
    for (; i2 < this.elements.length; i2++) {
      out[offset + i2] = this.elements[i2];
    }
    return out;
  }
};
var Vector2 = class _Vector2 extends Vector {
  constructor(x2 = 0, y2 = 0) {
    super();
    __publicField(this, "elements", new (getFloatArrayConstructor())(2));
    const v2 = this.elements;
    v2[0] = x2;
    v2[1] = y2;
  }
  get x() {
    return this.elements[0];
  }
  set x(x2) {
    this.elements[0] = x2;
  }
  get y() {
    return this.elements[1];
  }
  set y(y2) {
    this.elements[1] = y2;
  }
  fromObject(object) {
    const { x: x2, y: y2 } = object;
    if (x2 !== void 0)
      this.x = x2;
    if (y2 !== void 0)
      this.y = y2;
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y
    };
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  setScalar(s2) {
    return this.set(s2, s2);
  }
  add(vec) {
    add5(this.elements, this.elements, vec.elements);
    return this;
  }
  addScalar(v2) {
    add5(this.elements, this.elements, [v2, v2]);
    return this;
  }
  subtract(vec) {
    subtract5(this.elements, this.elements, vec.elements);
    return this;
  }
  subtractScalar(v2) {
    subtract5(this.elements, this.elements, [v2, v2]);
    return this;
  }
  multiply(vec) {
    multiply6(this.elements, this.elements, vec.elements);
    return this;
  }
  multiplyScalar(v2) {
    multiply6(this.elements, this.elements, [v2, v2]);
    return this;
  }
  divide(vec) {
    divide3(this.elements, this.elements, vec.elements);
    return this;
  }
  divideScalar(v2) {
    divide3(this.elements, this.elements, [v2, v2]);
    return this;
  }
  scale(s2) {
    scale5(this.elements, this.elements, s2);
    return this;
  }
  distanceTo(vec) {
    return distance3(this.elements, vec.elements);
  }
  length() {
    return length4(this.elements);
  }
  distanceToSquared(v2) {
    return squaredDistance3(v2.elements, this.elements);
  }
  angle() {
    return angle2(this.elements, [1, 0]);
  }
  angleTo(v2) {
    return angle2(this.elements, v2.elements);
  }
  dot(vec) {
    return dot4(this.elements, vec.elements);
  }
  equals(vec) {
    return equals5(this.elements, vec.elements);
  }
  cross(vec) {
    cross3(this.elements, this.elements, vec.elements);
    return this;
  }
  negate() {
    negate3(this.elements, this.elements);
    return this;
  }
  inverse() {
    inverse3(this.elements, this.elements);
    return this;
  }
  lerp(vec, t2) {
    lerp3(this.elements, this.elements, vec.elements, t2);
    return this;
  }
  normalize() {
    normalize4(this.elements, this.elements);
    return this;
  }
  applyMatrix3(matrix) {
    transformMat32(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyMatrix4(matrix) {
    transformMat43(this.elements, this.elements, matrix.elements);
    return this;
  }
  copy(vec2) {
    this.x = vec2.x;
    this.y = vec2.y;
    return this;
  }
  clone() {
    return new _Vector2(this.x, this.y);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
var tempArray$1 = [];
var _changeCallbacks;
var _Quaternion = class _Quaternion extends Vector {
  constructor(x2 = 0, y2 = 0, z = 0, w2 = 0) {
    super();
    __publicField(this, "elements", new (getFloatArrayConstructor())(4));
    __privateAdd(this, _changeCallbacks, []);
    const v2 = this.elements;
    v2[0] = x2;
    v2[1] = y2;
    v2[2] = z;
    v2[3] = w2;
  }
  get x() {
    return this.elements[0];
  }
  set x(x2) {
    this.elements[0] = x2;
    this.triggerChange();
  }
  get y() {
    return this.elements[1];
  }
  set y(y2) {
    this.elements[1] = y2;
    this.triggerChange();
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
    this.triggerChange();
  }
  get w() {
    return this.elements[3];
  }
  set w(w2) {
    this.elements[3] = w2;
    this.triggerChange();
  }
  fromObject({ x: x2, y: y2, z, w: w2 }) {
    if (x2 !== void 0)
      this.x = x2;
    if (y2 !== void 0)
      this.y = y2;
    if (z !== void 0)
      this.z = z;
    if (w2 !== void 0)
      this.w = w2;
    this.triggerChange();
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
  fromAxisAngle(axis, rad) {
    setAxisAngle(this.elements, axis.elements, rad);
    this.triggerChange();
    return this;
  }
  getAxisAngle(axis = new Vector3()) {
    const rad = getAxisAngle(tempArray$1, this.elements);
    axis.set(tempArray$1[0], tempArray$1[1], tempArray$1[2]);
    return rad;
  }
  fromEuler(e2) {
    fromEuler(this.elements, radToDeg(e2.x), radToDeg(e2.y), radToDeg(e2.z));
    this.triggerChange();
    return this;
  }
  fromMat3(m2) {
    fromMat3(this.elements, m2);
    return this;
  }
  set(x2, y2, z, w2) {
    set5(this.elements, x2, y2, z, w2);
    this.triggerChange();
    return this;
  }
  length() {
    return length3(this.elements);
  }
  multiply(a2, b2) {
    if (b2) {
      multiply5(this.elements, a2.elements, b2.elements);
    } else {
      multiply5(this.elements, this.elements, a2.elements);
    }
    this.triggerChange();
    return this;
  }
  slerp(q, t2) {
    slerp(this.elements, this.elements, q.elements, t2);
    this.triggerChange();
    return this;
  }
  invert() {
    invert3(this.elements, this.elements);
    this.triggerChange();
    return this;
  }
  conjugate() {
    conjugate(this.elements, this.elements);
    this.triggerChange();
    return this;
  }
  normalize() {
    normalize3(this.elements, this.elements);
    this.triggerChange();
    return this;
  }
  dot(q) {
    return dot3(this.elements, q.elements);
  }
  angleTo(q) {
    return getAngle(this.elements, q.elements);
  }
  clone() {
    return new _Quaternion().copy(this);
  }
  copy(q) {
    copy3(this.elements, q.elements);
    this.triggerChange();
    return this;
  }
  equals(q) {
    return equals4(this.elements, q.elements);
  }
  onChange(fn) {
    if (!__privateGet(this, _changeCallbacks).includes(fn)) {
      __privateGet(this, _changeCallbacks).push(fn);
    }
  }
  triggerChange() {
    __privateGet(this, _changeCallbacks).forEach((cb) => cb());
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
_changeCallbacks = new WeakMap();
var Quaternion = _Quaternion;
var Vector3 = class _Vector3 extends Vector {
  constructor(x2 = 0, y2 = 0, z = 0) {
    super();
    __publicField(this, "elements", new (getFloatArrayConstructor())(3));
    const v2 = this.elements;
    v2[0] = x2;
    v2[1] = y2;
    v2[2] = z;
  }
  get x() {
    return this.elements[0];
  }
  set x(x2) {
    this.elements[0] = x2;
  }
  get y() {
    return this.elements[1];
  }
  set y(y2) {
    this.elements[1] = y2;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  fromObject(object) {
    const { x: x2, y: y2, z } = object;
    if (x2 !== void 0)
      this.x = x2;
    if (y2 !== void 0)
      this.y = y2;
    if (z !== void 0)
      this.z = z;
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
  set(x2, y2, z) {
    set3(this.elements, x2, y2, z);
    return this;
  }
  setScalar(s2) {
    return this.set(s2, s2, s2);
  }
  length() {
    return length(this.elements);
  }
  add(vec) {
    add3(this.elements, this.elements, vec.elements);
    return this;
  }
  addScalar(v2) {
    add3(this.elements, this.elements, [v2, v2, v2]);
    return this;
  }
  subtract(vec) {
    subtract3(this.elements, this.elements, vec.elements);
    return this;
  }
  subtractScalar(v2) {
    subtract3(this.elements, this.elements, [v2, v2, v2]);
    return this;
  }
  subVectors(a2, b2) {
    subtract3(this.elements, a2.elements, b2.elements);
    return this;
  }
  multiply(vec) {
    multiply3(this.elements, this.elements, vec.elements);
    return this;
  }
  multiplyScalar(v2) {
    multiply3(this.elements, this.elements, [v2, v2, v2]);
    return this;
  }
  divide(vec) {
    divide(this.elements, this.elements, vec.elements);
    return this;
  }
  divideScalar(v2) {
    divide(this.elements, this.elements, [v2, v2, v2]);
    return this;
  }
  scale(s2) {
    scale3(this.elements, this.elements, s2);
    return this;
  }
  scaleAndAdd(v2, s2) {
    scaleAndAdd(this.elements, this.elements, v2.elements, s2);
    return this;
  }
  distanceTo(vec) {
    return distance(this.elements, vec.elements);
  }
  distanceToSquared(vec) {
    return squaredDistance(this.elements, vec.elements);
  }
  angle(vector) {
    return angle(this.elements, [1, 0, 0]);
  }
  angleTo(vector) {
    return angle(this.elements, vector.elements);
  }
  dot(vec) {
    return dot(this.elements, vec.elements);
  }
  equals(vec) {
    return equals3(this.elements, vec.elements);
  }
  cross(vec) {
    cross(this.elements, this.elements, vec.elements);
    return this;
  }
  negate() {
    negate(this.elements, this.elements);
    return this;
  }
  inverse() {
    inverse(this.elements, this.elements);
    return this;
  }
  lerp(vec, t2) {
    lerp(this.elements, this.elements, vec.elements, t2);
    return this;
  }
  normalize() {
    normalize(this.elements, this.elements);
    return this;
  }
  applyEuler(euler) {
    const e2 = new Quaternion().fromEuler(euler);
    return this.applyQuaternion(e2);
  }
  applyMatrix3(matrix) {
    transformMat3(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyMatrix4(matrix) {
    transformMat4(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyQuaternion(quaternion) {
    transformQuat(this.elements, this.elements, quaternion.elements);
    return this;
  }
  copy(vec3) {
    this.x = vec3.x;
    this.y = vec3.y;
    this.z = vec3.z;
    return this;
  }
  clone() {
    return new _Vector3(this.x, this.y, this.z);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
var Vector4 = class _Vector4 extends Vector {
  constructor(x2 = 0, y2 = 0, z = 0, w2 = 0) {
    super();
    __publicField(this, "elements", new (getFloatArrayConstructor())(4));
    const v2 = this.elements;
    v2[0] = x2;
    v2[1] = y2;
    v2[2] = z;
    v2[3] = w2;
  }
  get x() {
    return this.elements[0];
  }
  set x(x2) {
    this.elements[0] = x2;
  }
  get y() {
    return this.elements[1];
  }
  set y(y2) {
    this.elements[1] = y2;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  get w() {
    return this.elements[3];
  }
  set w(w2) {
    this.elements[3] = w2;
  }
  fromObject(object) {
    const { x: x2, y: y2, z, w: w2 } = object;
    if (x2 !== void 0)
      this.x = x2;
    if (y2 !== void 0)
      this.y = y2;
    if (z !== void 0)
      this.z = z;
    if (w2 !== void 0)
      this.w = w2;
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
  set(x2, y2, z, w2) {
    set4(this.elements, x2, y2, z, w2);
    return this;
  }
  setScalar(s2) {
    return this.set(s2, s2, s2, s2);
  }
  add(vec) {
    add4(this.elements, this.elements, vec.elements);
    return this;
  }
  addScalar(v2) {
    add4(this.elements, this.elements, [v2, v2, v2, v2]);
    return this;
  }
  subtract(vec) {
    subtract4(this.elements, this.elements, vec.elements);
    return this;
  }
  subtractScalar(v2) {
    subtract4(this.elements, this.elements, [v2, v2, v2, v2]);
    return this;
  }
  subVectors(a2, b2) {
    subtract4(this.elements, a2.elements, b2.elements);
    return this;
  }
  multiply(vec) {
    multiply4(this.elements, this.elements, vec.elements);
    return this;
  }
  multiplyScalar(v2) {
    multiply4(this.elements, this.elements, [v2, v2, v2, v2]);
    return this;
  }
  divide(vec) {
    divide2(this.elements, this.elements, vec.elements);
    return this;
  }
  divideScalar(v2) {
    divide2(this.elements, this.elements, [v2, v2, v2, v2]);
    return this;
  }
  scale(s2) {
    scale4(this.elements, this.elements, s2);
    return this;
  }
  scaleAndAdd(v2, s2) {
    scaleAndAdd2(this.elements, this.elements, v2.elements, s2);
    return this;
  }
  distanceTo(vec) {
    return distance2(this.elements, vec.elements);
  }
  distanceToSquared(vec) {
    return squaredDistance2(this.elements, vec.elements);
  }
  length() {
    return length2(this.elements);
  }
  dot(vec) {
    return dot2(this.elements, vec.elements);
  }
  equals(vec) {
    return equals4(this.elements, vec.elements);
  }
  cross(vec) {
    cross2(this.elements, this.elements, vec.elements);
    return this;
  }
  negate() {
    negate2(this.elements, this.elements);
    return this;
  }
  inverse() {
    inverse2(this.elements, this.elements);
    return this;
  }
  lerp(vec, t2) {
    lerp2(this.elements, this.elements, vec.elements, t2);
    return this;
  }
  normalize() {
    normalize2(this.elements, this.elements);
    return this;
  }
  applyMatrix4(matrix) {
    transformMat42(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyQuaternion(quaternion) {
    transformQuat2(this.elements, this.elements, quaternion.elements);
    return this;
  }
  copy(vec4) {
    this.x = vec4.x;
    this.y = vec4.y;
    this.z = vec4.z;
    this.w = vec4.w;
    return this;
  }
  clone() {
    return new _Vector4(this.x, this.y, this.z, this.w);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
var Matrix = class {
  constructor() {
    __publicField(this, "elements", new (getFloatArrayConstructor())(16));
  }
  fromArray(array, offset = 0) {
    let i2 = 0;
    for (; i2 < this.elements.length; i2++) {
      this.elements[i2] = array[offset + i2];
    }
    return this;
  }
  toArray(out = [], offset = 0) {
    let i2 = 0;
    for (; i2 < this.elements.length; i2++) {
      out[offset + i2] = this.elements[i2];
    }
    return out;
  }
};
var Matrix3 = class _Matrix3 extends Matrix {
  constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {
    super();
    __publicField(this, "elements", new (getFloatArrayConstructor())(9));
    const e2 = this.elements;
    e2[0] = m00;
    e2[1] = m01;
    e2[2] = m02;
    e2[3] = m10;
    e2[4] = m11;
    e2[5] = m12;
    e2[6] = m20;
    e2[7] = m21;
    e2[8] = m22;
  }
  get x() {
    return this.elements[2];
  }
  get y() {
    return this.elements[5];
  }
  get z() {
    return this.elements[8];
  }
  static get identity() {
    return new _Matrix3().fromArray(identity([]));
  }
  set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    set(this.elements, m00, m01, m02, m10, m11, m12, m20, m21, m22);
    return this;
  }
  transpose() {
    transpose(this.elements, this.elements);
    return this;
  }
  invert(m2 = this) {
    invert(this.elements, m2.elements);
    return this;
  }
  adjoint(m2 = this) {
    adjoint(this.elements, m2.elements);
    return this;
  }
  determinant() {
    return determinant(this.elements);
  }
  multiply(a2, b2) {
    if (b2) {
      multiply(this.elements, a2.elements, b2.elements);
    } else {
      multiply(this.elements, this.elements, a2.elements);
    }
    return this;
  }
  premultiply(a2, b2) {
    if (b2) {
      multiply(this.elements, b2.elements, a2.elements);
    } else {
      multiply(this.elements, a2.elements, this.elements);
    }
    return this;
  }
  translate(v2) {
    translate(this.elements, this.elements, v2.elements);
    return this;
  }
  rotate(rad) {
    rotate(this.elements, this.elements, rad);
    return this;
  }
  scale(v2) {
    scale(this.elements, this.elements, v2.elements);
    return this;
  }
  fromTranslation(v2) {
    fromTranslation(this.elements, v2.elements);
    return this;
  }
  fromRotation(rad) {
    fromRotation(this.elements, rad);
    return this;
  }
  fromScaling(v2) {
    fromScaling(this.elements, v2.elements);
    return this;
  }
  fromQuat(q) {
    fromQuat(this.elements, q.elements);
    return this;
  }
  normalFromMat4(m2) {
    normalFromMat4(this.elements, m2.elements);
    return this;
  }
  fromMat4(m2) {
    fromMat4(this.elements, m2.elements);
    return this;
  }
  frob() {
    return frob(this.elements);
  }
  add(a2, b2) {
    if (b2) {
      add(this.elements, a2.elements, b2.elements);
    } else {
      add(this.elements, this.elements, a2.elements);
    }
    return this;
  }
  subtract(a2, b2) {
    if (b2) {
      subtract(this.elements, a2.elements, b2.elements);
    } else {
      subtract(this.elements, this.elements, a2.elements);
    }
    return this;
  }
  equals(a2, b2) {
    if (b2) {
      return equals(a2.elements, b2.elements);
    } else {
      return equals(this.elements, a2.elements);
    }
  }
  fromRotationTranslationScale(rotation, x2, y2, scaleX, scaleY) {
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    this.set(scaleX * cos, -scaleY * sin, 0, scaleX * sin, scaleY * cos, 0, x2, y2, 1);
    return this;
  }
  getNormalMatrix(m2) {
    normalFromMat4(this.elements, m2.elements);
    return this;
  }
  copy(m2) {
    copy(this.elements, m2.elements);
    return this;
  }
  clone() {
    return new _Matrix3().copy(this);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
var tempArray = [];
var Matrix4 = class _Matrix4 extends Matrix {
  constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1) {
    super();
    __publicField(this, "elements", new (getFloatArrayConstructor())(16));
    const e2 = this.elements;
    e2[0] = m00;
    e2[1] = m01;
    e2[2] = m02;
    e2[3] = m03;
    e2[4] = m10;
    e2[5] = m11;
    e2[6] = m12;
    e2[7] = m13;
    e2[8] = m20;
    e2[9] = m21;
    e2[10] = m22;
    e2[11] = m23;
    e2[12] = m30;
    e2[13] = m31;
    e2[14] = m32;
    e2[15] = m33;
  }
  get x() {
    return this.elements[12];
  }
  get y() {
    return this.elements[13];
  }
  get z() {
    return this.elements[14];
  }
  get w() {
    return this.elements[15];
  }
  static get identity() {
    return new _Matrix4().fromArray(identity2([]));
  }
  set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    set2(this.elements, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    return this;
  }
  transpose() {
    transpose2(this.elements, this.elements);
    return this;
  }
  invert(m2 = this) {
    invert2(this.elements, m2.elements);
    return this;
  }
  adjoint(m2 = this) {
    adjoint2(this.elements, m2.elements);
    return this;
  }
  determinant() {
    return determinant2(this.elements);
  }
  add(a2, b2) {
    if (b2) {
      add2(this.elements, a2.elements, b2.elements);
    } else {
      add2(this.elements, this.elements, a2.elements);
    }
    return this;
  }
  subtract(a2, b2) {
    if (b2) {
      subtract2(this.elements, a2.elements, b2.elements);
    } else {
      subtract2(this.elements, this.elements, a2.elements);
    }
    return this;
  }
  multiply(a2, b2) {
    if (b2) {
      multiply2(this.elements, a2.elements, b2.elements);
    } else {
      multiply2(this.elements, this.elements, a2.elements);
    }
    return this;
  }
  multiplyScalar(a2 = this, b2) {
    multiplyScalar(this.elements, a2.elements, b2);
    return this;
  }
  premultiply(a2, b2) {
    if (b2) {
      multiply2(this.elements, b2.elements, a2.elements);
    } else {
      multiply2(this.elements, a2.elements, this.elements);
    }
    return this;
  }
  translate(v2) {
    translate2(this.elements, this.elements, v2.elements);
    return this;
  }
  rotate(rad) {
    rotate2(this.elements, this.elements, rad);
    return this;
  }
  scale(vec3) {
    scale2(this.elements, this.elements, vec3.elements);
    return this;
  }
  scaleScalar(s2) {
    scale2(this.elements, this.elements, [s2, s2, s2]);
    return this;
  }
  fromTranslation(vec) {
    fromTranslation2(this.elements, vec.elements);
    return this;
  }
  fromRotation(rad, axis) {
    fromRotation2(this.elements, rad, axis);
    return this;
  }
  fromRotationX(rad) {
    fromXRotation(this.elements, rad);
    return this;
  }
  fromRotationY(rad) {
    fromYRotation(this.elements, rad);
    return this;
  }
  fromRotationZ(rad) {
    fromZRotation(this.elements, rad);
    return this;
  }
  fromScale(vec) {
    fromScaling2(this.elements, vec.elements);
    return this;
  }
  fromRotationTranslation(quat, v2) {
    fromRotationTranslation(this.elements, quat.elements, v2.elements);
    return this;
  }
  fromPerspective(fov, aspect, near, far) {
    perspective(this.elements, degToRad(fov), aspect, near, far);
    return this;
  }
  fromOrthogonal(left, right, bottom, top, near, far) {
    ortho(this.elements, left, right, bottom, top, near, far);
    return this;
  }
  fromQuat(q) {
    fromQuat2(this.elements, q.elements);
    return this;
  }
  equals(mat4) {
    return equals2(this.elements, mat4.value);
  }
  getRotation(q = new Quaternion()) {
    getRotation(tempArray, this.elements);
    q.set(tempArray[0], tempArray[1], tempArray[2], tempArray[3]);
    return q;
  }
  getScale(v2 = new Vector3()) {
    getScaling(tempArray, this.elements);
    v2.set(tempArray[0], tempArray[1], tempArray[2]);
    return v2;
  }
  getTranslation(v2 = new Vector3()) {
    getTranslation(tempArray, this.elements);
    v2.set(tempArray[0], tempArray[1], tempArray[2]);
    return v2;
  }
  rotateX(rad) {
    rotateX(this.elements, this.elements, rad);
    return this;
  }
  rotateY(rad) {
    rotateY(this.elements, this.elements, rad);
    return this;
  }
  rotateZ(rad) {
    rotateZ(this.elements, this.elements, rad);
    return this;
  }
  compose(v2, q, s2) {
    fromRotationTranslationScale(this.elements, q.elements, v2.elements, s2.elements);
    return this;
  }
  decompose() {
    return {
      rotation: this.getRotation(),
      scale: this.getScale(),
      translation: this.getTranslation()
    };
  }
  copy(m2) {
    copy2(this.elements, m2.elements);
    return this;
  }
  clone() {
    return new _Matrix4().copy(this);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
var _changeCallbacks2, _order;
var _Euler = class _Euler extends Vector {
  constructor(x2 = 0, y2 = 0, z = 0, order = "xyz") {
    super();
    __publicField(this, "elements", new (getFloatArrayConstructor())(3));
    __privateAdd(this, _changeCallbacks2, []);
    __privateAdd(this, _order, "xyz");
    const v2 = this.elements;
    v2[0] = x2;
    v2[1] = y2;
    v2[2] = z;
    __privateSet(this, _order, order);
  }
  get x() {
    return this.elements[0];
  }
  set x(x2) {
    this.elements[0] = x2;
    this.triggerChange();
  }
  get y() {
    return this.elements[1];
  }
  set y(y2) {
    this.elements[1] = y2;
    this.triggerChange();
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
    this.triggerChange();
  }
  get order() {
    return __privateGet(this, _order);
  }
  set order(order) {
    __privateSet(this, _order, order);
    this.triggerChange();
  }
  get roll() {
    return this.x;
  }
  set roll(roll) {
    this.x = roll;
  }
  get pitch() {
    return this.y;
  }
  set pitch(pitch) {
    this.y = pitch;
  }
  get yaw() {
    return this.z;
  }
  set yaw(yaw) {
    this.z = yaw;
  }
  fromObject({ x: x2, y: y2, z, order }) {
    if (x2 !== void 0) {
      this.x = x2;
    }
    if (y2 !== void 0) {
      this.y = y2;
    }
    if (z !== void 0) {
      this.z = z;
    }
    if (order !== void 0) {
      this.order = order;
    }
    this.triggerChange();
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      order: this.order
    };
  }
  fromRotationMatrix(m2, order = __privateGet(this, _order), update = true) {
    const te = m2.toArray();
    const m11 = te[0];
    const m12 = te[4];
    const m13 = te[8];
    const m21 = te[1];
    const m22 = te[5];
    const m23 = te[9];
    const m31 = te[2];
    const m32 = te[6];
    const m33 = te[10];
    switch (order) {
      case "xyz":
        this.y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this.x = Math.atan2(-m23, m33);
          this.z = Math.atan2(-m12, m11);
        } else {
          this.x = Math.atan2(m32, m22);
          this.z = 0;
        }
        break;
      case "yxz":
        this.x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this.y = Math.atan2(m13, m33);
          this.z = Math.atan2(m21, m22);
        } else {
          this.y = Math.atan2(-m31, m11);
          this.z = 0;
        }
        break;
      case "zxy":
        this.x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this.y = Math.atan2(-m31, m33);
          this.z = Math.atan2(-m12, m22);
        } else {
          this.y = 0;
          this.z = Math.atan2(m21, m11);
        }
        break;
      case "zyx":
        this.y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this.x = Math.atan2(m32, m33);
          this.z = Math.atan2(m21, m11);
        } else {
          this.x = 0;
          this.z = Math.atan2(-m12, m22);
        }
        break;
      case "yzx":
        this.z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this.x = Math.atan2(-m23, m22);
          this.y = Math.atan2(-m31, m11);
        } else {
          this.x = 0;
          this.y = Math.atan2(m13, m33);
        }
        break;
      case "xzy":
        this.z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this.x = Math.atan2(m32, m22);
          this.y = Math.atan2(m13, m11);
        } else {
          this.x = Math.atan2(-m23, m33);
          this.y = 0;
        }
        break;
      default:
        throw new Error("Unknown Euler angle order");
    }
    __privateSet(this, _order, order);
    if (update) {
      this.triggerChange();
    }
    return this;
  }
  fromQuaternion(q) {
    const [x2, y2, z, w2] = q.elements;
    const a2 = y2 * y2;
    const s2 = -2 * (a2 + z * z) + 1;
    const o2 = 2 * (x2 * y2 + w2 * z);
    let l2 = -2 * (x2 * z - w2 * y2);
    const c2 = 2 * (y2 * z + w2 * x2);
    const h2 = -2 * (x2 * x2 + a2) + 1;
    l2 = l2 > 1 ? 1 : l2;
    l2 = l2 < -1 ? -1 : l2;
    const d2 = Math.atan2(c2, h2);
    const u2 = Math.asin(l2);
    const f2 = Math.atan2(o2, s2);
    return new _Euler(d2, u2, f2, "zyx");
  }
  fromVector3(vec3, order = __privateGet(this, _order)) {
    return this.set(vec3.x, vec3.y, vec3.z, order);
  }
  toQuaternion() {
    const t2 = Math.cos(0.5 * this.yaw);
    const e2 = Math.sin(0.5 * this.yaw);
    const n2 = Math.cos(0.5 * this.roll);
    const r2 = Math.sin(0.5 * this.roll);
    const i2 = Math.cos(0.5 * this.pitch);
    const a2 = Math.sin(0.5 * this.pitch);
    return new Quaternion(
      t2 * r2 * i2 - e2 * n2 * a2,
      t2 * n2 * a2 + e2 * r2 * i2,
      e2 * n2 * i2 - t2 * r2 * a2,
      t2 * n2 * i2 + e2 * r2 * a2
    );
  }
  toVector3() {
    return new Vector3(this.x, this.y, this.z);
  }
  set(x2, y2, z, order = __privateGet(this, _order)) {
    this.elements[0] = x2;
    this.elements[1] = y2;
    this.elements[2] = z;
    __privateSet(this, _order, order);
    this.triggerChange();
    return this;
  }
  clone() {
    return new _Euler().copy(this);
  }
  copy(euler) {
    let i2 = 0;
    for (; i2 < this.elements.length; i2++) {
      this.elements[i2] = euler.elements[i2];
    }
    __privateSet(this, _order, euler.order);
    this.triggerChange();
    return this;
  }
  equals(e2) {
    return this.x === e2.x && this.y === e2.y && this.z === e2.z && this.order === e2.order;
  }
  onChange(cb) {
    if (!__privateGet(this, _changeCallbacks2).includes(cb)) {
      __privateGet(this, _changeCallbacks2).push(cb);
    }
  }
  triggerChange() {
    __privateGet(this, _changeCallbacks2).forEach((f2) => f2());
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
_changeCallbacks2 = new WeakMap();
_order = new WeakMap();
var Euler = _Euler;
function namesPlugin(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2) r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2) return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
k([namesPlugin]);
var normalize5 = (a2, min, max) => {
  const hex = isHex(a2);
  const diff = max - min;
  let v2 = clamp(Number.parseFloat(`${a2}`), min, max);
  if (hex) {
    v2 = Number.parseInt("" + a2 * max, 10) / 100;
  }
  return Math.abs(v2 - max) < 1e-6 ? 1 : a2 % diff / diff;
};
var Color = class {
  constructor(v2 = 255, g2, b2, a2 = 1, isNormalized = false) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = 1;
    this.g = 1;
    this.b = 1;
    this.a = 1;
    if (isUndef(g2) && isUndef(b2)) {
      if (isNumber(v2) && v2 <= 255) {
        this.setRGBA(v2, v2, v2, this.a, isNormalized);
      } else {
        const rgb = w(v2).toRgb();
        if (rgb) {
          this.setRGBA(rgb.r, rgb.g, rgb.b, rgb.a);
        } else {
          console.error("Unsupported color value {".concat(String(v2), "} provided"));
        }
      }
    } else {
      this.setRGBA(v2, g2, b2, a2);
    }
  }
  fromColor(c2) {
    const color = w(c2).toRgb();
    return this.setRGBA(color.r, color.g, color.b, color.a);
  }
  fromHSL(h2, s2, l2, a2 = 1) {
    const color = w({
      h: h2,
      s: s2,
      l: l2,
      a: a2
    }).toRgb();
    return this.setRGBA(color.r, color.g, color.b, color.a);
  }
  fromHSV(h2, s2, v2, a2 = 1) {
    const color = w({
      h: h2,
      s: s2,
      v: v2,
      a: a2
    }).toRgb();
    return this.setRGBA(color.r, color.g, color.b, color.a);
  }
  setRGB(r2, g2, b2) {
    this.setRGBA(r2, g2, b2, this.a);
    return this;
  }
  setRGBA(r2, g2, b2, a2, isNormalized) {
    this.r = isNormalized ? r2 : normalize5(r2, 0, 255);
    this.g = isNormalized ? g2 : normalize5(g2, 0, 255);
    this.b = isNormalized ? b2 : normalize5(b2, 0, 255);
    this.setAlpha(a2);
    return this;
  }
  setAlpha(alpha) {
    if (alpha > 1) {
      this.a = normalize5(alpha, 0, 255);
    } else {
      this.a = alpha;
    }
    return this;
  }
  toHex() {
    return w(this.toObject()).toHex();
  }
  toHSL() {
    return w(this.toObject()).toHsl();
  }
  toHSV() {
    return w(this.toObject()).toHsv();
  }
  toObject(isNormalized = false) {
    const m2 = isNormalized ? 1 : 255;
    return {
      r: this.r * m2,
      g: this.g * m2,
      b: this.b * m2,
      a: this.a
    };
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toVector() {
    return new Vector4().fromArray(this.toArray());
  }
  toVector3() {
    return new Vector3().fromArray(this.toArray());
  }
  toString() {
    return `${this.constructor.name}(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
  }
};
var ProjectionMatrix = class extends Matrix4 {
  frustum(mat4, left, right, top, bottom, near, far) {
    frustum(mat4.elements, left, right, bottom, top, near, far);
    return this;
  }
  orthographic(left, right, top, bottom, near, far) {
    ortho(this.elements, left, right, bottom, top, near, far);
    return this;
  }
  perspective(fovy, aspect, near, far) {
    perspective(this.elements, fovy, aspect, near, far);
    return this;
  }
  lookAt(eye, target = new Vector3(0, 0, 0), up = new Vector3(0, 1, 0)) {
    lookAt(this.elements, eye.elements, target.elements, up.elements);
    return this;
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
};
var Object3D = class _Object3D {
  constructor() {
    __publicField(this, "visible");
    __publicField(this, "localMatrix");
    __publicField(this, "worldMatrix");
    __publicField(this, "matrixAutoUpdate");
    __publicField(this, "position");
    __publicField(this, "scale");
    __publicField(this, "rotation");
    __publicField(this, "quaternion");
    __publicField(this, "up");
    __publicField(this, "children");
    __publicField(this, "parent");
    __publicField(this, "worldMatrixNeedsUpdate");
    this.visible = true;
    this.localMatrix = new ProjectionMatrix();
    this.worldMatrix = new ProjectionMatrix();
    this.matrixAutoUpdate = true;
    this.position = new Vector3();
    this.scale = new Vector3(1, 1, 1);
    this.rotation = new Euler();
    this.quaternion = new Quaternion();
    this.up = new Vector3(0, 1, 0);
    this.parent = null;
    this.children = [];
    this.worldMatrixNeedsUpdate = false;
    this.rotation.onChange(() => {
      this.quaternion.fromEuler(this.rotation);
    });
    this.quaternion.onChange(() => {
      this.rotation.fromQuaternion(this.quaternion);
    });
  }
  add(object, notifyChild = true) {
    if (!this.contains(object)) {
      this.children.push(object);
    }
    if (notifyChild) {
      object.setParent(this, false);
    }
  }
  remove(object, notifyChild = true) {
    if (this.contains(object)) {
      this.children.splice(this.children.indexOf(object), 1);
    }
    if (notifyChild) {
      object.setParent(null, false);
    }
  }
  contains(object) {
    return this.children.includes(object);
  }
  setParent(object, notifyParent = true) {
    if (this.parent && object !== this.parent) {
      this.parent.remove(this, false);
    }
    this.parent = object;
    if (notifyParent && object) {
      object.add(this, false);
    }
  }
  traverse(callback) {
    if (!callback(this)) {
      for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
        this.children[i2].traverse(callback);
      }
    }
  }
  lookAt(eye, invert4) {
    if (invert4) {
      this.localMatrix.lookAt(this.position, eye, this.up);
    } else {
      this.localMatrix.lookAt(eye, this.position, this.up);
    }
    this.localMatrix.getRotation(this.quaternion);
    this.rotation.fromQuaternion(this.quaternion);
  }
  updateMatrixWorld(force) {
    let f2 = force;
    if (this.matrixAutoUpdate) {
      this.updateMatrix();
    }
    if (this.worldMatrixNeedsUpdate || f2) {
      if (this.parent === null) {
        this.worldMatrix.copy(this.localMatrix);
      } else {
        this.worldMatrix.multiply(this.parent.worldMatrix, this.localMatrix);
      }
      this.worldMatrixNeedsUpdate = false;
      f2 = true;
    }
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      child.updateMatrixWorld(f2);
    }
  }
  updateMatrix() {
    this.localMatrix.compose(this.position, this.quaternion, this.scale);
    this.worldMatrixNeedsUpdate = true;
  }
  decompose() {
    this.localMatrix.getTranslation(this.position);
    this.localMatrix.getRotation(this.quaternion);
    this.localMatrix.getScale(this.scale);
    this.rotation.fromQuaternion(this.quaternion);
  }
  clone() {
    return new _Object3D().copy(this, false);
  }
  copy(object, recursive) {
    this.visible = object.visible;
    this.position.copy(object.position);
    this.scale.copy(object.scale);
    this.rotation.copy(object.rotation);
    this.quaternion.copy(object.quaternion);
    this.up.copy(object.up);
    this.localMatrix.copy(object.localMatrix);
    this.worldMatrix.copy(object.worldMatrix);
    this.matrixAutoUpdate = object.matrixAutoUpdate;
    if (recursive) {
      for (let i2 = 0, n2 = object.children.length; i2 < n2; i2++) {
        const children = object.children[i2];
        this.add(children.clone());
      }
    }
    return this;
  }
};
var Base = class {
  constructor(renderer) {
    __publicField(this, "renderer");
    this.renderer = renderer;
  }
  get gl() {
    return this.renderer.gl;
  }
  get rendererState() {
    return this.renderer.state;
  }
};
var getBufferType = (gl, data) => {
  if (data instanceof Float32Array || data instanceof Float64Array) {
    return gl.FLOAT;
  }
  if (data instanceof Uint16Array) {
    return gl.UNSIGNED_SHORT;
  }
  if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return gl.UNSIGNED_BYTE;
  }
  if (data instanceof Uint32Array) {
    return gl.UNSIGNED_INT;
  }
  if (data instanceof Int8Array) {
    return gl.BYTE;
  }
  if (data instanceof Int16Array) {
    return gl.SHORT;
  }
  if (data instanceof Int32Array) {
    return gl.INT;
  }
};
var BufferAttribute = class {
  constructor(renderer, attribute) {
    __publicField(this, "id");
    __publicField(this, "data");
    __publicField(this, "type");
    __publicField(this, "size");
    __publicField(this, "instanced");
    __publicField(this, "stride");
    __publicField(this, "offset");
    __publicField(this, "divisor");
    __publicField(this, "normalized");
    __publicField(this, "needsUpdate");
    __publicField(this, "count");
    __publicField(this, "usage");
    __publicField(this, "target");
    __publicField(this, "buffer");
    const attr = Object.assign(
      {},
      {
        size: 1,
        normalized: true,
        stride: 0,
        offset: 0,
        divisor: 0,
        usage: renderer.gl.STATIC_DRAW
      },
      attribute
    );
    this.id = uid("attribute");
    this.needsUpdate = false;
    if (!attribute.data || Array.isArray(attribute.data)) {
      throw new TypeError("BufferAttribute: data should be a typed array");
    }
    this.data = attr.data;
    this.size = attr.size || 1;
    this.type = attr.type || getBufferType(renderer.gl, attr.data);
    this.normalized = attr.normalized || false;
    this.stride = attr.stride || 0;
    this.offset = attr.offset || 0;
    this.divisor = attr.divisor || 0;
    this.instanced = attr.divisor > 0;
    this.usage = attr.usage || renderer.gl.STATIC_DRAW;
    if (attr.target) {
      this.target = attr.target;
    }
    let count = attr.count;
    if (attr.count === void 0 || attr.count === null) {
      count = attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size;
    }
    this.count = count;
  }
};
var tempVec3 = new Vector3();
var _id, _attributes, _VAOs, _bounds;
var _Geometry = class _Geometry extends Base {
  constructor(renderer, attributes = {}) {
    super(renderer);
    __privateAdd(this, _id);
    __privateAdd(this, _attributes);
    __privateAdd(this, _VAOs);
    __privateAdd(this, _bounds);
    __publicField(this, "drawRange");
    __publicField(this, "instancedCount");
    __publicField(this, "isInstanced");
    __publicField(this, "drawMode");
    this.drawRange = {
      start: 0,
      count: 0
    };
    this.instancedCount = 0;
    this.isInstanced = false;
    __privateSet(this, _attributes, /* @__PURE__ */ new Map());
    __privateSet(this, _VAOs, /* @__PURE__ */ new Map());
    __privateSet(this, _id, uid("geometry"));
    this.drawMode = this.gl.TRIANGLES;
    renderer.bindVertexArray(null);
    renderer.state.setActiveGeometry(null);
    for (const name in attributes) {
      const attribute = attributes[name];
      if (attribute instanceof BufferAttribute) {
        if (name === "index") {
          this.setIndex(attribute);
        } else {
          this.addAttribute(name, attribute);
        }
      } else {
        if (attribute.data) {
          const n2 = new BufferAttribute(this.renderer, attribute);
          if (name === "index") {
            this.setIndex(n2);
          } else {
            this.addAttribute(name, n2);
          }
        }
      }
    }
  }
  get id() {
    return __privateGet(this, _id);
  }
  get attributes() {
    return __privateGet(this, _attributes);
  }
  get attributesData() {
    const attributes = {};
    const iterator = __privateGet(this, _attributes).entries();
    for (let i2 = 0; i2 < __privateGet(this, _attributes).size; i2++) {
      const entry = iterator.next().value;
      attributes[entry[0]] = omit(entry[1], [
        "id",
        "buffer"
      ]);
    }
    return attributes;
  }
  get index() {
    return this.attributes.get("index");
  }
  get bounds() {
    return __privateGet(this, _bounds);
  }
  set bounds(bounds) {
    __privateSet(this, _bounds, bounds);
  }
  addAttribute(name, attribute) {
    if (!attribute.target) {
      attribute.target = name === "index" ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;
    }
    attribute.needsUpdate = false;
    this.attributes.set(name, attribute);
    if (!attribute.buffer) {
      attribute.buffer = this.gl.createBuffer();
      this.updateAttribute(attribute);
    }
    if (attribute.divisor) {
      this.isInstanced = true;
      if (this.instancedCount && this.instancedCount !== attribute.count * attribute.divisor) {
        this.instancedCount = Math.min(this.instancedCount, attribute.count * attribute.divisor);
        return console.warn(
          `Geometry has multiple instanced buffers of different length - instancedCount: ${this.instancedCount}, count: ${attribute.count}, divisor: ${attribute.divisor}, attribute: ${name}`
        );
      }
      this.instancedCount = attribute.count * attribute.divisor;
    } else if (name === "index") {
      this.drawRange.count = attribute.count;
    } else if (!this.index) {
      this.drawRange.count = Math.max(this.drawRange.count, attribute.count);
    }
  }
  getAttribute(name) {
    return this.attributes.get(name);
  }
  setAttributeData(name, data) {
    const attribute = this.getAttribute(name);
    if (attribute) {
      attribute.data = data;
      attribute.needsUpdate = true;
    }
  }
  updateAttribute(attribute) {
    const createBuffer = !attribute.buffer;
    if (createBuffer) {
      attribute.buffer = this.gl.createBuffer();
    }
    if (this.rendererState.boundBuffer !== attribute.buffer) {
      this.gl.bindBuffer(attribute.target, attribute.buffer);
      this.rendererState.boundBuffer = attribute.buffer;
    }
    this.gl.bufferData(attribute.target, attribute.data, attribute.usage);
    attribute.needsUpdate = false;
  }
  removeAttribute(attribute) {
    this.attributes.delete(attribute);
  }
  setIndex(index2) {
    var _a;
    if (index2 instanceof BufferAttribute) {
      index2.size = 1;
      this.addAttribute("index", index2);
    } else {
      const buffer = new BufferAttribute(this.renderer, {
        data: index2.length > 65535 ? new Uint32Array(index2) : new Uint16Array(index2),
        size: 1
      });
      this.addAttribute("index", buffer);
    }
    this.drawRange.count = (_a = this.index) == null ? void 0 : _a.count;
  }
  setVertices(data) {
    const array = [];
    const len = data.length;
    for (let i2 = 0; i2 < len; i2++) {
      const item = data[i2];
      array.push(item[0], item[1], item[2]);
    }
    this.addAttribute(
      "position",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(array),
        size: 3
      })
    );
  }
  setNormals(data) {
    this.addAttribute(
      "normal",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(data),
        size: 2
      })
    );
  }
  setUVs(data) {
    this.addAttribute(
      "uv",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(data),
        size: 2
      })
    );
  }
  setColors(colors) {
    const data = [];
    for (let i2 = 0; i2 < colors.length; i2++) {
      let color = colors[i2];
      if (color && (color instanceof Vector3 || color instanceof Vector4)) {
        color = color.toArray();
      }
      data.push(color[0], color[1], color[2], color[3] || 1);
    }
    this.addAttribute(
      "color",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(data),
        size: 4
      })
    );
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  setInstancedCount(count) {
    this.instancedCount = count;
  }
  createVAO(program) {
    const { attributeOrder } = program;
    const vao = this.renderer.createVertexArray();
    this.renderer.bindVertexArray(vao);
    __privateGet(this, _VAOs).set(attributeOrder, vao);
    this.bindAttributes(program);
  }
  bindAttributes(program) {
    program.attributeLocations.forEach((location, { name, type }) => {
      const attributes = this.attributes.get(name);
      if (!attributes)
        return;
      this.gl.bindBuffer(attributes.target, attributes.buffer);
      this.rendererState.boundBuffer = attributes.buffer;
      let numLoc = 1;
      if (type === this.gl.FLOAT_MAT2)
        numLoc = 2;
      if (type === this.gl.FLOAT_MAT3)
        numLoc = 3;
      if (type === this.gl.FLOAT_MAT4)
        numLoc = 4;
      const size = attributes.size / numLoc;
      const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;
      const offset = numLoc === 1 ? 0 : numLoc * numLoc;
      for (let i2 = 0; i2 < numLoc; i2++) {
        const attribIndex = location + i2;
        this.gl.vertexAttribPointer(
          attribIndex,
          size,
          attributes.type,
          attributes.normalized,
          attributes.stride + stride,
          attributes.offset + offset
        );
        this.gl.enableVertexAttribArray(attribIndex);
        this.renderer.vertexAttribDivisor(attribIndex, attributes.divisor);
      }
    });
    const index2 = this.attributes.get("index");
    if (index2) {
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, index2.buffer);
    }
  }
  computeBoundingBox(vertices) {
    const { data, offset = 0, stride, size } = this.attributes.get("position");
    if (!__privateGet(this, _bounds)) {
      __privateSet(this, _bounds, {
        min: new Vector3(),
        max: new Vector3(),
        center: new Vector3(),
        scale: new Vector3(),
        radius: Number.POSITIVE_INFINITY
      });
    }
    __privateGet(this, _bounds).min.setScalar(+Number.POSITIVE_INFINITY);
    __privateGet(this, _bounds).max.setScalar(Number.NEGATIVE_INFINITY);
    const array = vertices || data;
    const dl = stride || size;
    for (let i2 = offset; i2 < array.length; i2 += dl) {
      const x2 = array[i2 + 0];
      const y2 = array[i2 + 1];
      const z = array[i2 + 2];
      __privateGet(this, _bounds).min.x = Math.min(x2, __privateGet(this, _bounds).min.x);
      __privateGet(this, _bounds).min.y = Math.min(y2, __privateGet(this, _bounds).min.y);
      __privateGet(this, _bounds).min.z = Math.min(z, __privateGet(this, _bounds).min.z);
      __privateGet(this, _bounds).max.x = Math.max(x2, __privateGet(this, _bounds).max.x);
      __privateGet(this, _bounds).max.y = Math.max(y2, __privateGet(this, _bounds).max.y);
      __privateGet(this, _bounds).max.z = Math.max(z, __privateGet(this, _bounds).max.z);
    }
    __privateGet(this, _bounds).scale.subVectors(__privateGet(this, _bounds).max, __privateGet(this, _bounds).min);
    __privateGet(this, _bounds).center.add(__privateGet(this, _bounds).min).add(__privateGet(this, _bounds).max).divideScalar(2);
    return __privateGet(this, _bounds);
  }
  computeBoundingSphere(vertices) {
    const { data, offset = 0, stride, size } = this.attributes.get("position");
    if (!__privateGet(this, _bounds)) {
      this.computeBoundingBox(vertices);
    }
    const array = vertices || data;
    let len = 0;
    const dl = stride || size;
    const length5 = array.length;
    for (let j2 = offset; j2 < length5; j2 += dl) {
      tempVec3.fromArray(array, j2);
      len = Math.max(len, __privateGet(this, _bounds).center.distanceToSquared(tempVec3));
    }
    __privateGet(this, _bounds).radius = Math.sqrt(len);
  }
  draw(program, drawMode = this.drawMode) {
    const { start, count } = this.drawRange;
    const activeGeometryId = `${this.id}_${program.attributeOrder}`;
    if (this.rendererState.activeGeometryId !== activeGeometryId) {
      const vao = __privateGet(this, _VAOs).get(program.attributeOrder);
      if (!vao) {
        this.createVAO(program);
      }
      this.renderer.bindVertexArray(__privateGet(this, _VAOs).get(program.attributeOrder));
      this.rendererState.activeGeometryId = activeGeometryId;
    }
    program.attributeLocations.forEach((location, { name }) => {
      const attribute = this.getAttribute(name);
      if (attribute && attribute.needsUpdate) {
        this.updateAttribute(attribute);
      }
    });
    if (this.isInstanced) {
      if (this.index) {
        const offset = this.index.offset + 2 * start;
        this.renderer.drawElementsInstanced(
          drawMode,
          count,
          this.index.type,
          offset,
          this.instancedCount
        );
      } else {
        this.renderer.drawArraysInstanced(drawMode, start, count, this.instancedCount);
      }
    } else if (this.index) {
      const offset = this.index.offset + 2 * start;
      this.gl.drawElements(drawMode, count, this.index.type, offset);
    } else {
      this.gl.drawArrays(drawMode, start, count);
    }
  }
  copy(source) {
    const attributes = source.attributesData;
    for (const name in attributes) {
      const attribute = attributes[name];
      if (attribute instanceof BufferAttribute) {
        if (name === "index") {
          this.setIndex(attribute);
        } else {
          this.addAttribute(name, attribute);
        }
      } else {
        if (attribute.data) {
          const n2 = new BufferAttribute(this.renderer, attribute);
          if (name === "index") {
            this.setIndex(n2);
          } else {
            this.addAttribute(name, n2);
          }
        }
      }
    }
    if (source.bounds) {
      this.bounds = {
        min: new Vector3().copy(source.bounds.min),
        max: new Vector3().copy(source.bounds.max),
        center: new Vector3().copy(source.bounds.center),
        scale: new Vector3().copy(source.bounds.scale),
        radius: source.bounds.radius
      };
    }
    return this;
  }
  clone() {
    const geometry = new _Geometry(this.renderer, {}).copy(this);
    geometry.drawMode = this.drawMode;
    return geometry;
  }
  destroy() {
    __privateGet(this, _VAOs).forEach((t2) => {
      this.renderer.deleteVertexArray(t2);
    });
    __privateGet(this, _VAOs).clear();
    __privateGet(this, _attributes).forEach((t2) => {
      this.gl.deleteBuffer(t2.buffer);
    });
    __privateGet(this, _attributes).clear();
  }
};
_id = new WeakMap();
_attributes = new WeakMap();
_VAOs = new WeakMap();
_bounds = new WeakMap();
var Geometry = _Geometry;
var _id2, _lastMode, _geometry, _program, _wireframe, _wireframeGeometry;
var _Mesh = class _Mesh extends Object3D {
  constructor(renderer, options = {}) {
    super();
    __publicField(this, "gl");
    __publicField(this, "modelViewMatrix");
    __publicField(this, "normalMatrix");
    __publicField(this, "renderOrder");
    __publicField(this, "zDepth");
    __publicField(this, "frustumCulled");
    __publicField(this, "mode");
    __publicField(this, "renderer");
    __privateAdd(this, _id2);
    __privateAdd(this, _lastMode);
    __privateAdd(this, _geometry);
    __privateAdd(this, _program);
    __privateAdd(this, _wireframe);
    __privateAdd(this, _wireframeGeometry);
    const opts = Object.assign({}, {
      mode: renderer.gl.TRIANGLES,
      frustumCulled: true,
      renderOrder: 0
    }, options);
    this.renderer = renderer;
    this.gl = this.renderer.gl;
    this.modelViewMatrix = new Matrix4();
    this.normalMatrix = new Matrix3();
    this.renderOrder = opts.renderOrder;
    this.frustumCulled = opts.frustumCulled;
    this.zDepth = 0;
    __privateSet(this, _id2, opts.id || uid("mesh"));
    __privateSet(this, _geometry, opts.geometry);
    __privateSet(this, _program, opts.program);
    __privateSet(this, _wireframe, Boolean(opts.wireframe));
    this.mode = opts.mode;
    __privateSet(this, _lastMode, opts.mode);
    if (__privateGet(this, _wireframe)) {
      this.mode = this.gl.LINES;
      this.updateWireframeGeometry(__privateGet(this, _wireframe));
    }
  }
  get id() {
    return __privateGet(this, _id2);
  }
  get geometry() {
    return __privateGet(this, _wireframe) ? __privateGet(this, _wireframeGeometry) : __privateGet(this, _geometry);
  }
  get program() {
    return __privateGet(this, _program);
  }
  set wireframe(wireframe) {
    this.mode = wireframe ? this.gl.LINES : __privateGet(this, _lastMode);
    __privateSet(this, _wireframe, wireframe);
    this.updateWireframeGeometry(__privateGet(this, _wireframe));
  }
  get wireframe() {
    return __privateGet(this, _wireframe);
  }
  draw(options = {}) {
    var _a, _b, _c, _d;
    const { camera, target } = options;
    const uniforms = {};
    if (camera) {
      Object.assign(uniforms, {
        projectionMatrix: camera.projectionMatrix,
        cameraPosition: camera.worldPosition,
        viewMatrix: camera.viewMatrix
      });
      this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);
      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);
    } else {
      this.modelViewMatrix.copy(this.worldMatrix);
    }
    Object.assign(uniforms, {
      resolution: new Vector2(
        ((_b = (_a = this.renderer.state) == null ? void 0 : _a.viewport) == null ? void 0 : _b.width) || 1,
        ((_d = (_c = this.renderer.state) == null ? void 0 : _c.viewport) == null ? void 0 : _d.height) || 1
      ),
      modelMatrix: this.worldMatrix,
      modelViewMatrix: this.modelViewMatrix,
      normalMatrix: this.normalMatrix
    });
    Object.keys(uniforms).forEach((key) => {
      if (!Object.hasOwn(this.program.uniforms, key)) {
        this.program.uniforms[key] = { value: null };
      }
      this.program.uniforms[key].value = uniforms[key];
    });
    if (target)
      target.bind();
    this.program.use();
    this.geometry.draw(this.program, this.mode);
    if (target)
      target.unbind();
  }
  updateWireframeGeometry(wireframe, force = false) {
    var _a, _b;
    if (__privateGet(this, _geometry) && (force || !__privateGet(this, _wireframeGeometry))) {
      if (__privateGet(this, _wireframeGeometry)) {
        __privateGet(this, _wireframeGeometry).destroy();
      }
      const attributes = __privateGet(this, _geometry).attributes;
      const positionArray = (_a = attributes.get("position")) == null ? void 0 : _a.data;
      const indexAttribute = (_b = __privateGet(this, _geometry).index) == null ? void 0 : _b.data;
      const numIndices = indexAttribute ? indexAttribute.length : Math.floor(positionArray.length / 3);
      const index2 = [];
      if (__privateGet(this, _geometry).index) {
        if (indexAttribute) {
          getWireframeIndex(positionArray, index2, numIndices, indexAttribute);
        }
      } else {
        getWireframeIndex(positionArray, index2, numIndices);
      }
      const indices = index2.length > 65536 ? new Uint32Array(index2) : new Uint16Array(index2);
      __privateSet(this, _wireframeGeometry, new Geometry(this.renderer, {
        ...__privateGet(this, _geometry).attributesData,
        index: {
          data: indices
        }
      }));
    }
  }
  updateGeometry(geometry, destroy = true) {
    if (destroy && __privateGet(this, _geometry)) {
      __privateGet(this, _geometry).destroy();
    }
    __privateSet(this, _geometry, geometry);
    this.updateWireframeGeometry(__privateGet(this, _wireframe), true);
  }
  updateProgram(program, destroy = true) {
    if (destroy && __privateGet(this, _program)) {
      __privateGet(this, _program).destroy();
    }
    __privateSet(this, _program, program);
  }
  destroy() {
    this.program.destroy();
    this.geometry.destroy();
  }
  clone() {
    return new _Mesh(this.gl, {
      geometry: this.geometry,
      program: this.program,
      frustumCulled: this.frustumCulled,
      mode: this.mode,
      renderOrder: this.renderOrder
    }).copy(this);
  }
  copy(mesh, recursive = true) {
    super.copy(mesh, recursive);
    this.modelViewMatrix.copy(mesh.modelViewMatrix);
    this.normalMatrix.copy(mesh.normalMatrix);
    this.mode = mesh.mode;
    this.renderOrder = mesh.renderOrder;
    this.zDepth = mesh.zDepth;
    return this;
  }
};
_id2 = new WeakMap();
_lastMode = new WeakMap();
_geometry = new WeakMap();
_program = new WeakMap();
_wireframe = new WeakMap();
_wireframeGeometry = new WeakMap();
var Mesh = _Mesh;
var Scene = class _Scene extends Object3D {
  clone() {
    return new _Scene().copy(this, false);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
};
var BlendType = ((BlendType2) => {
  BlendType2[BlendType2["NoBlending"] = 0] = "NoBlending";
  BlendType2[BlendType2["NormalBlending"] = 1] = "NormalBlending";
  BlendType2[BlendType2["AdditiveBlending"] = 2] = "AdditiveBlending";
  BlendType2[BlendType2["SubtractiveBlending"] = 3] = "SubtractiveBlending";
  BlendType2[BlendType2["MultiplyBlending"] = 4] = "MultiplyBlending";
  BlendType2[BlendType2["CustomBlending"] = 5] = "CustomBlending";
  return BlendType2;
})(BlendType || {});
var _state;
var State = class extends Base {
  constructor(renderer, options) {
    super(renderer);
    __privateAdd(this, _state);
    const { gl } = renderer;
    __privateSet(this, _state, {
      viewport: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    });
    this.apply(
      options || {
        frontFace: gl.CCW,
        depthTest: false,
        depthWrite: true,
        depthMask: true,
        depthFunc: gl.LESS,
        blending: 1,
        blendFunc: {
          src: gl.ONE,
          dst: gl.ZERO
        },
        blendEquation: {
          modeRGB: gl.FUNC_ADD
        },
        premultiplyAlpha: false,
        unpackAlignment: 4,
        flipY: false,
        framebuffer: null,
        textureUnits: [],
        activeTextureUnit: -1,
        activeGeometryId: -1,
        currentProgramId: -1,
        clearAlpha: 1,
        clearColor: new Color(0),
        stencil: {
          func: {},
          opFront: {},
          opBack: {}
        }
      }
    );
  }
  get state() {
    return __privateGet(this, _state);
  }
  get viewport() {
    return __privateGet(this, _state).viewport;
  }
  get textureUnits() {
    return __privateGet(this, _state).textureUnits;
  }
  get activeTextureUnit() {
    return __privateGet(this, _state).activeTextureUnit;
  }
  set activeTextureUnit(activeTextureUnit) {
    __privateGet(this, _state).activeTextureUnit = activeTextureUnit;
  }
  get currentProgramId() {
    return __privateGet(this, _state).currentProgramId;
  }
  set currentProgramId(id) {
    __privateGet(this, _state).currentProgramId = id;
  }
  get activeGeometryId() {
    return __privateGet(this, _state).activeGeometryId;
  }
  set activeGeometryId(id) {
    __privateGet(this, _state).activeGeometryId = id;
  }
  set flipY(flipY) {
    __privateGet(this, _state).flipY = flipY;
  }
  get flipY() {
    return __privateGet(this, _state).flipY;
  }
  set unpackAlignment(unpackAlignment) {
    __privateGet(this, _state).unpackAlignment = unpackAlignment;
  }
  get unpackAlignment() {
    return __privateGet(this, _state).unpackAlignment;
  }
  set premultiplyAlpha(premultiplyAlpha) {
    __privateGet(this, _state).premultiplyAlpha = premultiplyAlpha;
  }
  get premultiplyAlpha() {
    return __privateGet(this, _state).premultiplyAlpha;
  }
  set boundBuffer(boundBuffer) {
    __privateGet(this, _state).boundBuffer = boundBuffer;
  }
  get boundBuffer() {
    return __privateGet(this, _state).boundBuffer;
  }
  set anisotropy(anisotropy) {
    __privateGet(this, _state).anisotropy = anisotropy;
  }
  get anisotropy() {
    return __privateGet(this, _state).anisotropy;
  }
  apply(options) {
    if (options.blending !== void 0 && options.blending !== null) {
      this.setBlending(options.blending, options);
    } else {
      if (options.blendFunc) {
        const { src, dst, srcAlpha, dstAlpha } = options.blendFunc;
        this.setBlendFunc(src, dst, srcAlpha, dstAlpha);
        this.enable(this.gl.BLEND);
      } else {
        this.disable(this.gl.BLEND);
      }
      if (options.blendEquation) {
        const { modeRGB, modeAlpha } = options.blendEquation;
        this.setBlendEquation(modeRGB, modeAlpha);
      }
    }
    if (!isUndef(options.cullFace) && !isNull(options.cullFace)) {
      this.setCullFace(options.cullFace);
    }
    if (!isUndef(options.frontFace) && !isNull(options.frontFace)) {
      this.setFrontFace(options.frontFace);
    }
    if (options.depthTest) {
      this.enable(this.gl.DEPTH_TEST);
    } else {
      this.disable(this.gl.DEPTH_TEST);
    }
    if (!isUndef(options.depthMask) && !isNull(options.depthMask)) {
      this.setDepthMask(options.depthMask);
    }
    if (!isUndef(options.depthWrite) && !isNull(options.depthWrite)) {
      this.setDepthMask(options.depthWrite);
    }
    if (!isUndef(options.depthFunc) && !isNull(options.depthFunc)) {
      this.setDepthFunc(options.depthFunc);
    }
    if (!isUndef(options.lineWidth) && !isNull(options.lineWidth)) {
      this.setLineWidth(options.lineWidth);
    }
    __privateSet(this, _state, Object.assign(__privateGet(this, _state), options));
  }
  enable(id) {
    if (__privateGet(this, _state)[id] !== true) {
      this.gl.enable(id);
      __privateGet(this, _state)[id] = true;
    }
  }
  disable(id) {
    if (__privateGet(this, _state)[id] !== false) {
      this.gl.disable(id);
      __privateGet(this, _state)[id] = false;
    }
  }
  setViewport(width, height, x2 = 0, y2 = 0) {
    if (__privateGet(this, _state).viewport.width === width && __privateGet(this, _state).viewport.height === height)
      return;
    this.gl.viewport(x2, y2, width, height);
    __privateGet(this, _state).viewport = {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  setMask(colorMask) {
    if (__privateGet(this, _state).colorMask !== colorMask) {
      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
      __privateGet(this, _state).colorMask = colorMask;
    }
  }
  setBlending(blending, options) {
    __privateGet(this, _state).blending = blending;
    if (blending === 0) {
      this.disable(this.gl.BLEND);
      return;
    } else {
      this.enable(this.gl.BLEND);
    }
    if (blending === 2) {
      if (__privateGet(this, _state).premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ONE, this.gl.ONE, this.gl.ONE, this.gl.ONE);
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
      }
    } else if (blending === 3) {
      if (__privateGet(this, _state).premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(
          this.gl.ZERO,
          this.gl.ZERO,
          this.gl.ONE_MINUS_SRC_COLOR,
          this.gl.ONE_MINUS_SRC_ALPHA
        );
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ZERO, this.gl.ONE_MINUS_SRC_COLOR);
      }
    } else if (blending === 4) {
      if (__privateGet(this, _state).premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ZERO, this.gl.SRC_COLOR, this.gl.ZERO, this.gl.SRC_ALPHA);
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ZERO, this.gl.SRC_COLOR);
      }
    } else if (blending === 1) {
      if (__privateGet(this, _state).premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(
          this.gl.ONE,
          this.gl.ONE_MINUS_SRC_ALPHA,
          this.gl.ONE,
          this.gl.ONE_MINUS_SRC_ALPHA
        );
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(
          this.gl.SRC_ALPHA,
          this.gl.ONE_MINUS_SRC_ALPHA,
          this.gl.ONE,
          this.gl.ONE_MINUS_SRC_ALPHA
        );
      }
    } else if (blending === 5) {
      if (options == null ? void 0 : options.blendFunc) {
        const { src, dst, srcAlpha, dstAlpha } = options.blendFunc;
        this.setBlendFunc(src, dst, srcAlpha, dstAlpha);
        this.enable(this.gl.BLEND);
      }
      if (options == null ? void 0 : options.blendEquation) {
        const { modeRGB, modeAlpha } = options.blendEquation;
        this.setBlendEquation(modeRGB, modeAlpha);
      }
    } else {
      console.error("State: Invalid blending: ", blending);
    }
  }
  setBlendFunc(src, dst, srcAlpha, dstAlpha) {
    var _a, _b, _c, _d;
    if (src !== ((_a = __privateGet(this, _state).blendFunc) == null ? void 0 : _a.src) || dst !== ((_b = __privateGet(this, _state).blendFunc) == null ? void 0 : _b.dst) || srcAlpha !== ((_c = __privateGet(this, _state).blendFunc) == null ? void 0 : _c.srcAlpha) || dstAlpha !== ((_d = __privateGet(this, _state).blendFunc) == null ? void 0 : _d.dstAlpha)) {
      __privateGet(this, _state).blendFunc = {
        src,
        dst,
        srcAlpha,
        dstAlpha
      };
      if (!isUndef(srcAlpha) && !isNull(srcAlpha) && !isUndef(dstAlpha) && !isNull(dstAlpha)) {
        this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);
      } else {
        this.gl.blendFunc(src, dst);
      }
    }
  }
  setBlendEquation(modeRGB, modeAlpha) {
    var _a, _b;
    if (modeRGB !== ((_a = __privateGet(this, _state).blendEquation) == null ? void 0 : _a.modeRGB) || modeAlpha !== ((_b = __privateGet(this, _state).blendEquation) == null ? void 0 : _b.modeAlpha)) {
      __privateGet(this, _state).blendEquation = {
        modeRGB,
        modeAlpha
      };
      if (!isUndef(modeAlpha) && !isNull(modeAlpha)) {
        this.gl.blendEquationSeparate(modeRGB, modeAlpha);
      } else {
        this.gl.blendEquation(modeRGB);
      }
    }
  }
  setClearAlpha(alpha) {
    if (__privateGet(this, _state).clearAlpha !== alpha) {
      __privateGet(this, _state).clearAlpha = alpha;
    }
  }
  setClearColor(color, alpha) {
    if (__privateGet(this, _state).clearAlpha !== alpha || __privateGet(this, _state).clearColor !== color) {
      __privateGet(this, _state).clearColor = color;
      if (!isUndef(alpha) && !isNull(alpha)) {
        __privateGet(this, _state).clearAlpha = alpha;
      } else {
        __privateGet(this, _state).clearAlpha = color.a;
      }
      this.gl.clearColor(color.r, color.g, color.b, __privateGet(this, _state).clearAlpha);
    }
  }
  setCullFace(cullFace) {
    if (__privateGet(this, _state).cullFace !== cullFace) {
      if (cullFace) {
        this.gl.enable(this.gl.CULL_FACE);
      } else {
        this.gl.disable(this.gl.CULL_FACE);
      }
      __privateGet(this, _state).cullFace = cullFace;
      this.gl.cullFace(cullFace);
    }
  }
  setFrontFace(frontFace) {
    if (__privateGet(this, _state).frontFace !== frontFace) {
      __privateGet(this, _state).frontFace = frontFace;
      this.gl.frontFace(frontFace);
    }
  }
  setDepthMask(mask) {
    if (__privateGet(this, _state).depthMask !== mask) {
      __privateGet(this, _state).depthMask = mask;
      this.gl.depthMask(mask);
    }
  }
  setDepthFunc(func) {
    if (__privateGet(this, _state).depthFunc !== func) {
      __privateGet(this, _state).depthFunc = func;
      this.gl.depthFunc(func);
    }
  }
  setDepthTest(state) {
    if (__privateGet(this, _state).depthTest !== state) {
      __privateGet(this, _state).depthTest = state;
      if (state) {
        this.enable(this.gl.DEPTH_TEST);
      } else {
        this.disable(this.gl.DEPTH_TEST);
      }
    }
  }
  setStencilFunc(cmp, ref, mask, face) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (((_c = (_b = (_a = __privateGet(this, _state)) == null ? void 0 : _a.stencil) == null ? void 0 : _b.func) == null ? void 0 : _c.cmp) !== cmp || ((_f = (_e = (_d = __privateGet(this, _state)) == null ? void 0 : _d.stencil) == null ? void 0 : _e.func) == null ? void 0 : _f.ref) !== ref || ((_i = (_h = (_g = __privateGet(this, _state)) == null ? void 0 : _g.stencil) == null ? void 0 : _h.func) == null ? void 0 : _i.mask) !== mask) {
      if (!((_j = __privateGet(this, _state)) == null ? void 0 : _j.stencil)) {
        __privateGet(this, _state).stencil = {};
      }
      if (!((_l = (_k = __privateGet(this, _state)) == null ? void 0 : _k.stencil) == null ? void 0 : _l.func)) {
        __privateGet(this, _state).stencil.func = {};
      }
      __privateGet(this, _state).stencil.func = {
        ref,
        mask,
        cmp
      };
      if (face) {
        this.gl.stencilFuncSeparate(face, cmp, ref, mask);
      } else {
        this.gl.stencilFunc(cmp, ref, mask);
      }
    }
  }
  setStencilOp(fail, zFail, zPass, face) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    if (!((_a = __privateGet(this, _state)) == null ? void 0 : _a.stencil)) {
      __privateGet(this, _state).stencil = {};
    }
    if (!face || face === this.gl.FRONT_AND_BACK) {
      return ((_c = (_b = __privateGet(this, _state).stencil) == null ? void 0 : _b.opFront) == null ? void 0 : _c.fail) !== fail || ((_e = (_d = __privateGet(this, _state).stencil) == null ? void 0 : _d.opFront) == null ? void 0 : _e.zFail) !== zFail || ((_g = (_f = __privateGet(this, _state).stencil) == null ? void 0 : _f.opFront) == null ? void 0 : _g.zPass) !== zPass || ((_i = (_h = __privateGet(this, _state).stencil) == null ? void 0 : _h.opBack) == null ? void 0 : _i.fail) !== fail || ((_k = (_j = __privateGet(this, _state).stencil) == null ? void 0 : _j.opBack) == null ? void 0 : _k.zFail) !== zFail || ((_m = (_l = __privateGet(this, _state).stencil) == null ? void 0 : _l.opBack) == null ? void 0 : _m.zPass) !== zPass;
    } else if (face === this.gl.FRONT) {
      return ((_o = (_n = __privateGet(this, _state).stencil) == null ? void 0 : _n.opFront) == null ? void 0 : _o.fail) !== fail || ((_q = (_p = __privateGet(this, _state).stencil) == null ? void 0 : _p.opFront) == null ? void 0 : _q.zFail) !== zFail || ((_s = (_r = __privateGet(this, _state).stencil) == null ? void 0 : _r.opFront) == null ? void 0 : _s.zPass) !== zPass;
    } else if (face === this.gl.BACK) {
      return ((_u = (_t = __privateGet(this, _state).stencil) == null ? void 0 : _t.opBack) == null ? void 0 : _u.fail) !== fail || ((_w = (_v = __privateGet(this, _state).stencil) == null ? void 0 : _v.opBack) == null ? void 0 : _w.zFail) !== zFail || ((_y = (_x = __privateGet(this, _state).stencil) == null ? void 0 : _x.opBack) == null ? void 0 : _y.zPass) !== zPass;
    }
  }
  setStencilMask(mask, face) {
    var _a;
    if (((_a = __privateGet(this, _state).stencil) == null ? void 0 : _a.mask) !== mask) {
      __privateGet(this, _state).stencil = {
        ...__privateGet(this, _state).stencil,
        mask
      };
      if (face) {
        this.gl.stencilMaskSeparate(face, mask);
      } else {
        this.gl.stencilMask(mask);
      }
    }
  }
  setActiveTexture(unit) {
    if (__privateGet(this, _state).activeTextureUnit !== unit) {
      __privateGet(this, _state).activeTextureUnit = unit;
      this.gl.activeTexture(this.gl.TEXTURE0 + unit);
    }
  }
  setLineWidth(width) {
    if (__privateGet(this, _state).lineWidth !== width) {
      __privateGet(this, _state).lineWidth = width;
      this.gl.lineWidth(width);
    }
  }
  setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      this.enable(this.gl.POLYGON_OFFSET_FILL);
      if (__privateGet(this, _state).polygonOffsetFactor !== factor || __privateGet(this, _state).polygonOffsetUnits !== units) {
        this.gl.polygonOffset(factor, units);
        __privateGet(this, _state).polygonOffsetFactor = factor;
        __privateGet(this, _state).polygonOffsetUnits = units;
      }
    } else {
      this.disable(this.gl.POLYGON_OFFSET_FILL);
    }
  }
  bindFramebuffer(v2 = {}) {
    const { target = this.gl.FRAMEBUFFER, buffer = null } = v2;
    if (__privateGet(this, _state).framebuffer !== buffer) {
      __privateGet(this, _state).framebuffer = buffer;
      this.gl.bindFramebuffer(target, buffer);
    }
  }
  setActiveGeometry(id) {
    __privateGet(this, _state).activeGeometryId = id;
  }
  reset(force = true) {
    const keys = Object.keys(__privateGet(this, _state));
    if (force) {
      keys.filter((key) => ["viewport", "premultiplyAlpha"].indexOf(key) < 0).forEach((key) => {
        delete __privateGet(this, _state)[key];
      });
      this.bindFramebuffer({
        buffer: null
      });
      this.apply({
        frontFace: this.gl.CCW,
        depthTest: false,
        depthWrite: true,
        depthMask: true,
        depthFunc: this.gl.LESS,
        blending: 1,
        blendFunc: {
          src: this.gl.ONE,
          dst: this.gl.ZERO
        },
        blendEquation: {
          modeRGB: this.gl.FUNC_ADD
        },
        premultiplyAlpha: false,
        unpackAlignment: 4,
        flipY: false,
        framebuffer: null,
        textureUnits: [],
        activeTextureUnit: -1,
        activeGeometryId: -1,
        currentProgramId: -1,
        clearAlpha: 1,
        clearColor: new Color(0),
        stencil: {
          func: {},
          opFront: {},
          opBack: {}
        }
      });
    } else {
      keys.filter(
        (key) => [
          "flipY",
          "framebuffer",
          "textureUnits",
          "activeTextureUnit",
          "activeGeometryId",
          "currentProgramId"
        ].indexOf(key) > -1
      ).forEach((key) => {
        delete __privateGet(this, _state)[key];
      });
      this.bindFramebuffer({
        buffer: null
      });
      __privateGet(this, _state).flipY = false;
      __privateGet(this, _state).activeGeometryId = -1;
      __privateGet(this, _state).activeTextureUnit = -1;
      __privateGet(this, _state).currentProgramId = -1;
      __privateGet(this, _state).textureUnits = [];
      __privateGet(this, _state).boundBuffer = null;
    }
  }
};
_state = new WeakMap();
var external1ExtensionKeys = [
  "WEBGL_depth_texture",
  "OES_texture_half_float",
  "OES_texture_float",
  "OES_standard_derivatives",
  "OES_element_index_uint",
  "EXT_frag_depth",
  "EXT_blend_minmax",
  "EXT_shader_texture_lod",
  "WEBGL_draw_buffers",
  "WEBGL_color_buffer_float"
];
var external2ExtensionKeys = [
  "EXT_color_buffer_float"
];
var external12ExtensionKeys = [
  "WEBGL_lose_context",
  "OES_texture_half_float_linear",
  "OES_texture_float_linear",
  "EXT_color_buffer_half_float",
  "WEBGL_debug_renderer_info",
  "EXT_texture_filter_anisotropic"
];
var _gl, _state2, _extensions, _autoClear, _depth, _alpha, _stencil, _antialias, _premultipliedAlpha, _preserveDrawingBuffer, _color, _dpr, _frustumCull;
var Renderer = class {
  constructor(gl, opts = {}) {
    __privateAdd(this, _gl);
    __privateAdd(this, _state2);
    __privateAdd(this, _extensions);
    __privateAdd(this, _autoClear);
    __privateAdd(this, _depth);
    __privateAdd(this, _alpha);
    __privateAdd(this, _stencil);
    __privateAdd(this, _antialias);
    __privateAdd(this, _premultipliedAlpha);
    __privateAdd(this, _preserveDrawingBuffer);
    __privateAdd(this, _color);
    __privateAdd(this, _dpr);
    __privateAdd(this, _frustumCull);
    __publicField(this, "vertexAttribDivisor");
    __publicField(this, "drawArraysInstanced");
    __publicField(this, "drawElementsInstanced");
    __publicField(this, "createVertexArray");
    __publicField(this, "bindVertexArray");
    __publicField(this, "deleteVertexArray");
    __publicField(this, "width");
    __publicField(this, "height");
    var _a, _b, _c;
    const options = Object.assign(
      {},
      {
        autoClear: true,
        depth: true,
        alpha: false,
        stencil: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        requestWebGl2: true,
        extensions: []
      },
      opts
    );
    __privateSet(this, _autoClear, Boolean(options.autoClear));
    __privateSet(this, _depth, options.depth);
    __privateSet(this, _alpha, options.alpha);
    __privateSet(this, _stencil, options.stencil);
    __privateSet(this, _antialias, options.antialias);
    __privateSet(this, _premultipliedAlpha, options.premultipliedAlpha);
    __privateSet(this, _preserveDrawingBuffer, options.preserveDrawingBuffer);
    __privateSet(this, _gl, isWebGL(gl) || isWebGL2(gl) ? gl : getContext(
      gl,
      {
        alpha: __privateGet(this, _alpha),
        depth: __privateGet(this, _depth),
        stencil: __privateGet(this, _stencil),
        antialias: __privateGet(this, _antialias),
        powerPreference: options.powerPreference,
        premultipliedAlpha: __privateGet(this, _premultipliedAlpha),
        preserveDrawingBuffer: __privateGet(this, _preserveDrawingBuffer)
      },
      options.requestWebGl2
    ));
    const attrs = (_a = __privateGet(this, _gl)) == null ? void 0 : _a.getContextAttributes();
    const viewport = (_b = __privateGet(this, _gl)) == null ? void 0 : _b.getParameter(__privateGet(this, _gl).VIEWPORT);
    const flipY = (_c = __privateGet(this, _gl)) == null ? void 0 : _c.getParameter(__privateGet(this, _gl).UNPACK_FLIP_Y_WEBGL);
    __privateSet(this, _state2, new State(this));
    if (attrs) {
      __privateSet(this, _depth, Boolean(attrs.depth));
      __privateSet(this, _antialias, Boolean(attrs.antialias));
      __privateSet(this, _alpha, Boolean(attrs.alpha));
      __privateSet(this, _stencil, Boolean(attrs.stencil));
      __privateSet(this, _premultipliedAlpha, Boolean(attrs.premultipliedAlpha));
      __privateSet(this, _preserveDrawingBuffer, Boolean(attrs.preserveDrawingBuffer));
    }
    __privateGet(this, _state2).flipY = Boolean(flipY);
    __privateGet(this, _state2).setViewport(viewport[2], viewport[3], viewport[0], viewport[1]);
    __privateGet(this, _state2).premultiplyAlpha = __privateGet(this, _premultipliedAlpha);
    __privateSet(this, _color, true);
    __privateSet(this, _dpr, options.dpr || 1);
    this.width = this.gl.canvas.width / __privateGet(this, _dpr);
    this.height = this.gl.canvas.height / __privateGet(this, _dpr);
    __privateSet(this, _frustumCull, !!options.frustumCull);
    __privateSet(this, _extensions, {});
    this.vertexAttribDivisor = this.getExtension(
      "ANGLE_instanced_arrays",
      "vertexAttribDivisor",
      "vertexAttribDivisorANGLE"
    );
    this.drawArraysInstanced = this.getExtension(
      "ANGLE_instanced_arrays",
      "drawArraysInstanced",
      "drawArraysInstancedANGLE"
    );
    this.drawElementsInstanced = this.getExtension(
      "ANGLE_instanced_arrays",
      "drawElementsInstanced",
      "drawElementsInstancedANGLE"
    );
    this.createVertexArray = this.getExtension(
      "OES_vertex_array_object",
      "createVertexArray",
      "createVertexArrayOES"
    );
    this.bindVertexArray = this.getExtension(
      "OES_vertex_array_object",
      "bindVertexArray",
      "bindVertexArrayOES"
    );
    this.deleteVertexArray = this.getExtension(
      "OES_vertex_array_object",
      "deleteVertexArray",
      "deleteVertexArrayOES"
    );
    if (options.extensions) {
      options.extensions.filter(
        (extension) => external1ExtensionKeys.findIndex((ext) => ext === extension) > -1
      ).forEach((extension) => {
        if (!__privateGet(this, _extensions)[extension] && !this.isWebGL2) {
          __privateGet(this, _extensions)[extension] = this.gl.getExtension(extension);
        }
      });
      options.extensions.filter(
        (extension) => external2ExtensionKeys.findIndex((ext) => ext === extension) > -1
      ).forEach((extension) => {
        if (!__privateGet(this, _extensions)[extension] && this.isWebGL2) {
          __privateGet(this, _extensions)[extension] = this.gl.getExtension(extension);
        }
      });
      options.extensions.filter(
        (extension) => external12ExtensionKeys.findIndex((ext) => ext === extension) > -1
      ).forEach((extension) => {
        if (!__privateGet(this, _extensions)[extension]) {
          __privateGet(this, _extensions)[extension] = this.gl.getExtension(extension);
        }
      });
    }
  }
  get gl() {
    return __privateGet(this, _gl);
  }
  get attributes() {
    return {
      dpr: __privateGet(this, _dpr),
      flipY: __privateGet(this, _state2).flipY,
      depth: __privateGet(this, _depth),
      color: __privateGet(this, _color),
      antialias: __privateGet(this, _antialias),
      alpha: __privateGet(this, _alpha),
      stencil: __privateGet(this, _stencil),
      autoClear: __privateGet(this, _autoClear),
      frustumCull: __privateGet(this, _frustumCull),
      premultipliedAlpha: __privateGet(this, _premultipliedAlpha),
      preserveDrawingBuffer: __privateGet(this, _preserveDrawingBuffer)
    };
  }
  get canvas() {
    return __privateGet(this, _gl).canvas;
  }
  get isWebGL() {
    return isWebGL(this.gl);
  }
  get isWebGL2() {
    return isWebGL2(this.gl);
  }
  get extensions() {
    return __privateGet(this, _extensions);
  }
  extension(key) {
    return __privateGet(this, _extensions)[key];
  }
  get size() {
    return {
      width: "clientWidth" in this.canvas ? this.canvas.clientWidth : this.canvas.width,
      height: "clientHeight" in this.canvas ? this.canvas.clientHeight : this.canvas.height
    };
  }
  get state() {
    return __privateGet(this, _state2);
  }
  get premultipliedAlpha() {
    return __privateGet(this, _premultipliedAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.gl.canvas.width = width * __privateGet(this, _dpr);
    this.gl.canvas.height = height * __privateGet(this, _dpr);
  }
  setViewport(width, height, x2 = 0, y2 = 0) {
    __privateGet(this, _state2).setViewport(width, height, x2, y2);
  }
  getExtension(extension, method, extFunc) {
    const func = this.gl[method];
    if (method && func)
      return func.bind(this.gl);
    if (!__privateGet(this, _extensions)[extension]) {
      __privateGet(this, _extensions)[extension] = this.gl.getExtension(extension);
    }
    const ef = __privateGet(this, _extensions)[extension];
    return method ? ef ? ef[extFunc].bind(ef) : null : ef;
  }
  getRenderList({ scene, camera }) {
    const renderList = [];
    scene.traverse((node) => {
      if (!node.visible)
        return true;
      if (!node.draw)
        return;
      if (__privateGet(this, _frustumCull) && node.frustumCulled && camera) {
        if (!camera.frustumIntersectsMesh(node))
          return;
      }
      renderList.push(node);
    });
    return renderList;
  }
  render(params) {
    const { scene, camera, target = null, update = true, clear } = params;
    if (target === null) {
      __privateGet(this, _state2).bindFramebuffer({
        buffer: null
      });
      this.setViewport(this.width * __privateGet(this, _dpr), this.height * __privateGet(this, _dpr));
    } else {
      target.bind();
      this.setViewport(target.width, target.height);
    }
    if (clear || __privateGet(this, _autoClear) && clear !== false) {
      if (__privateGet(this, _depth) && (!target || target.depth)) {
        __privateGet(this, _state2).enable(this.gl.DEPTH_TEST);
        __privateGet(this, _state2).setDepthMask(true);
      }
      this.clear(__privateGet(this, _color), __privateGet(this, _depth), __privateGet(this, _stencil));
    }
    if (update)
      scene.updateMatrixWorld();
    if (camera)
      camera.updateMatrixWorld();
    const renderList = this.getRenderList({ scene, camera });
    let i2 = 0;
    const len = renderList.length;
    for (; i2 < len; i2++) {
      const node = renderList[i2];
      node.draw({ camera });
    }
    if (target) {
      target.unbind();
    }
  }
  clear(color = __privateGet(this, _color), depth = __privateGet(this, _depth), stencil = __privateGet(this, _stencil)) {
    let bits = 0;
    if (color)
      bits |= this.gl.COLOR_BUFFER_BIT;
    if (depth)
      bits |= this.gl.DEPTH_BUFFER_BIT;
    if (stencil)
      bits |= this.gl.STENCIL_BUFFER_BIT;
    this.gl.clear(bits);
  }
  resetState(force = true, vao = null) {
    __privateGet(this, _state2).reset(force);
    this.bindVertexArray(vao);
  }
};
_gl = new WeakMap();
_state2 = new WeakMap();
_extensions = new WeakMap();
_autoClear = new WeakMap();
_depth = new WeakMap();
_alpha = new WeakMap();
_stencil = new WeakMap();
_antialias = new WeakMap();
_premultipliedAlpha = new WeakMap();
_preserveDrawingBuffer = new WeakMap();
_color = new WeakMap();
_dpr = new WeakMap();
_frustumCull = new WeakMap();
var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
var _handle, _lastHandle;
var Resource = class extends Base {
  constructor(renderer, options = {}) {
    super(renderer);
    __privateAdd(this, _handle);
    __privateAdd(this, _lastHandle);
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "userData");
    __publicField(this, "byteLength");
    __publicField(this, "options");
    this.id = (options == null ? void 0 : options.id) || uid(this.constructor.name);
    this.name = options == null ? void 0 : options.name;
    this.userData = options == null ? void 0 : options.userData;
    __privateSet(this, _handle, options == null ? void 0 : options.handle);
    this.options = options;
    if (__privateGet(this, _handle) === void 0) {
      __privateSet(this, _handle, this.createHandle());
    }
    this.byteLength = 0;
  }
  get handle() {
    return __privateGet(this, _handle);
  }
  swapHandle(handle) {
    __privateSet(this, _lastHandle, __privateGet(this, _handle));
    __privateSet(this, _handle, handle);
  }
  restoreHandle() {
    __privateSet(this, _handle, __privateGet(this, _lastHandle));
  }
  destroy() {
    this.delete();
  }
  delete({ deleteChildren = false } = {}) {
    const children = this.handle && this.deleteHandle(this.handle);
    if (this.handle) {
      this.removeStats();
    }
    __privateSet(this, _handle, null);
    if (children && deleteChildren) {
      children.filter(Boolean).forEach((child) => child.delete());
    }
    return this;
  }
  bind(funcOrHandle = this.handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  unbind() {
    this.bind(null);
  }
  removeStats() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  toString() {
    return `${this.constructor.name}(${this.id})`;
  }
};
_handle = new WeakMap();
_lastHandle = new WeakMap();
var _internalFormat;
var RenderBuffer = class extends Resource {
  constructor(renderer, options = {}) {
    super(renderer, {
      ...options,
      format: options.format || renderer.gl.DEPTH_COMPONENT16
    });
    __publicField(this, "width");
    __publicField(this, "height");
    __privateAdd(this, _internalFormat);
    __privateSet(this, _internalFormat, this.options.format);
    this.width = this.options.width;
    this.height = this.options.height;
    console.assert(
      this.width > 0 && this.height > 0,
      "Renderbuffer object requires valid width and height greater than zero"
    );
    this.bind();
    renderer.gl.renderbufferStorage(
      renderer.gl.RENDERBUFFER,
      __privateGet(this, _internalFormat),
      this.width,
      this.height
    );
  }
  resize(width, height) {
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.bind();
    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, __privateGet(this, _internalFormat), width, height);
    this.unbind();
  }
  bind() {
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.handle);
  }
  unbind() {
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
  }
  removeStats() {
  }
  destroy() {
    this.unbind();
    this.deleteHandle();
  }
  createHandle() {
    return this.gl.createRenderbuffer();
  }
  deleteHandle() {
    this.handle && this.gl.deleteRenderbuffer(this.handle);
  }
};
_internalFormat = new WeakMap();
var emptyPixel = new Uint8Array(4);
var _state3;
var Texture = class extends Resource {
  constructor(renderer, options = {}, needsUpdate = true) {
    const { gl } = renderer;
    const defaultOptions2 = {
      target: gl.TEXTURE_2D,
      type: gl.UNSIGNED_BYTE,
      format: gl.RGBA,
      internalFormat: options.format || gl.RGBA,
      wrapS: gl.CLAMP_TO_EDGE,
      wrapT: gl.CLAMP_TO_EDGE,
      generateMipmaps: true,
      minFilter: gl.LINEAR,
      magFilter: gl.LINEAR,
      premultiplyAlpha: false,
      unpackAlignment: 4,
      anisotropy: 0,
      flipY: false,
      level: 0
    };
    const opt = Object.assign({}, defaultOptions2, options);
    super(renderer, opt);
    __publicField(this, "needsUpdate", false);
    __publicField(this, "textureUnit", 0);
    __publicField(this, "image");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "target");
    __privateAdd(this, _state3, {});
    this.textureUnit = 0;
    this.image = this.options.image;
    this.width = this.options.width;
    this.height = this.options.height;
    this.target = this.options.target;
    __privateGet(this, _state3).version = -1;
    this.needsUpdate = Boolean(needsUpdate);
    if (this.needsUpdate) {
      this.update();
    }
  }
  setData(image, width = this.width, height = this.height) {
    this.image = image;
    this.width = width;
    this.height = height;
    this.needsUpdate = true;
  }
  setOptions(options) {
    this.options = Object.assign(this.options, options);
    this.width = this.options.width;
    this.height = this.options.height;
    this.needsUpdate = true;
  }
  fromSrc(url) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => {
        this.setData(image, image.width, image.height);
        resolve(this);
      };
      image.onerror = (e2) => {
        reject(e2);
      };
      image.crossOrigin = "*";
      image.src = url;
    });
  }
  update(units = 0) {
    const needUpdate = !(this.image === __privateGet(this, _state3).image && !this.needsUpdate);
    const checked = needUpdate || this.rendererState.textureUnits[units] !== this.id || this.rendererState.activeTextureUnit !== units;
    if (checked) {
      this.rendererState.setActiveTexture(units);
      this.bind(units);
    }
    if (!needUpdate)
      return;
    this.needsUpdate = false;
    if (this.options.wrapS !== __privateGet(this, _state3).wrapS) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.options.wrapS);
      __privateGet(this, _state3).wrapS = this.options.wrapS;
    }
    if (this.options.wrapT !== __privateGet(this, _state3).wrapT) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.options.wrapT);
      __privateGet(this, _state3).wrapT = this.options.wrapT;
    }
    if (this.options.minFilter !== __privateGet(this, _state3).minFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MIN_FILTER,
        this.options.minFilter
      );
      __privateGet(this, _state3).minFilter = this.options.minFilter;
    }
    if (this.options.magFilter !== __privateGet(this, _state3).magFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MAG_FILTER,
        this.options.magFilter
      );
      __privateGet(this, _state3).magFilter = this.options.magFilter;
    }
    if (this.options.flipY !== this.rendererState.flipY) {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.options.flipY);
      this.rendererState.flipY = this.options.flipY;
    }
    if (this.options.premultiplyAlpha !== this.rendererState.premultiplyAlpha) {
      this.gl.pixelStorei(
        this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        this.options.premultiplyAlpha
      );
      this.rendererState.premultiplyAlpha = this.options.premultiplyAlpha;
    }
    if (this.options.unpackAlignment !== this.rendererState.unpackAlignment) {
      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.options.unpackAlignment);
      this.rendererState.unpackAlignment = this.options.unpackAlignment;
    }
    if (this.options.anisotropy && this.options.anisotropy !== this.rendererState.anisotropy) {
      const extTextureFilterAnisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
      if (extTextureFilterAnisotropic) {
        const max = this.gl.getParameter(
          extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
        );
        let v2 = this.options.anisotropy;
        if (this.options.anisotropy > max) {
          v2 = max;
          console.warn(
            `[Texture]: Texture.anisotropy option exceeded the maximum allowed value ${max} of the device`
          );
        }
        this.gl.texParameterf(
          this.target,
          extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          v2
        );
      }
      this.rendererState.anisotropy = this.options.anisotropy;
    }
    if (this.image) {
      if (this.image.width) {
        this.width = this.image.width;
        this.height = this.image.height;
      }
      if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
        this.gl.texImage2D(
          this.target,
          this.options.level,
          this.options.internalFormat,
          this.width,
          this.height,
          0,
          this.options.format,
          this.options.type,
          this.image,
          this.options.offset
        );
      } else {
        if (ArrayBuffer.isView(this.image)) {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            0,
            this.options.format,
            this.options.type,
            this.image
          );
        } else {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.options.format,
            this.options.type,
            this.image
          );
        }
      }
      if (this.options.generateMipmaps) {
        if (this.renderer.isWebGL2 || isPowerOfTwo(this.image.width) && isPowerOfTwo(this.image.height)) {
          this.gl.generateMipmap(this.target);
        } else {
          this.options.generateMipmaps = false;
          this.options.wrapS = this.gl.CLAMP_TO_EDGE;
          this.options.wrapT = this.options.wrapS;
          this.options.minFilter = this.gl.LINEAR;
        }
      }
    } else {
      if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
        if (this.width > 0) {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            0,
            this.options.format,
            this.options.type,
            this.options.offset
          );
        } else {
          this.gl.texImage2D(
            this.target,
            0,
            this.gl.RGBA,
            1,
            1,
            0,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            emptyPixel,
            this.options.offset
          );
        }
      } else {
        if (this.width > 0) {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            0,
            this.options.format,
            this.options.type,
            null
          );
        } else {
          this.gl.texImage2D(
            this.target,
            0,
            this.gl.RGBA,
            1,
            1,
            0,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            emptyPixel
          );
        }
      }
    }
    __privateGet(this, _state3).image = this.image;
    __privateGet(this, _state3).version += 1;
  }
  bind(unit = this.textureUnit) {
    if (this.rendererState.textureUnits[this.rendererState.activeTextureUnit] === this.id)
      return;
    this.textureUnit = unit;
    this.rendererState.textureUnits[this.textureUnit] = this.id;
    this.gl.bindTexture(this.target, this.handle);
  }
  unbind() {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.textureUnit);
    this.gl.bindTexture(this.target, null);
    delete this.rendererState.textureUnits[this.textureUnit];
  }
  destroy() {
    this.unbind();
    super.destroy();
  }
  removeStats() {
    __privateSet(this, _state3, {
      version: -1
    });
  }
  createHandle() {
    return this.gl.createTexture();
  }
  deleteHandle() {
    if (this.handle) {
      this.gl.deleteTexture(this.handle);
    }
  }
  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }
};
_state3 = new WeakMap();
var DataTexture = class extends Texture {
  constructor(renderer, options = {}) {
    super(renderer, {
      ...options,
      image: options.data,
      premultiplyAlpha: true,
      flipY: false,
      unpackAlignment: 1
    });
    __publicField(this, "needsUpdate", true);
  }
};
var _textures, _renderBuffers, _clearColors, _clearDepth, _clearStencil;
var RenderTarget = class extends Resource {
  constructor(renderer, options = {}) {
    super(renderer, {
      color: 1,
      depth: true,
      depthTexture: false,
      stencil: false,
      ...options
    });
    __privateAdd(this, _textures);
    __privateAdd(this, _renderBuffers);
    __publicField(this, "depth");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "viewport");
    __publicField(this, "drawBuffersChanged");
    __publicField(this, "drawBuffers");
    __privateAdd(this, _clearColors);
    __privateAdd(this, _clearDepth);
    __privateAdd(this, _clearStencil);
    __privateSet(this, _renderBuffers, /* @__PURE__ */ new Map());
    __privateSet(this, _textures, /* @__PURE__ */ new Map());
    this.depth = Boolean(options.depth);
    this.drawBuffers = [];
    this.drawBuffersChanged = false;
    this.width = this.options.width;
    this.height = this.options.height;
    this.viewport = new Vector4(0, 0, this.width, this.height);
    this.name = this.options.name;
    const attachments = this.options.attachments || [];
    if (attachments.length === 0) {
      for (let i2 = 0; i2 < this.options.color; i2++) {
        const opt = {
          wrapS: this.gl.CLAMP_TO_EDGE,
          wrapT: this.gl.CLAMP_TO_EDGE,
          minFilter: this.gl.LINEAR,
          magFilter: this.gl.LINEAR,
          type: this.gl.UNSIGNED_BYTE,
          format: this.gl.RGBA,
          flipY: false,
          generateMipmaps: false,
          ...options
        };
        let texture;
        if (opt.data) {
          texture = new DataTexture(renderer, opt);
        } else {
          texture = new Texture(
            renderer,
            omit(opt, [
              "data",
              "name",
              "attachments",
              "depthTexture"
            ])
          );
        }
        attachments.push([this.gl.COLOR_ATTACHMENT0 + i2, texture]);
      }
      if (options.depthTexture && (renderer.isWebGL2 || !renderer.isWebGL2 && renderer.gl.getExtension("WEBGL_depth_texture"))) {
        const texture = new Texture(renderer, {
          width: this.width,
          height: this.height,
          minFilter: this.gl.NEAREST,
          magFilter: this.gl.NEAREST,
          format: this.gl.DEPTH_COMPONENT,
          internalFormat: renderer.isWebGL2 ? this.gl.DEPTH_COMPONENT16 : this.gl.DEPTH_COMPONENT,
          type: this.gl.UNSIGNED_INT
        });
        attachments.push([this.gl.DEPTH_ATTACHMENT, texture]);
      } else {
        const { depth, stencil } = options;
        if (depth && !stencil) {
          const renderBuffer = new RenderBuffer(renderer, {
            format: this.gl.DEPTH_COMPONENT16,
            width: this.width,
            height: this.height
          });
          attachments.push([this.gl.DEPTH_ATTACHMENT, renderBuffer]);
        } else if (stencil && !depth) {
          const renderBuffer = new RenderBuffer(renderer, {
            format: this.gl.STENCIL_INDEX8,
            width: this.width,
            height: this.height
          });
          attachments.push([this.gl.STENCIL_ATTACHMENT, renderBuffer]);
        } else if (depth && stencil) {
          const renderBuffer = new RenderBuffer(renderer, {
            format: this.gl.DEPTH_STENCIL,
            width: this.width,
            height: this.height
          });
          attachments.push([this.gl.DEPTH_STENCIL_ATTACHMENT, renderBuffer]);
        }
      }
    }
    this.create(attachments);
  }
  get texture() {
    return __privateGet(this, _textures).values().next().value;
  }
  set clearColors(colors) {
    __privateSet(this, _clearColors, colors);
  }
  get clearColors() {
    return __privateGet(this, _clearColors);
  }
  set clearDepth(depth) {
    __privateSet(this, _clearDepth, depth);
  }
  get clearDepth() {
    return __privateGet(this, _clearDepth);
  }
  set clearStencil(stencil) {
    __privateSet(this, _clearStencil, stencil);
  }
  get clearStencil() {
    return __privateGet(this, _clearStencil);
  }
  create(attachments) {
    __privateSet(this, _clearColors, []);
    __privateSet(this, _clearDepth, 1);
    __privateSet(this, _clearStencil, 0);
    for (const attachment of attachments) {
      const attach = attachment[0];
      const target = attachment[1];
      if (target instanceof RenderBuffer) {
        __privateGet(this, _renderBuffers).set(attach, target);
      } else if (target instanceof Texture) {
        __privateGet(this, _textures).set(attach, target);
        this.drawBuffers.push(attach);
      }
      const i2 = attach - this.gl.COLOR_ATTACHMENT0;
      __privateGet(this, _clearColors)[i2] = [0, 0, 0, 0];
    }
    if (this.options.color > 1) {
      if (this.renderer.isWebGL2) {
        this.gl.drawBuffers(this.drawBuffers);
      } else {
        const ext = this.renderer.extension("WEBGL_draw_buffers");
        if (ext && ext.drawBuffersWEBGL) {
          ext.drawBuffersWEBGL(this.drawBuffers);
        } else {
          throw new Error(
            "Please open the corresponding extension [WEBGL_draw_buffers](https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_draw_buffers#browser_compatibility) and check whether the browser supports it"
          );
        }
      }
    }
    this.drawBuffersChanged = true;
    this.bind();
    __privateGet(this, _renderBuffers).forEach((rbo, attachment) => {
      this.gl.framebufferRenderbuffer(
        this.gl.FRAMEBUFFER,
        attachment,
        this.gl.RENDERBUFFER,
        rbo.handle
      );
    });
    __privateGet(this, _textures).forEach((texture, attachment) => {
      this.gl.framebufferTexture2D(
        this.gl.FRAMEBUFFER,
        attachment,
        this.gl.TEXTURE_2D,
        texture.handle,
        0
      );
    });
    this.unbind();
    const status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
    if (status !== this.gl.FRAMEBUFFER_COMPLETE) {
      switch (status) {
        case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error(
            "The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete"
          );
        case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error("There is no attachment");
        case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error(" Height and width of the attachment are not the same.");
        case this.gl.FRAMEBUFFER_UNSUPPORTED:
          throw new Error(
            "The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer"
          );
      }
    }
    return this.handle;
  }
  clear() {
    this.bind();
    let flags = 0;
    if (this.clearColors[0]) {
      const color = this.clearColors[0];
      this.gl.clearColor(color[0], color[1], color[2], color[3]);
      flags |= this.gl.COLOR_BUFFER_BIT;
    }
    if (isNumber(__privateGet(this, _clearDepth))) {
      this.gl.clearDepth(__privateGet(this, _clearDepth));
      flags |= this.gl.DEPTH_BUFFER_BIT;
    }
    if (isNumber(__privateGet(this, _clearStencil))) {
      this.gl.clearStencil(__privateGet(this, _clearStencil));
      flags |= this.gl.STENCIL_BUFFER_BIT;
    }
    this.gl.clear(flags);
    this.unbind();
  }
  getTexture(key) {
    return __privateGet(this, _textures).get(key);
  }
  resize(width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      __privateGet(this, _textures).forEach((texture) => {
        if (texture.width !== width || texture.height !== height) {
          texture.width = width;
          texture.height = height;
          texture.needsUpdate = true;
          texture.update();
        }
      });
      __privateGet(this, _renderBuffers).forEach((rbo) => {
        rbo.resize(width, height);
      });
      this.viewport.set(0, 0, width, height);
    }
  }
  bind(fbo = this.gl.FRAMEBUFFER) {
    this.gl.bindFramebuffer(fbo, this.handle);
  }
  unbind(fbo = this.gl.FRAMEBUFFER) {
    this.gl.bindFramebuffer(fbo, null);
  }
  removeStats() {
  }
  destroy() {
    __privateGet(this, _textures).forEach((texture) => {
      texture.destroy();
    });
    __privateGet(this, _renderBuffers).forEach((buffer) => {
      buffer.destroy();
    });
    this.deleteHandle();
  }
  createHandle() {
    return this.gl.createFramebuffer();
  }
  deleteHandle() {
    this.handle && this.gl.deleteFramebuffer(this.handle);
  }
  toString() {
    return `RenderTarget(${this.id},${this.width}x${this.height})`;
  }
};
_textures = new WeakMap();
_renderBuffers = new WeakMap();
_clearColors = new WeakMap();
_clearDepth = new WeakMap();
_clearStencil = new WeakMap();
function getPlaneBuffer(position, normal, uv, index2, width = 1, height = 1, depth = 0, widthSegments = 1, heightSegments = 1, u2 = 0, v2 = 1, w2 = 2, uDir = 1, vDir = -1, i2 = 0, ii = 0) {
  const consti = i2;
  const widthHalf = width / 2;
  const heightHalf = height / 2;
  const depthHalf = depth / 2;
  const gridX = Math.floor(widthSegments);
  const gridY = Math.floor(heightSegments);
  const gridX1 = gridX + 1;
  const gridY1 = gridY + 1;
  const segmentWidth = width / gridX;
  const segmentHeight = height / gridY;
  for (let iy = 0; iy < gridY1; iy++) {
    const y2 = iy * segmentHeight - heightHalf;
    for (let ix = 0; ix < gridX1; ix++) {
      position[i2 * 3 + u2] = (ix * segmentWidth - widthHalf) * uDir;
      position[i2 * 3 + v2] = y2 * vDir;
      position[i2 * 3 + w2] = depthHalf;
      normal[i2 * 3 + u2] = 0;
      normal[i2 * 3 + v2] = 0;
      normal[i2 * 3 + w2] = depth >= 0 ? 1 : -1;
      uv[i2 * 2] = ix / gridX;
      uv[i2 * 2 + 1] = 1 - iy / gridY;
      i2++;
      if (iy === gridY || ix === gridX)
        continue;
      const a2 = consti + ix + gridX1 * iy;
      const b2 = consti + ix + gridX1 * (iy + 1);
      const c2 = consti + ix + 1 + gridX1 * (iy + 1);
      const d2 = consti + ix + 1 + gridX1 * iy;
      index2[ii * 6] = a2;
      index2[ii * 6 + 1] = b2;
      index2[ii * 6 + 2] = d2;
      index2[ii * 6 + 3] = b2;
      index2[ii * 6 + 4] = c2;
      index2[ii * 6 + 5] = d2;
      ii++;
    }
  }
}
var Plane = class extends Geometry {
  constructor(renderer, {
    width = 1,
    height = 1,
    widthSegments = 1,
    heightSegments = 1,
    attributes = {}
  } = {}) {
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const num = gridX1 * gridY1;
    const numIndices = gridX * gridY * 6;
    const position = new Float32Array(num * 3);
    const normal = new Float32Array(num * 3);
    const uv = new Float32Array(num * 2);
    const index2 = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);
    getPlaneBuffer(position, normal, uv, index2, width, height, 0, widthSegments, heightSegments);
    super(renderer, {
      ...attributes,
      position: {
        size: 3,
        data: position
      },
      normal: {
        size: 3,
        data: normal
      },
      uv: {
        size: 2,
        data: uv
      },
      index: {
        data: index2
      }
    });
  }
};
var Box = class extends Geometry {
  constructor(renderer, {
    width = 1,
    height = 1,
    depth = 1,
    widthSegments = 1,
    heightSegments = 1,
    depthSegments = 1,
    attributes = {}
  } = {}) {
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridZ = Math.floor(depthSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const gridZ1 = gridZ + 1;
    const num = gridX1 * gridY1 * 2 + gridX1 * gridZ1 * 2 + gridY1 * gridZ1 * 2;
    const numIndices = (gridX * gridY * 2 + gridX * gridZ * 2 + gridY * gridZ * 2) * 6;
    const position = new Float32Array(num * 3);
    const normal = new Float32Array(num * 3);
    const uv = new Float32Array(num * 2);
    const index2 = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);
    let i2 = 0;
    let ii = 0;
    const d2 = gridZ1 * gridY1;
    const w2 = gridX1 * gridZ1;
    const h2 = gridX1 * gridY1;
    const dt = gridZ * gridY;
    const wt = gridX * gridZ;
    const ht = gridX * gridY;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index2,
      depth,
      height,
      width,
      depthSegments,
      heightSegments,
      2,
      1,
      0,
      -1,
      -1,
      i2,
      ii
    );
    i2 += d2;
    ii += dt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index2,
      depth,
      height,
      -width,
      depthSegments,
      heightSegments,
      2,
      1,
      0,
      1,
      -1,
      i2,
      ii
    );
    i2 += d2;
    ii += dt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index2,
      width,
      depth,
      height,
      depthSegments,
      widthSegments,
      0,
      2,
      1,
      1,
      1,
      i2,
      ii
    );
    i2 += w2;
    ii += wt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index2,
      width,
      depth,
      -height,
      depthSegments,
      widthSegments,
      0,
      2,
      1,
      1,
      -1,
      i2,
      ii
    );
    i2 += w2;
    ii += wt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index2,
      width,
      height,
      -depth,
      widthSegments,
      heightSegments,
      0,
      1,
      2,
      -1,
      -1,
      i2,
      ii
    );
    i2 += h2;
    ii += ht;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index2,
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      0,
      1,
      2,
      1,
      -1,
      i2,
      ii
    );
    super(renderer, {
      ...attributes,
      position: {
        size: 3,
        data: position
      },
      normal: {
        size: 3,
        data: normal
      },
      uv: {
        size: 2,
        data: uv
      },
      index: {
        data: index2
      }
    });
  }
};
var ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
var cachedIds = {};
function genShaderName(key = "id") {
  cachedIds[key] = cachedIds[key] || 1;
  const idx = cachedIds[key];
  cachedIds[key] += 1;
  return "".concat(key, "-").concat(idx);
}
var getTypeName = (ctx, shaderType) => {
  switch (shaderType) {
    case ctx.VERTEX_SHADER:
      return "vertex-shader";
    case ctx.FRAGMENT_SHADER:
      return "fragment-shader";
    default:
      return "unknown";
  }
};
var getShaderType = (ctx, type) => {
  switch (type) {
    case "fragment":
      return ctx.FRAGMENT_SHADER;
    case "vertex":
      return ctx.VERTEX_SHADER;
    default:
      return;
  }
};
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
var _shaderType, _includes;
var Shader = class extends Resource {
  constructor(renderer, sourceCode, type, includes = {}) {
    const shaderType = getShaderType(renderer.gl, type);
    super(renderer, {
      name: getShaderName(sourceCode) || genShaderName(getTypeName(renderer, shaderType))
    });
    __privateAdd(this, _shaderType);
    __privateAdd(this, _includes);
    __publicField(this, "sourceCode");
    console.assert(typeof sourceCode === "string", ERR_SOURCE);
    __privateSet(this, _includes, includes);
    __privateSet(this, _shaderType, shaderType);
    this.sourceCode = this.injectShaderModule(sourceCode, includes || {}).replace(
      /\n\n+/gm,
      "\n\n"
    );
    this.createShader(this.sourceCode);
  }
  injectShaderModule(shader, modules = {}) {
    const regExp = /^[\t ]*#glsl_include +<([\w.]+)>/gm;
    const replacement = (substring, r2) => {
      let module = modules[r2];
      if (module === void 0)
        throw new Error("Cannot resolve #include <".concat(r2, ">"));
      module = module.replace(/#include </g, "#glsl_include <");
      return this.injectShaderModule(module, modules);
    };
    return shader.replace(regExp, replacement);
  }
  createShader(source = this.source) {
    let s2 = source.replace(/#include </g, "#glsl_include <");
    s2 = this.injectShaderModule(s2, __privateGet(this, _includes) || {}).replace(/\n\n+/gm, "\n\n");
    this.gl.shaderSource(this.handle, s2);
    this.gl.compileShader(this.handle);
    if (!this.gl.getShaderParameter(this.handle, this.gl.COMPILE_STATUS)) {
      const log = this.gl.getShaderInfoLog(this.handle) || "";
      this.gl.deleteShader(this.handle);
      throw new Error(`${this.toString()}
${log}
${addLineNumbers(s2)}`);
    }
  }
  get source() {
    return this.sourceCode;
  }
  get shaderType() {
    return __privateGet(this, _shaderType);
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  setSource(source) {
    const name = getShaderName(source);
    if (name) {
      this.name = genShaderName(name);
    }
    this.createShader(source);
  }
  removeStats() {
  }
  deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  toString() {
    return `${getTypeName(this.gl, this.shaderType)}:${this.id}`;
  }
};
_shaderType = new WeakMap();
_includes = new WeakMap();
var VertexShader = class extends Shader {
  constructor(renderer, sourceCode, includes) {
    super(renderer, sourceCode, "vertex", includes);
  }
  createHandle() {
    return this.gl.createShader(this.gl.VERTEX_SHADER);
  }
};
var FragmentShader = class extends Shader {
  constructor(renderer, sourceCode, includes) {
    super(renderer, sourceCode, "fragment", includes);
  }
  createHandle() {
    return this.gl.createShader(this.gl.FRAGMENT_SHADER);
  }
};
var getDefines = (t2) => {
  const defines = [];
  return defines.map((d2) => "#define ".concat(d2));
};
var arrayCacheF32 = {};
function flatten(a2) {
  const arrayLen = a2.length;
  const valueLen = a2[0].length;
  if (valueLen === void 0)
    return a2;
  const length5 = arrayLen * valueLen;
  let value = arrayCacheF32[length5];
  if (!value)
    arrayCacheF32[length5] = value = new Float32Array(length5);
  for (let i2 = 0; i2 < arrayLen; i2++)
    value.set(a2[i2], i2 * valueLen);
  return value;
}
function setUniform(gl, type, location, value) {
  value = value.length ? flatten(value) : value;
  const isArray = value.length;
  switch (type) {
    case WebGLRenderingContext.FLOAT:
      return isArray ? gl.uniform1fv(location, value) : gl.uniform1f(location, value);
    case WebGLRenderingContext.FLOAT_VEC2:
      return gl.uniform2fv(location, value);
    case WebGLRenderingContext.FLOAT_VEC3:
      return gl.uniform3fv(location, value);
    case WebGLRenderingContext.FLOAT_VEC4:
      return gl.uniform4fv(location, value);
    case WebGLRenderingContext.BOOL:
    case WebGLRenderingContext.INT:
    case WebGLRenderingContext.SAMPLER_2D:
    case WebGLRenderingContext.SAMPLER_CUBE:
      return isArray ? gl.uniform1iv(location, value) : gl.uniform1i(location, value);
    case WebGLRenderingContext.BOOL_VEC2:
    case WebGLRenderingContext.INT_VEC2:
      return gl.uniform2iv(location, value);
    case WebGLRenderingContext.BOOL_VEC3:
    case WebGLRenderingContext.INT_VEC3:
      return gl.uniform3iv(location, value);
    case WebGLRenderingContext.BOOL_VEC4:
    case WebGLRenderingContext.INT_VEC4:
      return gl.uniform4iv(location, value);
    case WebGLRenderingContext.FLOAT_MAT2:
      return gl.uniformMatrix2fv(location, false, value);
    case WebGLRenderingContext.FLOAT_MAT3:
      return gl.uniformMatrix3fv(location, false, value);
    case WebGLRenderingContext.FLOAT_MAT4:
      return gl.uniformMatrix4fv(location, false, value);
  }
}
var _uniformLocations, _attributeLocations, _vs, _fs, _renderState, _Program_instances, assignUniforms_fn, assignAttributes_fn;
var Program = class extends Resource {
  constructor(renderer, options = {}) {
    super(renderer, options);
    __privateAdd(this, _Program_instances);
    __publicField(this, "attributeOrder");
    __publicField(this, "uniforms");
    __privateAdd(this, _uniformLocations);
    __privateAdd(this, _attributeLocations);
    __privateAdd(this, _vs);
    __privateAdd(this, _fs);
    __privateAdd(this, _renderState);
    const {
      id,
      vertexShader,
      fragmentShader,
      uniforms = {},
      transparent = false,
      defines = [],
      includes = {},
      cullFace,
      frontFace = renderer.gl.CCW,
      depthTest = true,
      depthWrite = true,
      depthFunc = renderer.gl.LESS,
      blending = 1,
      blendFunc,
      blendEquation
    } = options;
    this.id = id || uid("program");
    const defs = [
      ...getDefines({
        ...options,
        ...uniforms
      }),
      ...defines
    ].map((str) => !str.startsWith("#define ") ? "#define ".concat(str) : str);
    if (!vertexShader || !fragmentShader) {
      throw new Error(`Program: ${this.id}：must provide vertexShader and fragmentShader`);
    }
    __privateSet(this, _vs, typeof vertexShader === "string" ? new VertexShader(renderer, parseShader(vertexShader, defs), includes) : vertexShader);
    __privateSet(this, _fs, typeof fragmentShader === "string" ? new FragmentShader(renderer, parseShader(fragmentShader, defs), includes) : fragmentShader);
    this.gl.attachShader(this.handle, __privateGet(this, _vs).handle);
    this.gl.attachShader(this.handle, __privateGet(this, _fs).handle);
    this.gl.linkProgram(this.handle);
    this.gl.validateProgram(this.handle);
    if (!this.gl.getProgramParameter(this.handle, this.gl.LINK_STATUS)) {
      throw new Error(
        "Program:".concat(this.id, ": Error linking ").concat(this.gl.getProgramInfoLog(this.handle))
      );
    }
    this.uniforms = uniforms;
    __privateSet(this, _renderState, {
      blending,
      cullFace,
      frontFace,
      depthTest,
      depthWrite,
      depthFunc,
      blendFunc,
      blendEquation
    });
    __privateSet(this, _uniformLocations, /* @__PURE__ */ new Map());
    __privateSet(this, _attributeLocations, /* @__PURE__ */ new Map());
    __privateMethod(this, _Program_instances, assignUniforms_fn).call(this, uniforms);
    __privateMethod(this, _Program_instances, assignAttributes_fn).call(this);
    if (transparent && !(blendFunc == null ? void 0 : blendFunc.src)) {
      if (this.renderer.premultipliedAlpha) {
        __privateGet(this, _renderState).blendFunc = {
          ...blendFunc,
          src: this.gl.ONE,
          dst: this.gl.ONE_MINUS_SRC_ALPHA
        };
      } else {
        __privateGet(this, _renderState).blendFunc = {
          ...blendFunc,
          src: this.gl.SRC_ALPHA,
          dst: this.gl.ONE_MINUS_SRC_ALPHA
        };
      }
    }
  }
  get uniformLocations() {
    return __privateGet(this, _uniformLocations);
  }
  get attributeLocations() {
    return __privateGet(this, _attributeLocations);
  }
  get vertexShader() {
    return __privateGet(this, _vs);
  }
  get fragmentShader() {
    return __privateGet(this, _fs);
  }
  use() {
    const programActive = this.rendererState.currentProgramId === this.id;
    let textureUnit = -1;
    if (!programActive) {
      this.gl.useProgram(this.handle);
      this.rendererState.currentProgramId = this.id;
    }
    __privateGet(this, _uniformLocations).forEach((location, activeUniform) => {
      const name = activeUniform.name;
      const uniform = this.uniforms[name];
      if (!uniform) {
        console.warn("Program:".concat(this.id, ": Active uniform ").concat(name, " has not been supplied"));
        return;
      }
      if (uniform && (isUndef(uniform.value) || isNull(uniform.value))) {
        console.warn("Program:".concat(this.id, ": Uniform ").concat(name, " is missing a value parameter"));
        return;
      }
      let value = uniform == null ? void 0 : uniform.value;
      if (value instanceof Texture) {
        textureUnit += 1;
        uniform.value.update(textureUnit);
        return setUniform(this.gl, activeUniform.type, location.location, textureUnit);
      }
      if (value instanceof Matrix || value instanceof Vector) {
        value = uniform.value.toArray();
      } else if (value instanceof Color) {
        value = uniform.value.toArray();
      }
      if (value && value.length > 0 && value[0] instanceof Texture) {
        const units = [];
        for (let i2 = 0; i2 < uniform.value.length; i2++) {
          const v2 = value[i2];
          textureUnit += 1;
          v2.update(textureUnit);
          units.push(textureUnit);
        }
        return setUniform(this.gl, activeUniform.type, location.location, units);
      }
      setUniform(this.gl, activeUniform.type, location.location, value);
    });
    this.applyState();
  }
  setStates(states, merge = true) {
    if (!merge) {
      __privateSet(this, _renderState, states);
    } else {
      __privateSet(this, _renderState, {
        ...__privateGet(this, _renderState),
        ...omit(states, ["blendFunc", "blendEquation"])
      });
      if (states.blendFunc) {
        __privateGet(this, _renderState).blendFunc = {
          ...__privateGet(this, _renderState).blendFunc,
          ...states.blendFunc
        };
      }
      if (states.blendEquation) {
        __privateGet(this, _renderState).blendEquation = {
          ...__privateGet(this, _renderState).blendEquation,
          ...states.blendEquation
        };
      }
    }
  }
  applyState() {
    this.rendererState.apply(__privateGet(this, _renderState));
  }
  setUniform(key, value) {
    if (this.uniforms[key]) {
      this.uniforms[key].value = value;
    }
  }
  bind() {
    this.gl.useProgram(this.handle);
  }
  unbind() {
    this.gl.useProgram(null);
  }
  createHandle() {
    return this.gl.createProgram();
  }
  deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  destroy() {
    this.unbind();
    this.deleteHandle();
  }
};
_uniformLocations = new WeakMap();
_attributeLocations = new WeakMap();
_vs = new WeakMap();
_fs = new WeakMap();
_renderState = new WeakMap();
_Program_instances = new WeakSet();
assignUniforms_fn = function(uniforms = {}) {
  var _a;
  const numUniforms = this.gl.getProgramParameter(this.handle, this.gl.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < numUniforms; i2++) {
    const uniformInfo = this.gl.getActiveUniform(this.handle, i2);
    if (!uniformInfo)
      break;
    const name = uniformInfo.name;
    const split = name.match(/(\w+)/g);
    const uniformData = {
      location: this.gl.getUniformLocation(this.handle, name),
      type: uniformInfo.type,
      name: split[0],
      isStruct: false
    };
    if (split.length === 3) {
      uniformData.isStructArray = true;
      uniformData.structIndex = Number(split[1]);
      uniformData.structProperty = split[2];
    } else if (split.length === 2 && isNaN(Number(split[1]))) {
      uniformData.isStruct = true;
      uniformData.structProperty = split[1];
    }
    const v2 = (_a = uniforms[name]) == null ? void 0 : _a.value;
    if (!isUndef(v2) && !isNull(v2)) {
      uniformData.value = uniforms[name].value;
    }
    this.uniforms[name] = uniformData;
    __privateGet(this, _uniformLocations).set(uniformInfo, uniformData);
  }
};
assignAttributes_fn = function() {
  const numAttribs = this.gl.getProgramParameter(this.handle, this.gl.ACTIVE_ATTRIBUTES);
  const locations = [];
  for (let i2 = 0; i2 < numAttribs; i2++) {
    const attribInfo = this.gl.getActiveAttrib(this.handle, i2);
    if (!attribInfo)
      break;
    const location = this.gl.getAttribLocation(this.handle, attribInfo.name);
    locations[location] = attribInfo.name;
    __privateGet(this, _attributeLocations).set(attribInfo, location);
  }
  this.attributeOrder = locations.join("");
};
var _state4;
var Texture3D = class extends Texture {
  constructor(renderer, options = {}) {
    const gl = renderer.gl;
    const defaultOptions2 = {
      target: gl.TEXTURE_3D,
      type: gl.UNSIGNED_BYTE,
      format: gl.RGBA,
      internalFormat: options.format || gl.RGBA,
      wrapS: gl.CLAMP_TO_EDGE,
      wrapT: gl.CLAMP_TO_EDGE,
      wrapR: gl.CLAMP_TO_EDGE,
      generateMipmaps: true,
      minFilter: gl.LINEAR,
      magFilter: gl.LINEAR,
      premultiplyAlpha: false,
      unpackAlignment: 4,
      flipY: false,
      level: 0,
      depth: 0
    };
    const opt = Object.assign({}, defaultOptions2, options);
    super(renderer, opt, false);
    __publicField(this, "needsUpdate", false);
    __publicField(this, "textureUnit", 0);
    __publicField(this, "depth");
    __privateAdd(this, _state4, {});
    this.needsUpdate = true;
    this.depth = this.options.depth;
    __privateGet(this, _state4).version = -1;
    this.update();
  }
  get gl() {
    return this.renderer.gl;
  }
  setData(image, width = this.width, height = this.height, depth = this.depth) {
    this.image = image;
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.needsUpdate = true;
  }
  setOptions(options) {
    this.options = Object.assign(this.options, options);
    this.width = this.options.width;
    this.height = this.options.height;
    this.depth = this.options.depth;
    this.needsUpdate = true;
  }
  update(units = 0) {
    const needUpdate = !(this.image === __privateGet(this, _state4).image && !this.needsUpdate);
    const checked = needUpdate || this.rendererState.textureUnits[units] !== this.id || this.rendererState.activeTextureUnit !== units;
    if (checked) {
      this.rendererState.setActiveTexture(units);
      this.bind(units);
    }
    if (!needUpdate)
      return;
    this.needsUpdate = false;
    if (this.options.wrapS !== __privateGet(this, _state4).wrapS) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.options.wrapS);
      __privateGet(this, _state4).wrapS = this.options.wrapS;
    }
    if (this.options.wrapT !== __privateGet(this, _state4).wrapT) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.options.wrapT);
      __privateGet(this, _state4).wrapT = this.options.wrapT;
    }
    if (this.options.wrapR !== __privateGet(this, _state4).wrapR) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.options.wrapR);
      __privateGet(this, _state4).wrapR = this.options.wrapR;
    }
    if (this.options.minFilter !== __privateGet(this, _state4).minFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MIN_FILTER,
        this.options.minFilter
      );
      __privateGet(this, _state4).minFilter = this.options.minFilter;
    }
    if (this.options.magFilter !== __privateGet(this, _state4).magFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MAG_FILTER,
        this.options.magFilter
      );
      __privateGet(this, _state4).magFilter = this.options.magFilter;
    }
    if (this.options.flipY !== this.rendererState.flipY) {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.options.flipY);
      this.rendererState.flipY = this.options.flipY;
    }
    if (this.options.premultiplyAlpha !== this.rendererState.premultiplyAlpha) {
      this.gl.pixelStorei(
        this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        this.options.premultiplyAlpha
      );
      this.rendererState.premultiplyAlpha = this.options.premultiplyAlpha;
    }
    if (this.options.unpackAlignment !== this.rendererState.unpackAlignment) {
      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.options.unpackAlignment);
      this.rendererState.unpackAlignment = this.options.unpackAlignment;
    }
    if (this.options.anisotropy && this.options.anisotropy !== this.rendererState.anisotropy) {
      const extTextureFilterAnisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
      if (extTextureFilterAnisotropic) {
        const max = this.gl.getParameter(
          extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
        );
        let v2 = this.options.anisotropy;
        if (this.options.anisotropy > max) {
          v2 = max;
          console.warn(
            `[Texture]: Texture.anisotropy option exceeded the maximum allowed value ${max} of the device`
          );
        }
        this.gl.texParameterf(
          this.target,
          extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          v2
        );
      }
      this.rendererState.anisotropy = this.options.anisotropy;
    }
    if (this.image) {
      if (this.image.width) {
        this.width = this.image.width;
        this.height = this.image.height;
      }
      if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
        this.gl.texImage3D(
          this.target,
          this.options.level,
          this.options.internalFormat,
          this.width,
          this.height,
          this.depth,
          0,
          this.options.format,
          this.options.type,
          this.image,
          this.options.offset
        );
      } else {
        if (ArrayBuffer.isView(this.image)) {
          this.gl.texImage3D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            this.depth,
            0,
            this.options.format,
            this.options.type,
            this.image
          );
        } else {
          this.gl.texImage3D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            this.depth,
            0,
            this.options.format,
            this.options.type,
            this.image
          );
        }
      }
      if (this.options.generateMipmaps) {
        if (this.renderer.isWebGL2 || isPowerOfTwo(this.image.width) && isPowerOfTwo(this.image.height)) {
          this.gl.generateMipmap(this.target);
        } else {
          this.options.generateMipmaps = false;
          this.options.wrapS = this.gl.CLAMP_TO_EDGE;
          this.options.wrapT = this.options.wrapS;
          this.options.minFilter = this.gl.LINEAR;
        }
      }
    } else {
      if (this.width > 0) {
        this.gl.texImage3D(
          this.target,
          this.options.level,
          this.options.internalFormat,
          this.width,
          this.height,
          this.depth,
          0,
          this.options.format,
          this.options.type,
          null
        );
      } else {
        this.gl.texImage3D(
          this.target,
          0,
          this.gl.RGBA,
          1,
          1,
          this.depth,
          0,
          this.gl.RGBA,
          this.gl.UNSIGNED_BYTE,
          emptyPixel
        );
      }
    }
    __privateGet(this, _state4).image = this.image;
    __privateGet(this, _state4).version += 1;
  }
  removeStats() {
    __privateSet(this, _state4, {
      version: -1
    });
  }
  toString() {
    return `Texture3D(${this.id},${this.width}x${this.height})`;
  }
};
_state4 = new WeakMap();
var tempMat4 = new Matrix4();
var tempVec3a = new Vector3();
var tempVec3b = new Vector3();
var ERR_CAMERA_METHOD_UNDEFINED = "Camera subclass must define virtual methods";
var _near, _far, _fov, _aspect, _zoom, _bounds2;
var Camera = class extends Object3D {
  constructor({
    near = 0.1,
    far = 100,
    fov = 45,
    aspect = 1,
    bounds,
    zoom = 1
  } = {}) {
    super();
    __publicField(this, "cameraType");
    __publicField(this, "projectionMatrix");
    __publicField(this, "viewMatrix");
    __publicField(this, "projectionViewMatrix");
    __publicField(this, "worldPosition");
    __privateAdd(this, _near);
    __privateAdd(this, _far);
    __privateAdd(this, _fov);
    __privateAdd(this, _aspect);
    __privateAdd(this, _zoom);
    __privateAdd(this, _bounds2);
    __publicField(this, "frustum");
    this.cameraType = "perspective";
    this.projectionMatrix = new ProjectionMatrix();
    this.viewMatrix = new Matrix4();
    this.projectionViewMatrix = new ProjectionMatrix();
    this.worldPosition = new Vector3();
    this.frustum = new Matrix4();
    __privateSet(this, _near, near);
    __privateSet(this, _far, far);
    __privateSet(this, _fov, fov);
    __privateSet(this, _aspect, aspect);
    __privateSet(this, _bounds2, bounds);
    __privateSet(this, _zoom, zoom);
    const {
      left,
      right,
      top,
      bottom
    } = bounds || {};
    this.cameraType = left || right ? "orthographic" : "perspective";
    if (this.cameraType === "orthographic") {
      this.orthographic(left, right, top, bottom, near, far, zoom);
    } else {
      this.perspective(fov, aspect, near, far);
    }
  }
  get near() {
    return __privateGet(this, _near);
  }
  set near(n2) {
    __privateSet(this, _near, n2);
    this.updateProjectionMatrix();
  }
  get far() {
    return __privateGet(this, _far);
  }
  set far(f2) {
    __privateSet(this, _far, f2);
    this.updateProjectionMatrix();
  }
  get fov() {
    return __privateGet(this, _fov);
  }
  set fov(f2) {
    __privateSet(this, _fov, f2);
    this.updateProjectionMatrix();
  }
  get aspect() {
    return __privateGet(this, _aspect);
  }
  set aspect(aspect) {
    __privateSet(this, _aspect, aspect);
    this.updateProjectionMatrix();
  }
  get zoom() {
    return __privateGet(this, _zoom);
  }
  set zoom(zoom) {
    __privateSet(this, _zoom, zoom);
    this.updateProjectionMatrix();
  }
  get bounds() {
    return __privateGet(this, _bounds2);
  }
  set bounds(bounds) {
    __privateSet(this, _bounds2, bounds);
    this.updateProjectionMatrix();
  }
  perspective(fov = this.fov, aspect = this.aspect, near = this.near, far = this.far) {
    __privateSet(this, _fov, fov);
    __privateSet(this, _aspect, aspect);
    __privateSet(this, _near, near);
    __privateSet(this, _far, far);
    this.projectionMatrix.fromPerspective(fov, aspect, near, far);
    this.cameraType = "perspective";
  }
  orthographic(left, right, top, bottom, near = this.near, far = this.far, zoom = 1) {
    __privateSet(this, _bounds2, {
      left,
      right,
      top,
      bottom
    });
    this.near = near;
    this.far = far;
    this.projectionMatrix.orthographic(
      left / zoom,
      right / zoom,
      top / zoom,
      bottom / zoom,
      near,
      far
    );
    this.cameraType = "orthographic";
    this.projectionMatrix.frustum(this.frustum, __privateGet(this, _bounds2).left, __privateGet(this, _bounds2).right, __privateGet(this, _bounds2).top, __privateGet(this, _bounds2).bottom, __privateGet(this, _near), __privateGet(this, _far));
  }
  lookAt(t2) {
    super.lookAt(t2, true);
    return this;
  }
  updateMatrixWorld() {
    super.updateMatrixWorld();
    this.viewMatrix.invert(this.worldMatrix);
    this.worldMatrix.getTranslation(this.worldPosition);
    this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);
    return this;
  }
  frustumIntersectsMesh(node, worldMatrix = node.worldMatrix) {
    if (!node.geometry.attributes.position)
      return true;
    if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity)
      node.geometry.computeBoundingSphere();
    if (!node.geometry.bounds)
      return true;
    const center = tempVec3a;
    center.copy(node.geometry.bounds.center);
    center.applyMatrix4(worldMatrix);
    const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();
    return this.frustumIntersectsSphere(center, radius);
  }
  frustumIntersectsSphere(center, radius) {
    const normal = tempVec3b;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = this.frustum[i2];
      const distance4 = normal.copy(plane).dot(center) + plane.constant;
      if (distance4 < -radius)
        return false;
    }
    return true;
  }
  project(v2) {
    v2.applyMatrix4(this.viewMatrix);
    v2.applyMatrix4(this.projectionMatrix);
    return this;
  }
  unproject(v2) {
    v2.applyMatrix4(tempMat4.invert(this.projectionMatrix));
    v2.applyMatrix4(this.worldMatrix);
    return this;
  }
  updateProjectionMatrix() {
    throw new Error(ERR_CAMERA_METHOD_UNDEFINED);
  }
};
_near = new WeakMap();
_far = new WeakMap();
_fov = new WeakMap();
_aspect = new WeakMap();
_zoom = new WeakMap();
_bounds2 = new WeakMap();
var PerspectiveCamera = class extends Camera {
  constructor(fov, aspect, near, far) {
    super({
      fov,
      aspect,
      near,
      far
    });
  }
  updateProjectionMatrix() {
    this.projectionMatrix.fromPerspective(this.fov, this.aspect, this.near, this.far);
  }
};
var OrthographicCamera = class extends Camera {
  constructor(left, right, top, bottom, near, far, zoom = 1) {
    super({
      bounds: {
        left,
        right,
        top,
        bottom
      },
      near,
      far,
      zoom
    });
  }
  updateProjectionMatrix() {
    const {
      left,
      right,
      top,
      bottom
    } = this.bounds;
    const { zoom } = this;
    this.projectionMatrix.orthographic(
      left / zoom,
      right / zoom,
      top / zoom,
      bottom / zoom,
      this.near,
      this.far
    );
  }
};

export {
  highPrecision,
  index,
  Clock,
  Raf,
  EventEmitter,
  Vector2,
  Quaternion,
  Vector3,
  Vector4,
  Matrix3,
  Matrix4,
  Euler,
  Color,
  ProjectionMatrix,
  Object3D,
  BufferAttribute,
  Geometry,
  Mesh,
  Scene,
  BlendType,
  State,
  Renderer,
  Resource,
  RenderBuffer,
  Texture,
  DataTexture,
  RenderTarget,
  getPlaneBuffer,
  Plane,
  Box,
  Program,
  Texture3D,
  Camera,
  PerspectiveCamera,
  OrthographicCamera
};
//# sourceMappingURL=chunk-SEC2ZWGE.js.map
