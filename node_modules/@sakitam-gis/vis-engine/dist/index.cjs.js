'use strict';

var glMatrix = require('gl-matrix');
var vec2 = require('gl-matrix/vec2');
var vec3 = require('gl-matrix/vec3');
var quat = require('gl-matrix/quat');
var vec4 = require('gl-matrix/vec4');
var mat3 = require('gl-matrix/mat3');
var mat4 = require('gl-matrix/mat4');
var colord = require('colord');

function parseShader(shader, defines = [], includes = []) {
  return shader.replace(/#defines/, defines.join("\n")).replace(/#includes/, includes.join("\n"));
}
function defineShader(shader, defines = {}) {
  return Object.keys(defines).reduce((str, key) => defines[key] ? `#define ${key} ${defines[key]}
${str}` : str, shader);
}
function getShaderName(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define\s*SHADER_NAME\s*([A-Za-z0-9_-]+)\s*/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
function getWireframeIndex(position, indices, numIndices, data) {
  const edges = /* @__PURE__ */ new Set();
  if (data) {
    for (let j = 0, l = numIndices; j < l; j += 3) {
      const a = data[j];
      const b = data[j + 1];
      const c = data[j + 2];
      const array = [a, b, b, c, c, a];
      for (let i = 0; i < array.length; i += 2) {
        if (isUniqueEdge(array[i] * 3, array[i + 1] * 3, position, edges)) {
          indices.push(array[i], array[i + 1]);
        }
      }
    }
  } else {
    for (let j = 0, l = numIndices; j < l; j += 3) {
      const a = j;
      const b = j + 1;
      const c = j + 2;
      const array = [a, b, b, c, c, a];
      for (let i = 0; i < array.length; i += 2) {
        if (isUniqueEdge(array[i] * 3, array[i + 1] * 3, position, edges)) {
          indices.push(array[i], array[i + 1]);
        }
      }
    }
  }
  return indices;
}
function isUniqueEdge(start, end, position, edges) {
  const hash1 = `${position[start]},${position[start + 1]},${position[start + 2]}-${position[end]},${position[end + 1]},${position[end + 2]}`;
  const hash2 = `${position[end]},${position[end + 1]},${position[end + 2]}-${position[start]},${position[start + 1]},${position[start + 2]}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}

const DEG_TO_RAD = Math.PI / 180;
const RAD_TO_DEG = 180 / Math.PI;
function degToRad(deg) {
  return deg * DEG_TO_RAD;
}
function radToDeg(a) {
  return a * RAD_TO_DEG;
}
function clamp(val, min, max) {
  return Math.min(Math.max(val, min), max);
}
function isPowerOfTwo(value) {
  return Math.log(value) / Math.LN2 % 1 === 0;
}
let FloatArray = Float32Array;
function highPrecision(b, notifyGlMatrix = true) {
  if (b) {
    FloatArray = Float64Array;
  } else {
    FloatArray = Float32Array;
  }
  if (notifyGlMatrix) {
    glMatrix.glMatrix.setMatrixArrayType(FloatArray);
  }
}
function getFloatArrayConstructor() {
  return FloatArray;
}

function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  if (gl?.gl && (gl.gl instanceof WebGLRenderingContext || gl.gl instanceof WebGL2RenderingContext)) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  if (gl?.gl && gl.gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getContext(canvas, glOptions = {}, requestWebGl2 = false) {
  const names = ["webgl2", "webgl", "experimental-webgl"];
  if (!requestWebGl2) {
    names.shift();
  }
  let context = null;
  function onContextCreationError(error) {
    console.error(error.statusMessage);
  }
  canvas?.addEventListener?.("webglcontextcreationerror", onContextCreationError, false);
  for (let ii = 0; ii < names.length; ++ii) {
    try {
      context = canvas.getContext(names[ii], glOptions);
    } catch (e) {
    }
    if (context) {
      break;
    }
  }
  canvas?.removeEventListener?.("webglcontextcreationerror", onContextCreationError, false);
  return context;
}

const now = () => ("undefined" == typeof performance ? Date : performance).now();
function typeOf(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}
function isString(s) {
  return typeOf(s) === "string";
}
function isUndef(s) {
  return typeOf(s) === "undefined";
}
function isHex(string) {
  return isString(string) && string.includes("%");
}
function isNumber(s) {
  return typeOf(s) === "number";
}
function isRegexp(obj) {
  return typeOf(obj) === "regexp";
}
function isNull(value) {
  return value == null;
}
function isObject(value) {
  const type = typeof value;
  return value !== null && (type === "object" || type === "function");
}
function hasValue(v, state) {
  if (isObject(v)) {
    return !isNull(v.value) && (isNull(state) || v.value === state);
  } else {
    return !isNull(v) && (isNull(state) || v === state);
  }
}
const uidCounters = {};
function uid(id = "id") {
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return `${id}-${count}`;
}
function omit(obj, keys = []) {
  return Object.keys(obj).filter((key) => keys.indexOf(key) < 0).reduce(
    (newObj, key) => Object.assign(newObj, {
      [key]: obj[key]
    }),
    {}
  );
}
function pick(obj, keys = []) {
  return Object.keys(obj).filter((key) => keys.indexOf(key) > -1).reduce(
    (newObj, key) => Object.assign(newObj, {
      [key]: obj[key]
    }),
    {}
  );
}
const callbacks = [];
const fpsInterval = 1e3 / 60;
let time = performance.now();
function requestAnimationFrameLoop() {
  const current = now();
  const delta = current - time;
  if (delta >= fpsInterval) {
    time = current - delta % fpsInterval;
    const funcs = callbacks.slice();
    callbacks.length = 0;
    for (let i = 0; i < funcs.length; i++) {
      funcs[i] && funcs[i](current, delta);
    }
  } else {
    setImmediate(requestAnimationFrameLoop);
  }
}
function raf(func) {
  callbacks.push(func);
  if (callbacks.length === 1) {
    setImmediate(requestAnimationFrameLoop);
  }
  return callbacks.length - 1;
}
function caf(id) {
  callbacks[id] = void 0;
}
function requestAnimationFrame(cb) {
  if (typeof window !== "undefined" && window.requestAnimationFrame) {
    return window.requestAnimationFrame(cb);
  }
  return raf(cb);
}
function cancelAnimationFrame(cb) {
  if (typeof window !== "undefined" && window.cancelAnimationFrame) {
    return window.cancelAnimationFrame(cb);
  }
  return caf(cb);
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DEG_TO_RAD: DEG_TO_RAD,
  RAD_TO_DEG: RAD_TO_DEG,
  cancelAnimationFrame: cancelAnimationFrame,
  clamp: clamp,
  defineShader: defineShader,
  degToRad: degToRad,
  getContext: getContext,
  getFloatArrayConstructor: getFloatArrayConstructor,
  getShaderName: getShaderName,
  getWireframeIndex: getWireframeIndex,
  hasValue: hasValue,
  highPrecision: highPrecision,
  isHex: isHex,
  isNull: isNull,
  isNumber: isNumber,
  isObject: isObject,
  isPowerOfTwo: isPowerOfTwo,
  isRegexp: isRegexp,
  isString: isString,
  isUndef: isUndef,
  isUniqueEdge: isUniqueEdge,
  isWebGL: isWebGL,
  isWebGL2: isWebGL2,
  now: now,
  omit: omit,
  parseShader: parseShader,
  pick: pick,
  radToDeg: radToDeg,
  requestAnimationFrame: requestAnimationFrame,
  typeOf: typeOf,
  uid: uid
});

class Clock {
  #lastTime = 0;
  #elapsedTime = 0;
  #start = false;
  running;
  constructor(running = true) {
    this.running = running;
  }
  start() {
    if (!this.#start) {
      this.reset();
      this.#start = true;
    }
  }
  stop() {
    this.getElapsedTime();
    this.#start = false;
    this.running = false;
  }
  reset() {
    this.#lastTime = now();
    this.#elapsedTime = 0;
  }
  getElapsedTime() {
    this.getDelta();
    return this.#elapsedTime;
  }
  getDelta() {
    let deltaTime = 0;
    if (this.running && !this.#start) {
      this.start();
      return 0;
    }
    if (this.#start) {
      const time = now();
      deltaTime = (time - this.#lastTime) / 1e3;
      this.#lastTime = time;
      this.#elapsedTime = this.#elapsedTime + deltaTime;
    }
    return deltaTime;
  }
}

const defaultOptions = {
  autoStart: true
};
class Raf {
  options;
  #raf;
  #animating;
  #isVisible;
  #clock;
  #callback;
  constructor(cb, options = {}) {
    this.options = {
      ...options,
      ...defaultOptions
    };
    this.#clock = new Clock();
    this.reset();
    this.onVisibilityChange = this.onVisibilityChange.bind(this);
    this.#callback = () => {
      const time = this.#clock.getElapsedTime();
      cb && cb(time);
    };
    if (this.options.autoStart) {
      this.start();
    }
  }
  get visible() {
    return this.#isVisible;
  }
  get animating() {
    return this.#animating;
  }
  reset() {
    this.#animating = false;
    this.#isVisible = true;
    if (this.#raf !== void 0) {
      cancelAnimationFrame(this.#raf);
    }
  }
  get elapsedTime() {
    return this.#clock.getElapsedTime();
  }
  start() {
    if (this.#animating)
      return;
    this.#animating = true;
    this.#clock.start();
    this.tick();
    if (typeof window !== "undefined" && window.document) {
      window.document.addEventListener("visibilitychange", this.onVisibilityChange, false);
    }
  }
  stop() {
    this.#clock.stop();
    this.reset();
    if (typeof window !== "undefined" && window.document) {
      window.document.removeEventListener("visibilitychange", this.onVisibilityChange, false);
    }
  }
  tick() {
    if (!this.#animating || !this.#isVisible)
      return;
    this.#raf = requestAnimationFrame(() => {
      this.tick();
    });
    this.#callback();
  }
  onVisibilityChange() {
    if (typeof window !== "undefined" && window.document) {
      this.#isVisible = !window.document.hidden;
    }
    if (this.#isVisible) {
      this.reset();
      this.start();
    }
  }
}

class Event {
  type;
  constructor(type, params = {}) {
    this.type = type;
    (Object.getOwnPropertyNames(params) || []).forEach((key) => {
      this[key] = params[key];
    });
  }
}
class EventEmitter {
  fns;
  validateEventTypes;
  constructor({ validEventTypes = [/.*/] } = {}) {
    this.fns = /* @__PURE__ */ new Map();
    this.validateEventTypes = validEventTypes;
  }
  validateEventType(type) {
    let vs = this.validateEventTypes;
    if (!Array.isArray(this.validateEventTypes)) {
      vs = [this.validateEventTypes];
    }
    let isValid = true;
    vs.forEach((r) => {
      if (isRegexp(r) && !r.test(type)) {
        isValid = false;
      }
    });
    if (!isValid) {
      throw new Error(`Invalid Event Type: '${type}'.
Event type should be any of: ${vs}.`);
    }
  }
  on(type, handler, context) {
    this.validateEventType(type);
    if (isString(type)) {
      const names = type.split(" ");
      if (names.length > 1) {
        names.forEach((t) => {
          this.on(t, handler, context);
        });
        return this;
      }
    }
    if (!this.has(type)) {
      this.fns.set(type, []);
    }
    this.fns.get(type).push(handler);
    return this;
  }
  once(type, handler, context) {
    this.validateEventType(type);
    if (isString(type)) {
      const names = type.split(" ");
      if (names.length > 1) {
        names.forEach((t) => {
          this.once(t, handler, context);
        });
        return this;
      }
    }
    const onceHandler = (...args) => {
      this.off(type, onceHandler);
      handler.call(context || this, ...args);
    };
    return this.on(type, onceHandler, context);
  }
  off(type, handler, context) {
    this.validateEventType(type);
    if (isString(type)) {
      const names = type.split(" ");
      if (names.length > 1) {
        names.forEach((t) => {
          this.off(t, handler, context);
        });
        return this;
      }
    }
    const handlers = this.has(type);
    if (handlers) {
      if (handler) {
        const fns = handlers.filter((h) => h !== handler);
        this.fns.set(type, fns);
      } else {
        this.fns.delete(type);
      }
    }
    return this;
  }
  emit(type, args) {
    const eventObject = type instanceof Event ? type : new Event(type, args);
    this.validateEventType(eventObject.type);
    const fns = this.has(eventObject.type);
    if (fns) {
      return fns.map((fn) => fn.call(this, eventObject));
    }
  }
  has(type) {
    return this.fns.get(type);
  }
  clear() {
    this.fns.clear();
    return this;
  }
}

class Vector {
  elements = new (getFloatArrayConstructor())(2);
  fromArray(array, offset = 0) {
    let i = 0;
    for (; i < this.elements.length; i++) {
      this.elements[i] = array[offset + i];
    }
    return this;
  }
  toArray(out = [], offset = 0) {
    let i = 0;
    for (; i < this.elements.length; i++) {
      out[offset + i] = this.elements[i];
    }
    return out;
  }
}

class Vector2 extends Vector {
  elements = new (getFloatArrayConstructor())(2);
  constructor(x = 0, y = 0) {
    super();
    const v = this.elements;
    v[0] = x;
    v[1] = y;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  fromObject(object) {
    const { x, y } = object;
    if (x !== void 0)
      this.x = x;
    if (y !== void 0)
      this.y = y;
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y
    };
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(s) {
    return this.set(s, s);
  }
  add(vec) {
    vec2.add(this.elements, this.elements, vec.elements);
    return this;
  }
  addScalar(v) {
    vec2.add(this.elements, this.elements, [v, v]);
    return this;
  }
  subtract(vec) {
    vec2.subtract(this.elements, this.elements, vec.elements);
    return this;
  }
  subtractScalar(v) {
    vec2.subtract(this.elements, this.elements, [v, v]);
    return this;
  }
  multiply(vec) {
    vec2.multiply(this.elements, this.elements, vec.elements);
    return this;
  }
  multiplyScalar(v) {
    vec2.multiply(this.elements, this.elements, [v, v]);
    return this;
  }
  divide(vec) {
    vec2.divide(this.elements, this.elements, vec.elements);
    return this;
  }
  divideScalar(v) {
    vec2.divide(this.elements, this.elements, [v, v]);
    return this;
  }
  scale(s) {
    vec2.scale(this.elements, this.elements, s);
    return this;
  }
  distanceTo(vec) {
    return vec2.distance(this.elements, vec.elements);
  }
  length() {
    return vec2.length(this.elements);
  }
  distanceToSquared(v) {
    return vec2.squaredDistance(v.elements, this.elements);
  }
  angle() {
    return vec2.angle(this.elements, [1, 0]);
  }
  angleTo(v) {
    return vec2.angle(this.elements, v.elements);
  }
  dot(vec) {
    return vec2.dot(this.elements, vec.elements);
  }
  equals(vec) {
    return vec2.equals(this.elements, vec.elements);
  }
  cross(vec) {
    vec2.cross(this.elements, this.elements, vec.elements);
    return this;
  }
  negate() {
    vec2.negate(this.elements, this.elements);
    return this;
  }
  inverse() {
    vec2.inverse(this.elements, this.elements);
    return this;
  }
  lerp(vec, t) {
    vec2.lerp(this.elements, this.elements, vec.elements, t);
    return this;
  }
  normalize() {
    vec2.normalize(this.elements, this.elements);
    return this;
  }
  applyMatrix3(matrix) {
    vec2.transformMat3(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyMatrix4(matrix) {
    vec2.transformMat4(this.elements, this.elements, matrix.elements);
    return this;
  }
  copy(vec2) {
    this.x = vec2.x;
    this.y = vec2.y;
    return this;
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

const tempArray$1 = [];
class Quaternion extends Vector {
  elements = new (getFloatArrayConstructor())(4);
  #changeCallbacks = [];
  constructor(x = 0, y = 0, z = 0, w = 0) {
    super();
    const v = this.elements;
    v[0] = x;
    v[1] = y;
    v[2] = z;
    v[3] = w;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
    this.triggerChange();
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
    this.triggerChange();
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
    this.triggerChange();
  }
  get w() {
    return this.elements[3];
  }
  set w(w) {
    this.elements[3] = w;
    this.triggerChange();
  }
  fromObject({ x, y, z, w }) {
    if (x !== void 0)
      this.x = x;
    if (y !== void 0)
      this.y = y;
    if (z !== void 0)
      this.z = z;
    if (w !== void 0)
      this.w = w;
    this.triggerChange();
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
  fromAxisAngle(axis, rad) {
    quat.setAxisAngle(this.elements, axis.elements, rad);
    this.triggerChange();
    return this;
  }
  getAxisAngle(axis = new Vector3()) {
    const rad = quat.getAxisAngle(tempArray$1, this.elements);
    axis.set(tempArray$1[0], tempArray$1[1], tempArray$1[2]);
    return rad;
  }
  fromEuler(e) {
    quat.fromEuler(this.elements, radToDeg(e.x), radToDeg(e.y), radToDeg(e.z));
    this.triggerChange();
    return this;
  }
  fromMat3(m) {
    quat.fromMat3(this.elements, m);
    return this;
  }
  set(x, y, z, w) {
    quat.set(this.elements, x, y, z, w);
    this.triggerChange();
    return this;
  }
  length() {
    return quat.length(this.elements);
  }
  multiply(a, b) {
    if (b) {
      quat.multiply(this.elements, a.elements, b.elements);
    } else {
      quat.multiply(this.elements, this.elements, a.elements);
    }
    this.triggerChange();
    return this;
  }
  slerp(q, t) {
    quat.slerp(this.elements, this.elements, q.elements, t);
    this.triggerChange();
    return this;
  }
  invert() {
    quat.invert(this.elements, this.elements);
    this.triggerChange();
    return this;
  }
  conjugate() {
    quat.conjugate(this.elements, this.elements);
    this.triggerChange();
    return this;
  }
  normalize() {
    quat.normalize(this.elements, this.elements);
    this.triggerChange();
    return this;
  }
  dot(q) {
    return quat.dot(this.elements, q.elements);
  }
  angleTo(q) {
    return quat.getAngle(this.elements, q.elements);
  }
  clone() {
    return new Quaternion().copy(this);
  }
  copy(q) {
    quat.copy(this.elements, q.elements);
    this.triggerChange();
    return this;
  }
  equals(q) {
    return vec4.equals(this.elements, q.elements);
  }
  onChange(fn) {
    if (!this.#changeCallbacks.includes(fn)) {
      this.#changeCallbacks.push(fn);
    }
  }
  triggerChange() {
    this.#changeCallbacks.forEach((cb) => cb());
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

class Vector3 extends Vector {
  elements = new (getFloatArrayConstructor())(3);
  constructor(x = 0, y = 0, z = 0) {
    super();
    const v = this.elements;
    v[0] = x;
    v[1] = y;
    v[2] = z;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  fromObject(object) {
    const { x, y, z } = object;
    if (x !== void 0)
      this.x = x;
    if (y !== void 0)
      this.y = y;
    if (z !== void 0)
      this.z = z;
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
  set(x, y, z) {
    vec3.set(this.elements, x, y, z);
    return this;
  }
  setScalar(s) {
    return this.set(s, s, s);
  }
  length() {
    return vec3.length(this.elements);
  }
  add(vec) {
    vec3.add(this.elements, this.elements, vec.elements);
    return this;
  }
  addScalar(v) {
    vec3.add(this.elements, this.elements, [v, v, v]);
    return this;
  }
  subtract(vec) {
    vec3.subtract(this.elements, this.elements, vec.elements);
    return this;
  }
  subtractScalar(v) {
    vec3.subtract(this.elements, this.elements, [v, v, v]);
    return this;
  }
  subVectors(a, b) {
    vec3.subtract(this.elements, a.elements, b.elements);
    return this;
  }
  multiply(vec) {
    vec3.multiply(this.elements, this.elements, vec.elements);
    return this;
  }
  multiplyScalar(v) {
    vec3.multiply(this.elements, this.elements, [v, v, v]);
    return this;
  }
  divide(vec) {
    vec3.divide(this.elements, this.elements, vec.elements);
    return this;
  }
  divideScalar(v) {
    vec3.divide(this.elements, this.elements, [v, v, v]);
    return this;
  }
  scale(s) {
    vec3.scale(this.elements, this.elements, s);
    return this;
  }
  scaleAndAdd(v, s) {
    vec3.scaleAndAdd(this.elements, this.elements, v.elements, s);
    return this;
  }
  distanceTo(vec) {
    return vec3.distance(this.elements, vec.elements);
  }
  distanceToSquared(vec) {
    return vec3.squaredDistance(this.elements, vec.elements);
  }
  angle(vector) {
    return vec3.angle(this.elements, [1, 0, 0]);
  }
  angleTo(vector) {
    return vec3.angle(this.elements, vector.elements);
  }
  dot(vec) {
    return vec3.dot(this.elements, vec.elements);
  }
  equals(vec) {
    return vec3.equals(this.elements, vec.elements);
  }
  cross(vec) {
    vec3.cross(this.elements, this.elements, vec.elements);
    return this;
  }
  negate() {
    vec3.negate(this.elements, this.elements);
    return this;
  }
  inverse() {
    vec3.inverse(this.elements, this.elements);
    return this;
  }
  lerp(vec, t) {
    vec3.lerp(this.elements, this.elements, vec.elements, t);
    return this;
  }
  normalize() {
    vec3.normalize(this.elements, this.elements);
    return this;
  }
  applyEuler(euler) {
    const e = new Quaternion().fromEuler(euler);
    return this.applyQuaternion(e);
  }
  applyMatrix3(matrix) {
    vec3.transformMat3(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyMatrix4(matrix) {
    vec3.transformMat4(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyQuaternion(quaternion) {
    vec3.transformQuat(this.elements, this.elements, quaternion.elements);
    return this;
  }
  copy(vec3) {
    this.x = vec3.x;
    this.y = vec3.y;
    this.z = vec3.z;
    return this;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

class Vector4 extends Vector {
  elements = new (getFloatArrayConstructor())(4);
  constructor(x = 0, y = 0, z = 0, w = 0) {
    super();
    const v = this.elements;
    v[0] = x;
    v[1] = y;
    v[2] = z;
    v[3] = w;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  get w() {
    return this.elements[3];
  }
  set w(w) {
    this.elements[3] = w;
  }
  fromObject(object) {
    const { x, y, z, w } = object;
    if (x !== void 0)
      this.x = x;
    if (y !== void 0)
      this.y = y;
    if (z !== void 0)
      this.z = z;
    if (w !== void 0)
      this.w = w;
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
  set(x, y, z, w) {
    vec4.set(this.elements, x, y, z, w);
    return this;
  }
  setScalar(s) {
    return this.set(s, s, s, s);
  }
  add(vec) {
    vec4.add(this.elements, this.elements, vec.elements);
    return this;
  }
  addScalar(v) {
    vec4.add(this.elements, this.elements, [v, v, v, v]);
    return this;
  }
  subtract(vec) {
    vec4.subtract(this.elements, this.elements, vec.elements);
    return this;
  }
  subtractScalar(v) {
    vec4.subtract(this.elements, this.elements, [v, v, v, v]);
    return this;
  }
  subVectors(a, b) {
    vec4.subtract(this.elements, a.elements, b.elements);
    return this;
  }
  multiply(vec) {
    vec4.multiply(this.elements, this.elements, vec.elements);
    return this;
  }
  multiplyScalar(v) {
    vec4.multiply(this.elements, this.elements, [v, v, v, v]);
    return this;
  }
  divide(vec) {
    vec4.divide(this.elements, this.elements, vec.elements);
    return this;
  }
  divideScalar(v) {
    vec4.divide(this.elements, this.elements, [v, v, v, v]);
    return this;
  }
  scale(s) {
    vec4.scale(this.elements, this.elements, s);
    return this;
  }
  scaleAndAdd(v, s) {
    vec4.scaleAndAdd(this.elements, this.elements, v.elements, s);
    return this;
  }
  distanceTo(vec) {
    return vec4.distance(this.elements, vec.elements);
  }
  distanceToSquared(vec) {
    return vec4.squaredDistance(this.elements, vec.elements);
  }
  length() {
    return vec4.length(this.elements);
  }
  dot(vec) {
    return vec4.dot(this.elements, vec.elements);
  }
  equals(vec) {
    return vec4.equals(this.elements, vec.elements);
  }
  cross(vec) {
    vec4.cross(this.elements, this.elements, vec.elements);
    return this;
  }
  negate() {
    vec4.negate(this.elements, this.elements);
    return this;
  }
  inverse() {
    vec4.inverse(this.elements, this.elements);
    return this;
  }
  lerp(vec, t) {
    vec4.lerp(this.elements, this.elements, vec.elements, t);
    return this;
  }
  normalize() {
    vec4.normalize(this.elements, this.elements);
    return this;
  }
  applyMatrix4(matrix) {
    vec4.transformMat4(this.elements, this.elements, matrix.elements);
    return this;
  }
  applyQuaternion(quaternion) {
    vec4.transformQuat(this.elements, this.elements, quaternion.elements);
    return this;
  }
  copy(vec4) {
    this.x = vec4.x;
    this.y = vec4.y;
    this.z = vec4.z;
    this.w = vec4.w;
    return this;
  }
  clone() {
    return new Vector4(this.x, this.y, this.z, this.w);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

class Matrix {
  elements = new (getFloatArrayConstructor())(16);
  fromArray(array, offset = 0) {
    let i = 0;
    for (; i < this.elements.length; i++) {
      this.elements[i] = array[offset + i];
    }
    return this;
  }
  toArray(out = [], offset = 0) {
    let i = 0;
    for (; i < this.elements.length; i++) {
      out[offset + i] = this.elements[i];
    }
    return out;
  }
}

class Matrix3 extends Matrix {
  elements = new (getFloatArrayConstructor())(9);
  constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {
    super();
    const e = this.elements;
    e[0] = m00;
    e[1] = m01;
    e[2] = m02;
    e[3] = m10;
    e[4] = m11;
    e[5] = m12;
    e[6] = m20;
    e[7] = m21;
    e[8] = m22;
  }
  get x() {
    return this.elements[2];
  }
  get y() {
    return this.elements[5];
  }
  get z() {
    return this.elements[8];
  }
  static get identity() {
    return new Matrix3().fromArray(mat3.identity([]));
  }
  set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    mat3.set(this.elements, m00, m01, m02, m10, m11, m12, m20, m21, m22);
    return this;
  }
  transpose() {
    mat3.transpose(this.elements, this.elements);
    return this;
  }
  invert(m = this) {
    mat3.invert(this.elements, m.elements);
    return this;
  }
  adjoint(m = this) {
    mat3.adjoint(this.elements, m.elements);
    return this;
  }
  determinant() {
    return mat3.determinant(this.elements);
  }
  multiply(a, b) {
    if (b) {
      mat3.multiply(this.elements, a.elements, b.elements);
    } else {
      mat3.multiply(this.elements, this.elements, a.elements);
    }
    return this;
  }
  premultiply(a, b) {
    if (b) {
      mat3.multiply(this.elements, b.elements, a.elements);
    } else {
      mat3.multiply(this.elements, a.elements, this.elements);
    }
    return this;
  }
  translate(v) {
    mat3.translate(this.elements, this.elements, v.elements);
    return this;
  }
  rotate(rad) {
    mat3.rotate(this.elements, this.elements, rad);
    return this;
  }
  scale(v) {
    mat3.scale(this.elements, this.elements, v.elements);
    return this;
  }
  fromTranslation(v) {
    mat3.fromTranslation(this.elements, v.elements);
    return this;
  }
  fromRotation(rad) {
    mat3.fromRotation(this.elements, rad);
    return this;
  }
  fromScaling(v) {
    mat3.fromScaling(this.elements, v.elements);
    return this;
  }
  fromQuat(q) {
    mat3.fromQuat(this.elements, q.elements);
    return this;
  }
  normalFromMat4(m) {
    mat3.normalFromMat4(this.elements, m.elements);
    return this;
  }
  fromMat4(m) {
    mat3.fromMat4(this.elements, m.elements);
    return this;
  }
  frob() {
    return mat3.frob(this.elements);
  }
  add(a, b) {
    if (b) {
      mat3.add(this.elements, a.elements, b.elements);
    } else {
      mat3.add(this.elements, this.elements, a.elements);
    }
    return this;
  }
  subtract(a, b) {
    if (b) {
      mat3.subtract(this.elements, a.elements, b.elements);
    } else {
      mat3.subtract(this.elements, this.elements, a.elements);
    }
    return this;
  }
  equals(a, b) {
    if (b) {
      return mat3.equals(a.elements, b.elements);
    } else {
      return mat3.equals(this.elements, a.elements);
    }
  }
  fromRotationTranslationScale(rotation, x, y, scaleX, scaleY) {
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    this.set(scaleX * cos, -scaleY * sin, 0, scaleX * sin, scaleY * cos, 0, x, y, 1);
    return this;
  }
  getNormalMatrix(m) {
    mat3.normalFromMat4(this.elements, m.elements);
    return this;
  }
  copy(m) {
    mat3.copy(this.elements, m.elements);
    return this;
  }
  clone() {
    return new Matrix3().copy(this);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

const tempArray = [];
class Matrix4 extends Matrix {
  elements = new (getFloatArrayConstructor())(16);
  constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1) {
    super();
    const e = this.elements;
    e[0] = m00;
    e[1] = m01;
    e[2] = m02;
    e[3] = m03;
    e[4] = m10;
    e[5] = m11;
    e[6] = m12;
    e[7] = m13;
    e[8] = m20;
    e[9] = m21;
    e[10] = m22;
    e[11] = m23;
    e[12] = m30;
    e[13] = m31;
    e[14] = m32;
    e[15] = m33;
  }
  get x() {
    return this.elements[12];
  }
  get y() {
    return this.elements[13];
  }
  get z() {
    return this.elements[14];
  }
  get w() {
    return this.elements[15];
  }
  static get identity() {
    return new Matrix4().fromArray(mat4.identity([]));
  }
  set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    mat4.set(this.elements, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    return this;
  }
  transpose() {
    mat4.transpose(this.elements, this.elements);
    return this;
  }
  invert(m = this) {
    mat4.invert(this.elements, m.elements);
    return this;
  }
  adjoint(m = this) {
    mat4.adjoint(this.elements, m.elements);
    return this;
  }
  determinant() {
    return mat4.determinant(this.elements);
  }
  add(a, b) {
    if (b) {
      mat4.add(this.elements, a.elements, b.elements);
    } else {
      mat4.add(this.elements, this.elements, a.elements);
    }
    return this;
  }
  subtract(a, b) {
    if (b) {
      mat4.subtract(this.elements, a.elements, b.elements);
    } else {
      mat4.subtract(this.elements, this.elements, a.elements);
    }
    return this;
  }
  multiply(a, b) {
    if (b) {
      mat4.multiply(this.elements, a.elements, b.elements);
    } else {
      mat4.multiply(this.elements, this.elements, a.elements);
    }
    return this;
  }
  multiplyScalar(a = this, b) {
    mat4.multiplyScalar(this.elements, a.elements, b);
    return this;
  }
  premultiply(a, b) {
    if (b) {
      mat4.multiply(this.elements, b.elements, a.elements);
    } else {
      mat4.multiply(this.elements, a.elements, this.elements);
    }
    return this;
  }
  translate(v) {
    mat4.translate(this.elements, this.elements, v.elements);
    return this;
  }
  rotate(rad) {
    mat4.rotate(this.elements, this.elements, rad);
    return this;
  }
  scale(vec3) {
    mat4.scale(this.elements, this.elements, vec3.elements);
    return this;
  }
  scaleScalar(s) {
    mat4.scale(this.elements, this.elements, [s, s, s]);
    return this;
  }
  fromTranslation(vec) {
    mat4.fromTranslation(this.elements, vec.elements);
    return this;
  }
  fromRotation(rad, axis) {
    mat4.fromRotation(this.elements, rad, axis);
    return this;
  }
  fromRotationX(rad) {
    mat4.fromXRotation(this.elements, rad);
    return this;
  }
  fromRotationY(rad) {
    mat4.fromYRotation(this.elements, rad);
    return this;
  }
  fromRotationZ(rad) {
    mat4.fromZRotation(this.elements, rad);
    return this;
  }
  fromScale(vec) {
    mat4.fromScaling(this.elements, vec.elements);
    return this;
  }
  fromRotationTranslation(quat, v) {
    mat4.fromRotationTranslation(this.elements, quat.elements, v.elements);
    return this;
  }
  fromPerspective(fov, aspect, near, far) {
    mat4.perspective(this.elements, degToRad(fov), aspect, near, far);
    return this;
  }
  fromOrthogonal(left, right, bottom, top, near, far) {
    mat4.ortho(this.elements, left, right, bottom, top, near, far);
    return this;
  }
  fromQuat(q) {
    mat4.fromQuat(this.elements, q.elements);
    return this;
  }
  equals(mat4$1) {
    return mat4.equals(this.elements, mat4$1.value);
  }
  getRotation(q = new Quaternion()) {
    mat4.getRotation(tempArray, this.elements);
    q.set(tempArray[0], tempArray[1], tempArray[2], tempArray[3]);
    return q;
  }
  getScale(v = new Vector3()) {
    mat4.getScaling(tempArray, this.elements);
    v.set(tempArray[0], tempArray[1], tempArray[2]);
    return v;
  }
  getTranslation(v = new Vector3()) {
    mat4.getTranslation(tempArray, this.elements);
    v.set(tempArray[0], tempArray[1], tempArray[2]);
    return v;
  }
  rotateX(rad) {
    mat4.rotateX(this.elements, this.elements, rad);
    return this;
  }
  rotateY(rad) {
    mat4.rotateY(this.elements, this.elements, rad);
    return this;
  }
  rotateZ(rad) {
    mat4.rotateZ(this.elements, this.elements, rad);
    return this;
  }
  compose(v, q, s) {
    mat4.fromRotationTranslationScale(this.elements, q.elements, v.elements, s.elements);
    return this;
  }
  decompose() {
    return {
      rotation: this.getRotation(),
      scale: this.getScale(),
      translation: this.getTranslation()
    };
  }
  copy(m) {
    mat4.copy(this.elements, m.elements);
    return this;
  }
  clone() {
    return new Matrix4().copy(this);
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

class Euler extends Vector {
  elements = new (getFloatArrayConstructor())(3);
  #changeCallbacks = [];
  #order = "xyz";
  constructor(x = 0, y = 0, z = 0, order = "xyz") {
    super();
    const v = this.elements;
    v[0] = x;
    v[1] = y;
    v[2] = z;
    this.#order = order;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
    this.triggerChange();
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
    this.triggerChange();
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
    this.triggerChange();
  }
  get order() {
    return this.#order;
  }
  set order(order) {
    this.#order = order;
    this.triggerChange();
  }
  get roll() {
    return this.x;
  }
  set roll(roll) {
    this.x = roll;
  }
  get pitch() {
    return this.y;
  }
  set pitch(pitch) {
    this.y = pitch;
  }
  get yaw() {
    return this.z;
  }
  set yaw(yaw) {
    this.z = yaw;
  }
  fromObject({ x, y, z, order }) {
    if (x !== void 0) {
      this.x = x;
    }
    if (y !== void 0) {
      this.y = y;
    }
    if (z !== void 0) {
      this.z = z;
    }
    if (order !== void 0) {
      this.order = order;
    }
    this.triggerChange();
    return this;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      order: this.order
    };
  }
  fromRotationMatrix(m, order = this.#order, update = true) {
    const te = m.toArray();
    const m11 = te[0];
    const m12 = te[4];
    const m13 = te[8];
    const m21 = te[1];
    const m22 = te[5];
    const m23 = te[9];
    const m31 = te[2];
    const m32 = te[6];
    const m33 = te[10];
    switch (order) {
      case "xyz":
        this.y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this.x = Math.atan2(-m23, m33);
          this.z = Math.atan2(-m12, m11);
        } else {
          this.x = Math.atan2(m32, m22);
          this.z = 0;
        }
        break;
      case "yxz":
        this.x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this.y = Math.atan2(m13, m33);
          this.z = Math.atan2(m21, m22);
        } else {
          this.y = Math.atan2(-m31, m11);
          this.z = 0;
        }
        break;
      case "zxy":
        this.x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this.y = Math.atan2(-m31, m33);
          this.z = Math.atan2(-m12, m22);
        } else {
          this.y = 0;
          this.z = Math.atan2(m21, m11);
        }
        break;
      case "zyx":
        this.y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this.x = Math.atan2(m32, m33);
          this.z = Math.atan2(m21, m11);
        } else {
          this.x = 0;
          this.z = Math.atan2(-m12, m22);
        }
        break;
      case "yzx":
        this.z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this.x = Math.atan2(-m23, m22);
          this.y = Math.atan2(-m31, m11);
        } else {
          this.x = 0;
          this.y = Math.atan2(m13, m33);
        }
        break;
      case "xzy":
        this.z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this.x = Math.atan2(m32, m22);
          this.y = Math.atan2(m13, m11);
        } else {
          this.x = Math.atan2(-m23, m33);
          this.y = 0;
        }
        break;
      default:
        throw new Error("Unknown Euler angle order");
    }
    this.#order = order;
    if (update) {
      this.triggerChange();
    }
    return this;
  }
  fromQuaternion(q) {
    const [x, y, z, w] = q.elements;
    const a = y * y;
    const s = -2 * (a + z * z) + 1;
    const o = 2 * (x * y + w * z);
    let l = -2 * (x * z - w * y);
    const c = 2 * (y * z + w * x);
    const h = -2 * (x * x + a) + 1;
    l = l > 1 ? 1 : l;
    l = l < -1 ? -1 : l;
    const d = Math.atan2(c, h);
    const u = Math.asin(l);
    const f = Math.atan2(o, s);
    return new Euler(d, u, f, "zyx");
  }
  fromVector3(vec3, order = this.#order) {
    return this.set(vec3.x, vec3.y, vec3.z, order);
  }
  toQuaternion() {
    const t = Math.cos(0.5 * this.yaw);
    const e = Math.sin(0.5 * this.yaw);
    const n = Math.cos(0.5 * this.roll);
    const r = Math.sin(0.5 * this.roll);
    const i = Math.cos(0.5 * this.pitch);
    const a = Math.sin(0.5 * this.pitch);
    return new Quaternion(
      t * r * i - e * n * a,
      t * n * a + e * r * i,
      e * n * i - t * r * a,
      t * n * i + e * r * a
    );
  }
  toVector3() {
    return new Vector3(this.x, this.y, this.z);
  }
  set(x, y, z, order = this.#order) {
    this.elements[0] = x;
    this.elements[1] = y;
    this.elements[2] = z;
    this.#order = order;
    this.triggerChange();
    return this;
  }
  clone() {
    return new Euler().copy(this);
  }
  copy(euler) {
    let i = 0;
    for (; i < this.elements.length; i++) {
      this.elements[i] = euler.elements[i];
    }
    this.#order = euler.order;
    this.triggerChange();
    return this;
  }
  equals(e) {
    return this.x === e.x && this.y === e.y && this.z === e.z && this.order === e.order;
  }
  onChange(cb) {
    if (!this.#changeCallbacks.includes(cb)) {
      this.#changeCallbacks.push(cb);
    }
  }
  triggerChange() {
    this.#changeCallbacks.forEach((f) => f());
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

function namesPlugin(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return "transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g);}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"]);}

colord.extend([namesPlugin]);
const normalize = (a, min, max) => {
  const hex = isHex(a);
  const diff = max - min;
  let v = clamp(Number.parseFloat(`${a}`), min, max);
  if (hex) {
    v = Number.parseInt("" + a * max, 10) / 100;
  }
  return Math.abs(v - max) < 1e-6 ? 1 : a % diff / diff;
};
class Color {
  r;
  g;
  b;
  a;
  constructor(v = 255, g, b, a = 1, isNormalized = false) {
    this.r = 1;
    this.g = 1;
    this.b = 1;
    this.a = 1;
    if (isUndef(g) && isUndef(b)) {
      if (isNumber(v) && v <= 255) {
        this.setRGBA(v, v, v, this.a, isNormalized);
      } else {
        const rgb = colord.colord(v).toRgb();
        if (rgb) {
          this.setRGBA(rgb.r, rgb.g, rgb.b, rgb.a);
        } else {
          console.error("Unsupported color value {".concat(String(v), "} provided"));
        }
      }
    } else {
      this.setRGBA(v, g, b, a);
    }
  }
  fromColor(c) {
    const color = colord.colord(c).toRgb();
    return this.setRGBA(color.r, color.g, color.b, color.a);
  }
  fromHSL(h, s, l, a = 1) {
    const color = colord.colord({
      h,
      s,
      l,
      a
    }).toRgb();
    return this.setRGBA(color.r, color.g, color.b, color.a);
  }
  fromHSV(h, s, v, a = 1) {
    const color = colord.colord({
      h,
      s,
      v,
      a
    }).toRgb();
    return this.setRGBA(color.r, color.g, color.b, color.a);
  }
  setRGB(r, g, b) {
    this.setRGBA(r, g, b, this.a);
    return this;
  }
  setRGBA(r, g, b, a, isNormalized) {
    this.r = isNormalized ? r : normalize(r, 0, 255);
    this.g = isNormalized ? g : normalize(g, 0, 255);
    this.b = isNormalized ? b : normalize(b, 0, 255);
    this.setAlpha(a);
    return this;
  }
  setAlpha(alpha) {
    if (alpha > 1) {
      this.a = normalize(alpha, 0, 255);
    } else {
      this.a = alpha;
    }
    return this;
  }
  toHex() {
    return colord.colord(this.toObject()).toHex();
  }
  toHSL() {
    return colord.colord(this.toObject()).toHsl();
  }
  toHSV() {
    return colord.colord(this.toObject()).toHsv();
  }
  toObject(isNormalized = false) {
    const m = isNormalized ? 1 : 255;
    return {
      r: this.r * m,
      g: this.g * m,
      b: this.b * m,
      a: this.a
    };
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toVector() {
    return new Vector4().fromArray(this.toArray());
  }
  toVector3() {
    return new Vector3().fromArray(this.toArray());
  }
  toString() {
    return `${this.constructor.name}(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
  }
}

class ProjectionMatrix extends Matrix4 {
  frustum(mat4$1, left, right, top, bottom, near, far) {
    mat4.frustum(mat4$1.elements, left, right, bottom, top, near, far);
    return this;
  }
  orthographic(left, right, top, bottom, near, far) {
    mat4.ortho(this.elements, left, right, bottom, top, near, far);
    return this;
  }
  perspective(fovy, aspect, near, far) {
    mat4.perspective(this.elements, fovy, aspect, near, far);
    return this;
  }
  lookAt(eye, target = new Vector3(0, 0, 0), up = new Vector3(0, 1, 0)) {
    mat4.lookAt(this.elements, eye.elements, target.elements, up.elements);
    return this;
  }
  toString() {
    return `${this.constructor.name}(${this.elements.join(", ")})`;
  }
}

class Object3D {
  visible;
  localMatrix;
  worldMatrix;
  matrixAutoUpdate;
  position;
  scale;
  rotation;
  quaternion;
  up;
  children;
  parent;
  worldMatrixNeedsUpdate;
  constructor() {
    this.visible = true;
    this.localMatrix = new ProjectionMatrix();
    this.worldMatrix = new ProjectionMatrix();
    this.matrixAutoUpdate = true;
    this.position = new Vector3();
    this.scale = new Vector3(1, 1, 1);
    this.rotation = new Euler();
    this.quaternion = new Quaternion();
    this.up = new Vector3(0, 1, 0);
    this.parent = null;
    this.children = [];
    this.worldMatrixNeedsUpdate = false;
    this.rotation.onChange(() => {
      this.quaternion.fromEuler(this.rotation);
    });
    this.quaternion.onChange(() => {
      this.rotation.fromQuaternion(this.quaternion);
    });
  }
  add(object, notifyChild = true) {
    if (!this.contains(object)) {
      this.children.push(object);
    }
    if (notifyChild) {
      object.setParent(this, false);
    }
  }
  remove(object, notifyChild = true) {
    if (this.contains(object)) {
      this.children.splice(this.children.indexOf(object), 1);
    }
    if (notifyChild) {
      object.setParent(null, false);
    }
  }
  contains(object) {
    return this.children.includes(object);
  }
  setParent(object, notifyParent = true) {
    if (this.parent && object !== this.parent) {
      this.parent.remove(this, false);
    }
    this.parent = object;
    if (notifyParent && object) {
      object.add(this, false);
    }
  }
  traverse(callback) {
    if (!callback(this)) {
      for (let i = 0, l = this.children.length; i < l; i++) {
        this.children[i].traverse(callback);
      }
    }
  }
  lookAt(eye, invert) {
    if (invert) {
      this.localMatrix.lookAt(this.position, eye, this.up);
    } else {
      this.localMatrix.lookAt(eye, this.position, this.up);
    }
    this.localMatrix.getRotation(this.quaternion);
    this.rotation.fromQuaternion(this.quaternion);
  }
  updateMatrixWorld(force) {
    let f = force;
    if (this.matrixAutoUpdate) {
      this.updateMatrix();
    }
    if (this.worldMatrixNeedsUpdate || f) {
      if (this.parent === null) {
        this.worldMatrix.copy(this.localMatrix);
      } else {
        this.worldMatrix.multiply(this.parent.worldMatrix, this.localMatrix);
      }
      this.worldMatrixNeedsUpdate = false;
      f = true;
    }
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      child.updateMatrixWorld(f);
    }
  }
  updateMatrix() {
    this.localMatrix.compose(this.position, this.quaternion, this.scale);
    this.worldMatrixNeedsUpdate = true;
  }
  decompose() {
    this.localMatrix.getTranslation(this.position);
    this.localMatrix.getRotation(this.quaternion);
    this.localMatrix.getScale(this.scale);
    this.rotation.fromQuaternion(this.quaternion);
  }
  clone() {
    return new Object3D().copy(this, false);
  }
  copy(object, recursive) {
    this.visible = object.visible;
    this.position.copy(object.position);
    this.scale.copy(object.scale);
    this.rotation.copy(object.rotation);
    this.quaternion.copy(object.quaternion);
    this.up.copy(object.up);
    this.localMatrix.copy(object.localMatrix);
    this.worldMatrix.copy(object.worldMatrix);
    this.matrixAutoUpdate = object.matrixAutoUpdate;
    if (recursive) {
      for (let i = 0, n = object.children.length; i < n; i++) {
        const children = object.children[i];
        this.add(children.clone());
      }
    }
    return this;
  }
}

class Base {
  renderer;
  constructor(renderer) {
    this.renderer = renderer;
  }
  get gl() {
    return this.renderer.gl;
  }
  get rendererState() {
    return this.renderer.state;
  }
}

const getBufferType = (gl, data) => {
  if (data instanceof Float32Array || data instanceof Float64Array) {
    return gl.FLOAT;
  }
  if (data instanceof Uint16Array) {
    return gl.UNSIGNED_SHORT;
  }
  if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return gl.UNSIGNED_BYTE;
  }
  if (data instanceof Uint32Array) {
    return gl.UNSIGNED_INT;
  }
  if (data instanceof Int8Array) {
    return gl.BYTE;
  }
  if (data instanceof Int16Array) {
    return gl.SHORT;
  }
  if (data instanceof Int32Array) {
    return gl.INT;
  }
};
class BufferAttribute {
  id;
  data;
  type;
  size;
  instanced;
  stride;
  offset;
  divisor;
  normalized;
  needsUpdate;
  count;
  usage;
  target;
  buffer;
  constructor(renderer, attribute) {
    const attr = Object.assign(
      {},
      {
        size: 1,
        normalized: true,
        stride: 0,
        offset: 0,
        divisor: 0,
        usage: renderer.gl.STATIC_DRAW
      },
      attribute
    );
    this.id = uid("attribute");
    this.needsUpdate = false;
    if (!attribute.data || Array.isArray(attribute.data)) {
      throw new TypeError("BufferAttribute: data should be a typed array");
    }
    this.data = attr.data;
    this.size = attr.size || 1;
    this.type = attr.type || getBufferType(renderer.gl, attr.data);
    this.normalized = attr.normalized || false;
    this.stride = attr.stride || 0;
    this.offset = attr.offset || 0;
    this.divisor = attr.divisor || 0;
    this.instanced = attr.divisor > 0;
    this.usage = attr.usage || renderer.gl.STATIC_DRAW;
    if (attr.target) {
      this.target = attr.target;
    }
    let count = attr.count;
    if (attr.count === void 0 || attr.count === null) {
      count = attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size;
    }
    this.count = count;
  }
}

const tempVec3 = new Vector3();
class Geometry extends Base {
  #id;
  #attributes;
  #VAOs;
  #bounds;
  drawRange;
  instancedCount;
  isInstanced;
  drawMode;
  constructor(renderer, attributes = {}) {
    super(renderer);
    this.drawRange = {
      start: 0,
      count: 0
    };
    this.instancedCount = 0;
    this.isInstanced = false;
    this.#attributes = /* @__PURE__ */ new Map();
    this.#VAOs = /* @__PURE__ */ new Map();
    this.#id = uid("geometry");
    this.drawMode = this.gl.TRIANGLES;
    renderer.bindVertexArray(null);
    renderer.state.setActiveGeometry(null);
    for (const name in attributes) {
      const attribute = attributes[name];
      if (attribute instanceof BufferAttribute) {
        if (name === "index") {
          this.setIndex(attribute);
        } else {
          this.addAttribute(name, attribute);
        }
      } else {
        if (attribute.data) {
          const n = new BufferAttribute(this.renderer, attribute);
          if (name === "index") {
            this.setIndex(n);
          } else {
            this.addAttribute(name, n);
          }
        }
      }
    }
  }
  get id() {
    return this.#id;
  }
  get attributes() {
    return this.#attributes;
  }
  get attributesData() {
    const attributes = {};
    const iterator = this.#attributes.entries();
    for (let i = 0; i < this.#attributes.size; i++) {
      const entry = iterator.next().value;
      attributes[entry[0]] = omit(entry[1], [
        "id",
        "buffer"
      ]);
    }
    return attributes;
  }
  get index() {
    return this.attributes.get("index");
  }
  get bounds() {
    return this.#bounds;
  }
  set bounds(bounds) {
    this.#bounds = bounds;
  }
  addAttribute(name, attribute) {
    if (!attribute.target) {
      attribute.target = name === "index" ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;
    }
    attribute.needsUpdate = false;
    this.attributes.set(name, attribute);
    if (!attribute.buffer) {
      attribute.buffer = this.gl.createBuffer();
      this.updateAttribute(attribute);
    }
    if (attribute.divisor) {
      this.isInstanced = true;
      if (this.instancedCount && this.instancedCount !== attribute.count * attribute.divisor) {
        this.instancedCount = Math.min(this.instancedCount, attribute.count * attribute.divisor);
        return console.warn(
          `Geometry has multiple instanced buffers of different length - instancedCount: ${this.instancedCount}, count: ${attribute.count}, divisor: ${attribute.divisor}, attribute: ${name}`
        );
      }
      this.instancedCount = attribute.count * attribute.divisor;
    } else if (name === "index") {
      this.drawRange.count = attribute.count;
    } else if (!this.index) {
      this.drawRange.count = Math.max(this.drawRange.count, attribute.count);
    }
  }
  getAttribute(name) {
    return this.attributes.get(name);
  }
  setAttributeData(name, data) {
    const attribute = this.getAttribute(name);
    if (attribute) {
      attribute.data = data;
      attribute.needsUpdate = true;
    }
  }
  updateAttribute(attribute) {
    const createBuffer = !attribute.buffer;
    if (createBuffer) {
      attribute.buffer = this.gl.createBuffer();
    }
    if (this.rendererState.boundBuffer !== attribute.buffer) {
      this.gl.bindBuffer(attribute.target, attribute.buffer);
      this.rendererState.boundBuffer = attribute.buffer;
    }
    this.gl.bufferData(attribute.target, attribute.data, attribute.usage);
    attribute.needsUpdate = false;
  }
  removeAttribute(attribute) {
    this.attributes.delete(attribute);
  }
  setIndex(index) {
    if (index instanceof BufferAttribute) {
      index.size = 1;
      this.addAttribute("index", index);
    } else {
      const buffer = new BufferAttribute(this.renderer, {
        data: index.length > 65535 ? new Uint32Array(index) : new Uint16Array(index),
        size: 1
      });
      this.addAttribute("index", buffer);
    }
    this.drawRange.count = this.index?.count;
  }
  setVertices(data) {
    const array = [];
    const len = data.length;
    for (let i = 0; i < len; i++) {
      const item = data[i];
      array.push(item[0], item[1], item[2]);
    }
    this.addAttribute(
      "position",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(array),
        size: 3
      })
    );
  }
  setNormals(data) {
    this.addAttribute(
      "normal",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(data),
        size: 2
      })
    );
  }
  setUVs(data) {
    this.addAttribute(
      "uv",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(data),
        size: 2
      })
    );
  }
  setColors(colors) {
    const data = [];
    for (let i = 0; i < colors.length; i++) {
      let color = colors[i];
      if (color && (color instanceof Vector3 || color instanceof Vector4)) {
        color = color.toArray();
      }
      data.push(color[0], color[1], color[2], color[3] || 1);
    }
    this.addAttribute(
      "color",
      new BufferAttribute(this.renderer, {
        data: new Float32Array(data),
        size: 4
      })
    );
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  setInstancedCount(count) {
    this.instancedCount = count;
  }
  createVAO(program) {
    const { attributeOrder } = program;
    const vao = this.renderer.createVertexArray();
    this.renderer.bindVertexArray(vao);
    this.#VAOs.set(attributeOrder, vao);
    this.bindAttributes(program);
  }
  bindAttributes(program) {
    program.attributeLocations.forEach((location, { name, type }) => {
      const attributes = this.attributes.get(name);
      if (!attributes)
        return;
      this.gl.bindBuffer(attributes.target, attributes.buffer);
      this.rendererState.boundBuffer = attributes.buffer;
      let numLoc = 1;
      if (type === this.gl.FLOAT_MAT2)
        numLoc = 2;
      if (type === this.gl.FLOAT_MAT3)
        numLoc = 3;
      if (type === this.gl.FLOAT_MAT4)
        numLoc = 4;
      const size = attributes.size / numLoc;
      const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;
      const offset = numLoc === 1 ? 0 : numLoc * numLoc;
      for (let i = 0; i < numLoc; i++) {
        const attribIndex = location + i;
        this.gl.vertexAttribPointer(
          attribIndex,
          size,
          attributes.type,
          attributes.normalized,
          attributes.stride + stride,
          attributes.offset + offset
        );
        this.gl.enableVertexAttribArray(attribIndex);
        this.renderer.vertexAttribDivisor(attribIndex, attributes.divisor);
      }
    });
    const index = this.attributes.get("index");
    if (index) {
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, index.buffer);
    }
  }
  computeBoundingBox(vertices) {
    const { data, offset = 0, stride, size } = this.attributes.get("position");
    if (!this.#bounds) {
      this.#bounds = {
        min: new Vector3(),
        max: new Vector3(),
        center: new Vector3(),
        scale: new Vector3(),
        radius: Number.POSITIVE_INFINITY
      };
    }
    this.#bounds.min.setScalar(+Number.POSITIVE_INFINITY);
    this.#bounds.max.setScalar(Number.NEGATIVE_INFINITY);
    const array = vertices || data;
    const dl = stride || size;
    for (let i = offset; i < array.length; i += dl) {
      const x = array[i + 0];
      const y = array[i + 1];
      const z = array[i + 2];
      this.#bounds.min.x = Math.min(x, this.#bounds.min.x);
      this.#bounds.min.y = Math.min(y, this.#bounds.min.y);
      this.#bounds.min.z = Math.min(z, this.#bounds.min.z);
      this.#bounds.max.x = Math.max(x, this.#bounds.max.x);
      this.#bounds.max.y = Math.max(y, this.#bounds.max.y);
      this.#bounds.max.z = Math.max(z, this.#bounds.max.z);
    }
    this.#bounds.scale.subVectors(this.#bounds.max, this.#bounds.min);
    this.#bounds.center.add(this.#bounds.min).add(this.#bounds.max).divideScalar(2);
    return this.#bounds;
  }
  computeBoundingSphere(vertices) {
    const { data, offset = 0, stride, size } = this.attributes.get("position");
    if (!this.#bounds) {
      this.computeBoundingBox(vertices);
    }
    const array = vertices || data;
    let len = 0;
    const dl = stride || size;
    const length = array.length;
    for (let j = offset; j < length; j += dl) {
      tempVec3.fromArray(array, j);
      len = Math.max(len, this.#bounds.center.distanceToSquared(tempVec3));
    }
    this.#bounds.radius = Math.sqrt(len);
  }
  draw(program, drawMode = this.drawMode) {
    const { start, count } = this.drawRange;
    const activeGeometryId = `${this.id}_${program.attributeOrder}`;
    if (this.rendererState.activeGeometryId !== activeGeometryId) {
      const vao = this.#VAOs.get(program.attributeOrder);
      if (!vao) {
        this.createVAO(program);
      }
      this.renderer.bindVertexArray(this.#VAOs.get(program.attributeOrder));
      this.rendererState.activeGeometryId = activeGeometryId;
    }
    program.attributeLocations.forEach((location, { name }) => {
      const attribute = this.getAttribute(name);
      if (attribute && attribute.needsUpdate) {
        this.updateAttribute(attribute);
      }
    });
    if (this.isInstanced) {
      if (this.index) {
        const offset = this.index.offset + 2 * start;
        this.renderer.drawElementsInstanced(
          drawMode,
          count,
          this.index.type,
          offset,
          this.instancedCount
        );
      } else {
        this.renderer.drawArraysInstanced(drawMode, start, count, this.instancedCount);
      }
    } else if (this.index) {
      const offset = this.index.offset + 2 * start;
      this.gl.drawElements(drawMode, count, this.index.type, offset);
    } else {
      this.gl.drawArrays(drawMode, start, count);
    }
  }
  copy(source) {
    const attributes = source.attributesData;
    for (const name in attributes) {
      const attribute = attributes[name];
      if (attribute instanceof BufferAttribute) {
        if (name === "index") {
          this.setIndex(attribute);
        } else {
          this.addAttribute(name, attribute);
        }
      } else {
        if (attribute.data) {
          const n = new BufferAttribute(this.renderer, attribute);
          if (name === "index") {
            this.setIndex(n);
          } else {
            this.addAttribute(name, n);
          }
        }
      }
    }
    if (source.bounds) {
      this.bounds = {
        min: new Vector3().copy(source.bounds.min),
        max: new Vector3().copy(source.bounds.max),
        center: new Vector3().copy(source.bounds.center),
        scale: new Vector3().copy(source.bounds.scale),
        radius: source.bounds.radius
      };
    }
    return this;
  }
  clone() {
    const geometry = new Geometry(this.renderer, {}).copy(this);
    geometry.drawMode = this.drawMode;
    return geometry;
  }
  destroy() {
    this.#VAOs.forEach((t) => {
      this.renderer.deleteVertexArray(t);
    });
    this.#VAOs.clear();
    this.#attributes.forEach((t) => {
      this.gl.deleteBuffer(t.buffer);
    });
    this.#attributes.clear();
  }
}

class Mesh extends Object3D {
  gl;
  modelViewMatrix;
  normalMatrix;
  renderOrder;
  zDepth;
  frustumCulled;
  mode;
  renderer;
  #id;
  #lastMode;
  #geometry;
  #program;
  #wireframe;
  #wireframeGeometry;
  constructor(renderer, options = {}) {
    super();
    const opts = Object.assign({}, {
      mode: renderer.gl.TRIANGLES,
      frustumCulled: true,
      renderOrder: 0
    }, options);
    this.renderer = renderer;
    this.gl = this.renderer.gl;
    this.modelViewMatrix = new Matrix4();
    this.normalMatrix = new Matrix3();
    this.renderOrder = opts.renderOrder;
    this.frustumCulled = opts.frustumCulled;
    this.zDepth = 0;
    this.#id = opts.id || uid("mesh");
    this.#geometry = opts.geometry;
    this.#program = opts.program;
    this.#wireframe = Boolean(opts.wireframe);
    this.mode = opts.mode;
    this.#lastMode = opts.mode;
    if (this.#wireframe) {
      this.mode = this.gl.LINES;
      this.updateWireframeGeometry(this.#wireframe);
    }
  }
  get id() {
    return this.#id;
  }
  get geometry() {
    return this.#wireframe ? this.#wireframeGeometry : this.#geometry;
  }
  get program() {
    return this.#program;
  }
  set wireframe(wireframe) {
    this.mode = wireframe ? this.gl.LINES : this.#lastMode;
    this.#wireframe = wireframe;
    this.updateWireframeGeometry(this.#wireframe);
  }
  get wireframe() {
    return this.#wireframe;
  }
  draw(options = {}) {
    const { camera, target } = options;
    const uniforms = {};
    if (camera) {
      Object.assign(uniforms, {
        projectionMatrix: camera.projectionMatrix,
        cameraPosition: camera.worldPosition,
        viewMatrix: camera.viewMatrix
      });
      this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);
      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);
    } else {
      this.modelViewMatrix.copy(this.worldMatrix);
    }
    Object.assign(uniforms, {
      resolution: new Vector2(
        this.renderer.state?.viewport?.width || 1,
        this.renderer.state?.viewport?.height || 1
      ),
      modelMatrix: this.worldMatrix,
      modelViewMatrix: this.modelViewMatrix,
      normalMatrix: this.normalMatrix
    });
    Object.keys(uniforms).forEach((key) => {
      if (!Object.hasOwn(this.program.uniforms, key)) {
        this.program.uniforms[key] = { value: null };
      }
      this.program.uniforms[key].value = uniforms[key];
    });
    if (target)
      target.bind();
    this.program.use();
    this.geometry.draw(this.program, this.mode);
    if (target)
      target.unbind();
  }
  updateWireframeGeometry(wireframe, force = false) {
    if (this.#geometry && (force || !this.#wireframeGeometry)) {
      if (this.#wireframeGeometry) {
        this.#wireframeGeometry.destroy();
      }
      const attributes = this.#geometry.attributes;
      const positionArray = attributes.get("position")?.data;
      const indexAttribute = this.#geometry.index?.data;
      const numIndices = indexAttribute ? indexAttribute.length : Math.floor(positionArray.length / 3);
      const index = [];
      if (this.#geometry.index) {
        if (indexAttribute) {
          getWireframeIndex(positionArray, index, numIndices, indexAttribute);
        }
      } else {
        getWireframeIndex(positionArray, index, numIndices);
      }
      const indices = index.length > 65536 ? new Uint32Array(index) : new Uint16Array(index);
      this.#wireframeGeometry = new Geometry(this.renderer, {
        ...this.#geometry.attributesData,
        index: {
          data: indices
        }
      });
    }
  }
  updateGeometry(geometry, destroy = true) {
    if (destroy && this.#geometry) {
      this.#geometry.destroy();
    }
    this.#geometry = geometry;
    this.updateWireframeGeometry(this.#wireframe, true);
  }
  updateProgram(program, destroy = true) {
    if (destroy && this.#program) {
      this.#program.destroy();
    }
    this.#program = program;
  }
  destroy() {
    this.program.destroy();
    this.geometry.destroy();
  }
  clone() {
    return new Mesh(this.gl, {
      geometry: this.geometry,
      program: this.program,
      frustumCulled: this.frustumCulled,
      mode: this.mode,
      renderOrder: this.renderOrder
    }).copy(this);
  }
  copy(mesh, recursive = true) {
    super.copy(mesh, recursive);
    this.modelViewMatrix.copy(mesh.modelViewMatrix);
    this.normalMatrix.copy(mesh.normalMatrix);
    this.mode = mesh.mode;
    this.renderOrder = mesh.renderOrder;
    this.zDepth = mesh.zDepth;
    return this;
  }
}

class Scene extends Object3D {
  clone() {
    return new Scene().copy(this, false);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
}

var BlendType = /* @__PURE__ */ ((BlendType2) => {
  BlendType2[BlendType2["NoBlending"] = 0] = "NoBlending";
  BlendType2[BlendType2["NormalBlending"] = 1] = "NormalBlending";
  BlendType2[BlendType2["AdditiveBlending"] = 2] = "AdditiveBlending";
  BlendType2[BlendType2["SubtractiveBlending"] = 3] = "SubtractiveBlending";
  BlendType2[BlendType2["MultiplyBlending"] = 4] = "MultiplyBlending";
  BlendType2[BlendType2["CustomBlending"] = 5] = "CustomBlending";
  return BlendType2;
})(BlendType || {});
class State extends Base {
  #state;
  constructor(renderer, options) {
    super(renderer);
    const { gl } = renderer;
    this.#state = {
      viewport: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
    this.apply(
      options || {
        frontFace: gl.CCW,
        depthTest: false,
        depthWrite: true,
        depthMask: true,
        depthFunc: gl.LESS,
        blending: 1 /* NormalBlending */,
        blendFunc: {
          src: gl.ONE,
          dst: gl.ZERO
        },
        blendEquation: {
          modeRGB: gl.FUNC_ADD
        },
        premultiplyAlpha: false,
        unpackAlignment: 4,
        flipY: false,
        framebuffer: null,
        textureUnits: [],
        activeTextureUnit: -1,
        activeGeometryId: -1,
        currentProgramId: -1,
        clearAlpha: 1,
        clearColor: new Color(0),
        stencil: {
          func: {},
          opFront: {},
          opBack: {}
        }
      }
    );
  }
  get state() {
    return this.#state;
  }
  get viewport() {
    return this.#state.viewport;
  }
  get textureUnits() {
    return this.#state.textureUnits;
  }
  get activeTextureUnit() {
    return this.#state.activeTextureUnit;
  }
  set activeTextureUnit(activeTextureUnit) {
    this.#state.activeTextureUnit = activeTextureUnit;
  }
  get currentProgramId() {
    return this.#state.currentProgramId;
  }
  set currentProgramId(id) {
    this.#state.currentProgramId = id;
  }
  get activeGeometryId() {
    return this.#state.activeGeometryId;
  }
  set activeGeometryId(id) {
    this.#state.activeGeometryId = id;
  }
  set flipY(flipY) {
    this.#state.flipY = flipY;
  }
  get flipY() {
    return this.#state.flipY;
  }
  set unpackAlignment(unpackAlignment) {
    this.#state.unpackAlignment = unpackAlignment;
  }
  get unpackAlignment() {
    return this.#state.unpackAlignment;
  }
  set premultiplyAlpha(premultiplyAlpha) {
    this.#state.premultiplyAlpha = premultiplyAlpha;
  }
  get premultiplyAlpha() {
    return this.#state.premultiplyAlpha;
  }
  set boundBuffer(boundBuffer) {
    this.#state.boundBuffer = boundBuffer;
  }
  get boundBuffer() {
    return this.#state.boundBuffer;
  }
  set anisotropy(anisotropy) {
    this.#state.anisotropy = anisotropy;
  }
  get anisotropy() {
    return this.#state.anisotropy;
  }
  apply(options) {
    if (options.blending !== void 0 && options.blending !== null) {
      this.setBlending(options.blending, options);
    } else {
      if (options.blendFunc) {
        const { src, dst, srcAlpha, dstAlpha } = options.blendFunc;
        this.setBlendFunc(src, dst, srcAlpha, dstAlpha);
        this.enable(this.gl.BLEND);
      } else {
        this.disable(this.gl.BLEND);
      }
      if (options.blendEquation) {
        const { modeRGB, modeAlpha } = options.blendEquation;
        this.setBlendEquation(modeRGB, modeAlpha);
      }
    }
    if (!isUndef(options.cullFace) && !isNull(options.cullFace)) {
      this.setCullFace(options.cullFace);
    }
    if (!isUndef(options.frontFace) && !isNull(options.frontFace)) {
      this.setFrontFace(options.frontFace);
    }
    if (options.depthTest) {
      this.enable(this.gl.DEPTH_TEST);
    } else {
      this.disable(this.gl.DEPTH_TEST);
    }
    if (!isUndef(options.depthMask) && !isNull(options.depthMask)) {
      this.setDepthMask(options.depthMask);
    }
    if (!isUndef(options.depthWrite) && !isNull(options.depthWrite)) {
      this.setDepthMask(options.depthWrite);
    }
    if (!isUndef(options.depthFunc) && !isNull(options.depthFunc)) {
      this.setDepthFunc(options.depthFunc);
    }
    if (!isUndef(options.lineWidth) && !isNull(options.lineWidth)) {
      this.setLineWidth(options.lineWidth);
    }
    this.#state = Object.assign(this.#state, options);
  }
  enable(id) {
    if (this.#state[id] !== true) {
      this.gl.enable(id);
      this.#state[id] = true;
    }
  }
  disable(id) {
    if (this.#state[id] !== false) {
      this.gl.disable(id);
      this.#state[id] = false;
    }
  }
  setViewport(width, height, x = 0, y = 0) {
    if (this.#state.viewport.width === width && this.#state.viewport.height === height)
      return;
    this.gl.viewport(x, y, width, height);
    this.#state.viewport = {
      width,
      height,
      x,
      y
    };
  }
  setMask(colorMask) {
    if (this.#state.colorMask !== colorMask) {
      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
      this.#state.colorMask = colorMask;
    }
  }
  setBlending(blending, options) {
    this.#state.blending = blending;
    if (blending === 0 /* NoBlending */) {
      this.disable(this.gl.BLEND);
      return;
    } else {
      this.enable(this.gl.BLEND);
    }
    if (blending === 2 /* AdditiveBlending */) {
      if (this.#state.premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ONE, this.gl.ONE, this.gl.ONE, this.gl.ONE);
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
      }
    } else if (blending === 3 /* SubtractiveBlending */) {
      if (this.#state.premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(
          this.gl.ZERO,
          this.gl.ZERO,
          this.gl.ONE_MINUS_SRC_COLOR,
          this.gl.ONE_MINUS_SRC_ALPHA
        );
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ZERO, this.gl.ONE_MINUS_SRC_COLOR);
      }
    } else if (blending === 4 /* MultiplyBlending */) {
      if (this.#state.premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ZERO, this.gl.SRC_COLOR, this.gl.ZERO, this.gl.SRC_ALPHA);
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD);
        this.setBlendFunc(this.gl.ZERO, this.gl.SRC_COLOR);
      }
    } else if (blending === 1 /* NormalBlending */) {
      if (this.#state.premultiplyAlpha) {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(
          this.gl.ONE,
          this.gl.ONE_MINUS_SRC_ALPHA,
          this.gl.ONE,
          this.gl.ONE_MINUS_SRC_ALPHA
        );
      } else {
        this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
        this.setBlendFunc(
          this.gl.SRC_ALPHA,
          this.gl.ONE_MINUS_SRC_ALPHA,
          this.gl.ONE,
          this.gl.ONE_MINUS_SRC_ALPHA
        );
      }
    } else if (blending === 5 /* CustomBlending */) {
      if (options?.blendFunc) {
        const { src, dst, srcAlpha, dstAlpha } = options.blendFunc;
        this.setBlendFunc(src, dst, srcAlpha, dstAlpha);
        this.enable(this.gl.BLEND);
      }
      if (options?.blendEquation) {
        const { modeRGB, modeAlpha } = options.blendEquation;
        this.setBlendEquation(modeRGB, modeAlpha);
      }
    } else {
      console.error("State: Invalid blending: ", blending);
    }
  }
  setBlendFunc(src, dst, srcAlpha, dstAlpha) {
    if (src !== this.#state.blendFunc?.src || dst !== this.#state.blendFunc?.dst || srcAlpha !== this.#state.blendFunc?.srcAlpha || dstAlpha !== this.#state.blendFunc?.dstAlpha) {
      this.#state.blendFunc = {
        src,
        dst,
        srcAlpha,
        dstAlpha
      };
      if (!isUndef(srcAlpha) && !isNull(srcAlpha) && !isUndef(dstAlpha) && !isNull(dstAlpha)) {
        this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);
      } else {
        this.gl.blendFunc(src, dst);
      }
    }
  }
  setBlendEquation(modeRGB, modeAlpha) {
    if (modeRGB !== this.#state.blendEquation?.modeRGB || modeAlpha !== this.#state.blendEquation?.modeAlpha) {
      this.#state.blendEquation = {
        modeRGB,
        modeAlpha
      };
      if (!isUndef(modeAlpha) && !isNull(modeAlpha)) {
        this.gl.blendEquationSeparate(modeRGB, modeAlpha);
      } else {
        this.gl.blendEquation(modeRGB);
      }
    }
  }
  setClearAlpha(alpha) {
    if (this.#state.clearAlpha !== alpha) {
      this.#state.clearAlpha = alpha;
    }
  }
  setClearColor(color, alpha) {
    if (this.#state.clearAlpha !== alpha || this.#state.clearColor !== color) {
      this.#state.clearColor = color;
      if (!isUndef(alpha) && !isNull(alpha)) {
        this.#state.clearAlpha = alpha;
      } else {
        this.#state.clearAlpha = color.a;
      }
      this.gl.clearColor(color.r, color.g, color.b, this.#state.clearAlpha);
    }
  }
  setCullFace(cullFace) {
    if (this.#state.cullFace !== cullFace) {
      if (cullFace) {
        this.gl.enable(this.gl.CULL_FACE);
      } else {
        this.gl.disable(this.gl.CULL_FACE);
      }
      this.#state.cullFace = cullFace;
      this.gl.cullFace(cullFace);
    }
  }
  setFrontFace(frontFace) {
    if (this.#state.frontFace !== frontFace) {
      this.#state.frontFace = frontFace;
      this.gl.frontFace(frontFace);
    }
  }
  setDepthMask(mask) {
    if (this.#state.depthMask !== mask) {
      this.#state.depthMask = mask;
      this.gl.depthMask(mask);
    }
  }
  setDepthFunc(func) {
    if (this.#state.depthFunc !== func) {
      this.#state.depthFunc = func;
      this.gl.depthFunc(func);
    }
  }
  setDepthTest(state) {
    if (this.#state.depthTest !== state) {
      this.#state.depthTest = state;
      if (state) {
        this.enable(this.gl.DEPTH_TEST);
      } else {
        this.disable(this.gl.DEPTH_TEST);
      }
    }
  }
  setStencilFunc(cmp, ref, mask, face) {
    if (this.#state?.stencil?.func?.cmp !== cmp || this.#state?.stencil?.func?.ref !== ref || this.#state?.stencil?.func?.mask !== mask) {
      if (!this.#state?.stencil) {
        this.#state.stencil = {};
      }
      if (!this.#state?.stencil?.func) {
        this.#state.stencil.func = {};
      }
      this.#state.stencil.func = {
        ref,
        mask,
        cmp
      };
      if (face) {
        this.gl.stencilFuncSeparate(face, cmp, ref, mask);
      } else {
        this.gl.stencilFunc(cmp, ref, mask);
      }
    }
  }
  setStencilOp(fail, zFail, zPass, face) {
    if (!this.#state?.stencil) {
      this.#state.stencil = {};
    }
    if (!face || face === this.gl.FRONT_AND_BACK) {
      return this.#state.stencil?.opFront?.fail !== fail || this.#state.stencil?.opFront?.zFail !== zFail || this.#state.stencil?.opFront?.zPass !== zPass || this.#state.stencil?.opBack?.fail !== fail || this.#state.stencil?.opBack?.zFail !== zFail || this.#state.stencil?.opBack?.zPass !== zPass;
    } else if (face === this.gl.FRONT) {
      return this.#state.stencil?.opFront?.fail !== fail || this.#state.stencil?.opFront?.zFail !== zFail || this.#state.stencil?.opFront?.zPass !== zPass;
    } else if (face === this.gl.BACK) {
      return this.#state.stencil?.opBack?.fail !== fail || this.#state.stencil?.opBack?.zFail !== zFail || this.#state.stencil?.opBack?.zPass !== zPass;
    }
  }
  setStencilMask(mask, face) {
    if (this.#state.stencil?.mask !== mask) {
      this.#state.stencil = {
        ...this.#state.stencil,
        mask
      };
      if (face) {
        this.gl.stencilMaskSeparate(face, mask);
      } else {
        this.gl.stencilMask(mask);
      }
    }
  }
  setActiveTexture(unit) {
    if (this.#state.activeTextureUnit !== unit) {
      this.#state.activeTextureUnit = unit;
      this.gl.activeTexture(this.gl.TEXTURE0 + unit);
    }
  }
  setLineWidth(width) {
    if (this.#state.lineWidth !== width) {
      this.#state.lineWidth = width;
      this.gl.lineWidth(width);
    }
  }
  setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      this.enable(this.gl.POLYGON_OFFSET_FILL);
      if (this.#state.polygonOffsetFactor !== factor || this.#state.polygonOffsetUnits !== units) {
        this.gl.polygonOffset(factor, units);
        this.#state.polygonOffsetFactor = factor;
        this.#state.polygonOffsetUnits = units;
      }
    } else {
      this.disable(this.gl.POLYGON_OFFSET_FILL);
    }
  }
  bindFramebuffer(v = {}) {
    const { target = this.gl.FRAMEBUFFER, buffer = null } = v;
    if (this.#state.framebuffer !== buffer) {
      this.#state.framebuffer = buffer;
      this.gl.bindFramebuffer(target, buffer);
    }
  }
  setActiveGeometry(id) {
    this.#state.activeGeometryId = id;
  }
  reset(force = true) {
    const keys = Object.keys(this.#state);
    if (force) {
      keys.filter((key) => ["viewport", "premultiplyAlpha"].indexOf(key) < 0).forEach((key) => {
        delete this.#state[key];
      });
      this.bindFramebuffer({
        buffer: null
      });
      this.apply({
        frontFace: this.gl.CCW,
        depthTest: false,
        depthWrite: true,
        depthMask: true,
        depthFunc: this.gl.LESS,
        blending: 1 /* NormalBlending */,
        blendFunc: {
          src: this.gl.ONE,
          dst: this.gl.ZERO
        },
        blendEquation: {
          modeRGB: this.gl.FUNC_ADD
        },
        premultiplyAlpha: false,
        unpackAlignment: 4,
        flipY: false,
        framebuffer: null,
        textureUnits: [],
        activeTextureUnit: -1,
        activeGeometryId: -1,
        currentProgramId: -1,
        clearAlpha: 1,
        clearColor: new Color(0),
        stencil: {
          func: {},
          opFront: {},
          opBack: {}
        }
      });
    } else {
      keys.filter(
        (key) => [
          "flipY",
          "framebuffer",
          "textureUnits",
          "activeTextureUnit",
          "activeGeometryId",
          "currentProgramId"
        ].indexOf(key) > -1
      ).forEach((key) => {
        delete this.#state[key];
      });
      this.bindFramebuffer({
        buffer: null
      });
      this.#state.flipY = false;
      this.#state.activeGeometryId = -1;
      this.#state.activeTextureUnit = -1;
      this.#state.currentProgramId = -1;
      this.#state.textureUnits = [];
      this.#state.boundBuffer = null;
    }
  }
}

const external1ExtensionKeys = [
  "WEBGL_depth_texture",
  "OES_texture_half_float",
  "OES_texture_float",
  "OES_standard_derivatives",
  "OES_element_index_uint",
  "EXT_frag_depth",
  "EXT_blend_minmax",
  "EXT_shader_texture_lod",
  "WEBGL_draw_buffers",
  "WEBGL_color_buffer_float"
];
const external2ExtensionKeys = [
  "EXT_color_buffer_float"
];
const external12ExtensionKeys = [
  "WEBGL_lose_context",
  "OES_texture_half_float_linear",
  "OES_texture_float_linear",
  "EXT_color_buffer_half_float",
  "WEBGL_debug_renderer_info",
  "EXT_texture_filter_anisotropic"
];
class Renderer {
  #gl;
  #state;
  #extensions;
  #autoClear;
  #depth;
  #alpha;
  #stencil;
  #antialias;
  #premultipliedAlpha;
  #preserveDrawingBuffer;
  #color;
  #dpr;
  #frustumCull;
  vertexAttribDivisor;
  drawArraysInstanced;
  drawElementsInstanced;
  createVertexArray;
  bindVertexArray;
  deleteVertexArray;
  width;
  height;
  constructor(gl, opts = {}) {
    const options = Object.assign(
      {},
      {
        autoClear: true,
        depth: true,
        alpha: false,
        stencil: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        requestWebGl2: true,
        extensions: []
      },
      opts
    );
    this.#autoClear = Boolean(options.autoClear);
    this.#depth = options.depth;
    this.#alpha = options.alpha;
    this.#stencil = options.stencil;
    this.#antialias = options.antialias;
    this.#premultipliedAlpha = options.premultipliedAlpha;
    this.#preserveDrawingBuffer = options.preserveDrawingBuffer;
    this.#gl = isWebGL(gl) || isWebGL2(gl) ? gl : getContext(
      gl,
      {
        alpha: this.#alpha,
        depth: this.#depth,
        stencil: this.#stencil,
        antialias: this.#antialias,
        powerPreference: options.powerPreference,
        premultipliedAlpha: this.#premultipliedAlpha,
        preserveDrawingBuffer: this.#preserveDrawingBuffer
      },
      options.requestWebGl2
    );
    const attrs = this.#gl?.getContextAttributes();
    const viewport = this.#gl?.getParameter(this.#gl.VIEWPORT);
    const flipY = this.#gl?.getParameter(this.#gl.UNPACK_FLIP_Y_WEBGL);
    this.#state = new State(this);
    if (attrs) {
      this.#depth = Boolean(attrs.depth);
      this.#antialias = Boolean(attrs.antialias);
      this.#alpha = Boolean(attrs.alpha);
      this.#stencil = Boolean(attrs.stencil);
      this.#premultipliedAlpha = Boolean(attrs.premultipliedAlpha);
      this.#preserveDrawingBuffer = Boolean(attrs.preserveDrawingBuffer);
    }
    this.#state.flipY = Boolean(flipY);
    this.#state.setViewport(viewport[2], viewport[3], viewport[0], viewport[1]);
    this.#state.premultiplyAlpha = this.#premultipliedAlpha;
    this.#color = true;
    this.#dpr = options.dpr || 1;
    this.width = this.gl.canvas.width / this.#dpr;
    this.height = this.gl.canvas.height / this.#dpr;
    this.#frustumCull = !!options.frustumCull;
    this.#extensions = {};
    this.vertexAttribDivisor = this.getExtension(
      "ANGLE_instanced_arrays",
      "vertexAttribDivisor",
      "vertexAttribDivisorANGLE"
    );
    this.drawArraysInstanced = this.getExtension(
      "ANGLE_instanced_arrays",
      "drawArraysInstanced",
      "drawArraysInstancedANGLE"
    );
    this.drawElementsInstanced = this.getExtension(
      "ANGLE_instanced_arrays",
      "drawElementsInstanced",
      "drawElementsInstancedANGLE"
    );
    this.createVertexArray = this.getExtension(
      "OES_vertex_array_object",
      "createVertexArray",
      "createVertexArrayOES"
    );
    this.bindVertexArray = this.getExtension(
      "OES_vertex_array_object",
      "bindVertexArray",
      "bindVertexArrayOES"
    );
    this.deleteVertexArray = this.getExtension(
      "OES_vertex_array_object",
      "deleteVertexArray",
      "deleteVertexArrayOES"
    );
    if (options.extensions) {
      options.extensions.filter(
        (extension) => external1ExtensionKeys.findIndex((ext) => ext === extension) > -1
      ).forEach((extension) => {
        if (!this.#extensions[extension] && !this.isWebGL2) {
          this.#extensions[extension] = this.gl.getExtension(extension);
        }
      });
      options.extensions.filter(
        (extension) => external2ExtensionKeys.findIndex((ext) => ext === extension) > -1
      ).forEach((extension) => {
        if (!this.#extensions[extension] && this.isWebGL2) {
          this.#extensions[extension] = this.gl.getExtension(extension);
        }
      });
      options.extensions.filter(
        (extension) => external12ExtensionKeys.findIndex((ext) => ext === extension) > -1
      ).forEach((extension) => {
        if (!this.#extensions[extension]) {
          this.#extensions[extension] = this.gl.getExtension(extension);
        }
      });
    }
  }
  get gl() {
    return this.#gl;
  }
  get attributes() {
    return {
      dpr: this.#dpr,
      flipY: this.#state.flipY,
      depth: this.#depth,
      color: this.#color,
      antialias: this.#antialias,
      alpha: this.#alpha,
      stencil: this.#stencil,
      autoClear: this.#autoClear,
      frustumCull: this.#frustumCull,
      premultipliedAlpha: this.#premultipliedAlpha,
      preserveDrawingBuffer: this.#preserveDrawingBuffer
    };
  }
  get canvas() {
    return this.#gl.canvas;
  }
  get isWebGL() {
    return isWebGL(this.gl);
  }
  get isWebGL2() {
    return isWebGL2(this.gl);
  }
  get extensions() {
    return this.#extensions;
  }
  extension(key) {
    return this.#extensions[key];
  }
  get size() {
    return {
      width: "clientWidth" in this.canvas ? this.canvas.clientWidth : this.canvas.width,
      height: "clientHeight" in this.canvas ? this.canvas.clientHeight : this.canvas.height
    };
  }
  get state() {
    return this.#state;
  }
  get premultipliedAlpha() {
    return this.#premultipliedAlpha;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.gl.canvas.width = width * this.#dpr;
    this.gl.canvas.height = height * this.#dpr;
  }
  setViewport(width, height, x = 0, y = 0) {
    this.#state.setViewport(width, height, x, y);
  }
  getExtension(extension, method, extFunc) {
    const func = this.gl[method];
    if (method && func)
      return func.bind(this.gl);
    if (!this.#extensions[extension]) {
      this.#extensions[extension] = this.gl.getExtension(extension);
    }
    const ef = this.#extensions[extension];
    return method ? ef ? ef[extFunc].bind(ef) : null : ef;
  }
  getRenderList({ scene, camera }) {
    const renderList = [];
    scene.traverse((node) => {
      if (!node.visible)
        return true;
      if (!node.draw)
        return;
      if (this.#frustumCull && node.frustumCulled && camera) {
        if (!camera.frustumIntersectsMesh(node))
          return;
      }
      renderList.push(node);
    });
    return renderList;
  }
  render(params) {
    const { scene, camera, target = null, update = true, clear } = params;
    if (target === null) {
      this.#state.bindFramebuffer({
        buffer: null
      });
      this.setViewport(this.width * this.#dpr, this.height * this.#dpr);
    } else {
      target.bind();
      this.setViewport(target.width, target.height);
    }
    if (clear || this.#autoClear && clear !== false) {
      if (this.#depth && (!target || target.depth)) {
        this.#state.enable(this.gl.DEPTH_TEST);
        this.#state.setDepthMask(true);
      }
      this.clear(this.#color, this.#depth, this.#stencil);
    }
    if (update)
      scene.updateMatrixWorld();
    if (camera)
      camera.updateMatrixWorld();
    const renderList = this.getRenderList({ scene, camera });
    let i = 0;
    const len = renderList.length;
    for (; i < len; i++) {
      const node = renderList[i];
      node.draw({ camera });
    }
    if (target) {
      target.unbind();
    }
  }
  clear(color = this.#color, depth = this.#depth, stencil = this.#stencil) {
    let bits = 0;
    if (color)
      bits |= this.gl.COLOR_BUFFER_BIT;
    if (depth)
      bits |= this.gl.DEPTH_BUFFER_BIT;
    if (stencil)
      bits |= this.gl.STENCIL_BUFFER_BIT;
    this.gl.clear(bits);
  }
  resetState(force = true, vao = null) {
    this.#state.reset(force);
    this.bindVertexArray(vao);
  }
}

const ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
class Resource extends Base {
  #handle;
  #lastHandle;
  id;
  name;
  userData;
  byteLength;
  options;
  constructor(renderer, options = {}) {
    super(renderer);
    this.id = options?.id || uid(this.constructor.name);
    this.name = options?.name;
    this.userData = options?.userData;
    this.#handle = options?.handle;
    this.options = options;
    if (this.#handle === void 0) {
      this.#handle = this.createHandle();
    }
    this.byteLength = 0;
  }
  get handle() {
    return this.#handle;
  }
  swapHandle(handle) {
    this.#lastHandle = this.#handle;
    this.#handle = handle;
  }
  restoreHandle() {
    this.#handle = this.#lastHandle;
  }
  destroy() {
    this.delete();
  }
  delete({ deleteChildren = false } = {}) {
    const children = this.handle && this.deleteHandle(this.handle);
    if (this.handle) {
      this.removeStats();
    }
    this.#handle = null;
    if (children && deleteChildren) {
      children.filter(Boolean).forEach((child) => child.delete());
    }
    return this;
  }
  bind(funcOrHandle = this.handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  unbind() {
    this.bind(null);
  }
  removeStats() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  toString() {
    return `${this.constructor.name}(${this.id})`;
  }
}

class RenderBuffer extends Resource {
  width;
  height;
  #internalFormat;
  constructor(renderer, options = {}) {
    super(renderer, {
      ...options,
      format: options.format || renderer.gl.DEPTH_COMPONENT16
    });
    this.#internalFormat = this.options.format;
    this.width = this.options.width;
    this.height = this.options.height;
    console.assert(
      this.width > 0 && this.height > 0,
      "Renderbuffer object requires valid width and height greater than zero"
    );
    this.bind();
    renderer.gl.renderbufferStorage(
      renderer.gl.RENDERBUFFER,
      this.#internalFormat,
      this.width,
      this.height
    );
  }
  resize(width, height) {
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.bind();
    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.#internalFormat, width, height);
    this.unbind();
  }
  bind() {
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.handle);
  }
  unbind() {
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
  }
  removeStats() {
  }
  destroy() {
    this.unbind();
    this.deleteHandle();
  }
  createHandle() {
    return this.gl.createRenderbuffer();
  }
  deleteHandle() {
    this.handle && this.gl.deleteRenderbuffer(this.handle);
  }
}

const emptyPixel = new Uint8Array(4);
class Texture extends Resource {
  needsUpdate = false;
  textureUnit = 0;
  image;
  width;
  height;
  target;
  #state = {};
  constructor(renderer, options = {}, needsUpdate = true) {
    const { gl } = renderer;
    const defaultOptions = {
      target: gl.TEXTURE_2D,
      type: gl.UNSIGNED_BYTE,
      format: gl.RGBA,
      internalFormat: options.format || gl.RGBA,
      wrapS: gl.CLAMP_TO_EDGE,
      wrapT: gl.CLAMP_TO_EDGE,
      generateMipmaps: true,
      minFilter: gl.LINEAR,
      magFilter: gl.LINEAR,
      premultiplyAlpha: false,
      unpackAlignment: 4,
      anisotropy: 0,
      flipY: false,
      level: 0
    };
    const opt = Object.assign({}, defaultOptions, options);
    super(renderer, opt);
    this.textureUnit = 0;
    this.image = this.options.image;
    this.width = this.options.width;
    this.height = this.options.height;
    this.target = this.options.target;
    this.#state.version = -1;
    this.needsUpdate = Boolean(needsUpdate);
    if (this.needsUpdate) {
      this.update();
    }
  }
  setData(image, width = this.width, height = this.height) {
    this.image = image;
    this.width = width;
    this.height = height;
    this.needsUpdate = true;
  }
  setOptions(options) {
    this.options = Object.assign(this.options, options);
    this.width = this.options.width;
    this.height = this.options.height;
    this.needsUpdate = true;
  }
  fromSrc(url) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => {
        this.setData(image, image.width, image.height);
        resolve(this);
      };
      image.onerror = (e) => {
        reject(e);
      };
      image.crossOrigin = "*";
      image.src = url;
    });
  }
  update(units = 0) {
    const needUpdate = !(this.image === this.#state.image && !this.needsUpdate);
    const checked = needUpdate || this.rendererState.textureUnits[units] !== this.id || this.rendererState.activeTextureUnit !== units;
    if (checked) {
      this.rendererState.setActiveTexture(units);
      this.bind(units);
    }
    if (!needUpdate)
      return;
    this.needsUpdate = false;
    if (this.options.wrapS !== this.#state.wrapS) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.options.wrapS);
      this.#state.wrapS = this.options.wrapS;
    }
    if (this.options.wrapT !== this.#state.wrapT) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.options.wrapT);
      this.#state.wrapT = this.options.wrapT;
    }
    if (this.options.minFilter !== this.#state.minFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MIN_FILTER,
        this.options.minFilter
      );
      this.#state.minFilter = this.options.minFilter;
    }
    if (this.options.magFilter !== this.#state.magFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MAG_FILTER,
        this.options.magFilter
      );
      this.#state.magFilter = this.options.magFilter;
    }
    if (this.options.flipY !== this.rendererState.flipY) {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.options.flipY);
      this.rendererState.flipY = this.options.flipY;
    }
    if (this.options.premultiplyAlpha !== this.rendererState.premultiplyAlpha) {
      this.gl.pixelStorei(
        this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        this.options.premultiplyAlpha
      );
      this.rendererState.premultiplyAlpha = this.options.premultiplyAlpha;
    }
    if (this.options.unpackAlignment !== this.rendererState.unpackAlignment) {
      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.options.unpackAlignment);
      this.rendererState.unpackAlignment = this.options.unpackAlignment;
    }
    if (this.options.anisotropy && this.options.anisotropy !== this.rendererState.anisotropy) {
      const extTextureFilterAnisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
      if (extTextureFilterAnisotropic) {
        const max = this.gl.getParameter(
          extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
        );
        let v = this.options.anisotropy;
        if (this.options.anisotropy > max) {
          v = max;
          console.warn(
            `[Texture]: Texture.anisotropy option exceeded the maximum allowed value ${max} of the device`
          );
        }
        this.gl.texParameterf(
          this.target,
          extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          v
        );
      }
      this.rendererState.anisotropy = this.options.anisotropy;
    }
    if (this.image) {
      if (this.image.width) {
        this.width = this.image.width;
        this.height = this.image.height;
      }
      if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
        this.gl.texImage2D(
          this.target,
          this.options.level,
          this.options.internalFormat,
          this.width,
          this.height,
          0,
          this.options.format,
          this.options.type,
          this.image,
          this.options.offset
        );
      } else {
        if (ArrayBuffer.isView(this.image)) {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            0,
            this.options.format,
            this.options.type,
            this.image
          );
        } else {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.options.format,
            this.options.type,
            this.image
          );
        }
      }
      if (this.options.generateMipmaps) {
        if (this.renderer.isWebGL2 || isPowerOfTwo(this.image.width) && isPowerOfTwo(this.image.height)) {
          this.gl.generateMipmap(this.target);
        } else {
          this.options.generateMipmaps = false;
          this.options.wrapS = this.gl.CLAMP_TO_EDGE;
          this.options.wrapT = this.options.wrapS;
          this.options.minFilter = this.gl.LINEAR;
        }
      }
    } else {
      if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
        if (this.width > 0) {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            0,
            this.options.format,
            this.options.type,
            this.options.offset
          );
        } else {
          this.gl.texImage2D(
            this.target,
            0,
            this.gl.RGBA,
            1,
            1,
            0,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            emptyPixel,
            this.options.offset
          );
        }
      } else {
        if (this.width > 0) {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            0,
            this.options.format,
            this.options.type,
            null
          );
        } else {
          this.gl.texImage2D(
            this.target,
            0,
            this.gl.RGBA,
            1,
            1,
            0,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            emptyPixel
          );
        }
      }
    }
    this.#state.image = this.image;
    this.#state.version += 1;
  }
  bind(unit = this.textureUnit) {
    if (this.rendererState.textureUnits[this.rendererState.activeTextureUnit] === this.id)
      return;
    this.textureUnit = unit;
    this.rendererState.textureUnits[this.textureUnit] = this.id;
    this.gl.bindTexture(this.target, this.handle);
  }
  unbind() {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.textureUnit);
    this.gl.bindTexture(this.target, null);
    delete this.rendererState.textureUnits[this.textureUnit];
  }
  destroy() {
    this.unbind();
    super.destroy();
  }
  removeStats() {
    this.#state = {
      version: -1
    };
  }
  createHandle() {
    return this.gl.createTexture();
  }
  deleteHandle() {
    if (this.handle) {
      this.gl.deleteTexture(this.handle);
    }
  }
  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }
}

class DataTexture extends Texture {
  needsUpdate = true;
  constructor(renderer, options = {}) {
    super(renderer, {
      ...options,
      image: options.data,
      premultiplyAlpha: true,
      flipY: false,
      unpackAlignment: 1
    });
  }
}

class RenderTarget extends Resource {
  #textures;
  #renderBuffers;
  depth;
  width;
  height;
  viewport;
  drawBuffersChanged;
  drawBuffers;
  #clearColors;
  #clearDepth;
  #clearStencil;
  constructor(renderer, options = {}) {
    super(renderer, {
      color: 1,
      depth: true,
      depthTexture: false,
      stencil: false,
      ...options
    });
    this.#renderBuffers = /* @__PURE__ */ new Map();
    this.#textures = /* @__PURE__ */ new Map();
    this.depth = Boolean(options.depth);
    this.drawBuffers = [];
    this.drawBuffersChanged = false;
    this.width = this.options.width;
    this.height = this.options.height;
    this.viewport = new Vector4(0, 0, this.width, this.height);
    this.name = this.options.name;
    const attachments = this.options.attachments || [];
    if (attachments.length === 0) {
      for (let i = 0; i < this.options.color; i++) {
        const opt = {
          wrapS: this.gl.CLAMP_TO_EDGE,
          wrapT: this.gl.CLAMP_TO_EDGE,
          minFilter: this.gl.LINEAR,
          magFilter: this.gl.LINEAR,
          type: this.gl.UNSIGNED_BYTE,
          format: this.gl.RGBA,
          flipY: false,
          generateMipmaps: false,
          ...options
        };
        let texture;
        if (opt.data) {
          texture = new DataTexture(renderer, opt);
        } else {
          texture = new Texture(
            renderer,
            omit(opt, [
              "data",
              "name",
              "attachments",
              "depthTexture"
            ])
          );
        }
        attachments.push([this.gl.COLOR_ATTACHMENT0 + i, texture]);
      }
      if (options.depthTexture && (renderer.isWebGL2 || !renderer.isWebGL2 && renderer.gl.getExtension("WEBGL_depth_texture"))) {
        const texture = new Texture(renderer, {
          width: this.width,
          height: this.height,
          minFilter: this.gl.NEAREST,
          magFilter: this.gl.NEAREST,
          format: this.gl.DEPTH_COMPONENT,
          internalFormat: renderer.isWebGL2 ? this.gl.DEPTH_COMPONENT16 : this.gl.DEPTH_COMPONENT,
          type: this.gl.UNSIGNED_INT
        });
        attachments.push([this.gl.DEPTH_ATTACHMENT, texture]);
      } else {
        const { depth, stencil } = options;
        if (depth && !stencil) {
          const renderBuffer = new RenderBuffer(renderer, {
            format: this.gl.DEPTH_COMPONENT16,
            width: this.width,
            height: this.height
          });
          attachments.push([this.gl.DEPTH_ATTACHMENT, renderBuffer]);
        } else if (stencil && !depth) {
          const renderBuffer = new RenderBuffer(renderer, {
            format: this.gl.STENCIL_INDEX8,
            width: this.width,
            height: this.height
          });
          attachments.push([this.gl.STENCIL_ATTACHMENT, renderBuffer]);
        } else if (depth && stencil) {
          const renderBuffer = new RenderBuffer(renderer, {
            format: this.gl.DEPTH_STENCIL,
            width: this.width,
            height: this.height
          });
          attachments.push([this.gl.DEPTH_STENCIL_ATTACHMENT, renderBuffer]);
        }
      }
    }
    this.create(attachments);
  }
  get texture() {
    return this.#textures.values().next().value;
  }
  set clearColors(colors) {
    this.#clearColors = colors;
  }
  get clearColors() {
    return this.#clearColors;
  }
  set clearDepth(depth) {
    this.#clearDepth = depth;
  }
  get clearDepth() {
    return this.#clearDepth;
  }
  set clearStencil(stencil) {
    this.#clearStencil = stencil;
  }
  get clearStencil() {
    return this.#clearStencil;
  }
  create(attachments) {
    this.#clearColors = [];
    this.#clearDepth = 1;
    this.#clearStencil = 0;
    for (const attachment of attachments) {
      const attach = attachment[0];
      const target = attachment[1];
      if (target instanceof RenderBuffer) {
        this.#renderBuffers.set(attach, target);
      } else if (target instanceof Texture) {
        this.#textures.set(attach, target);
        this.drawBuffers.push(attach);
      }
      const i = attach - this.gl.COLOR_ATTACHMENT0;
      this.#clearColors[i] = [0, 0, 0, 0];
    }
    if (this.options.color > 1) {
      if (this.renderer.isWebGL2) {
        this.gl.drawBuffers(this.drawBuffers);
      } else {
        const ext = this.renderer.extension("WEBGL_draw_buffers");
        if (ext && ext.drawBuffersWEBGL) {
          ext.drawBuffersWEBGL(this.drawBuffers);
        } else {
          throw new Error(
            "Please open the corresponding extension [WEBGL_draw_buffers](https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_draw_buffers#browser_compatibility) and check whether the browser supports it"
          );
        }
      }
    }
    this.drawBuffersChanged = true;
    this.bind();
    this.#renderBuffers.forEach((rbo, attachment) => {
      this.gl.framebufferRenderbuffer(
        this.gl.FRAMEBUFFER,
        attachment,
        this.gl.RENDERBUFFER,
        rbo.handle
      );
    });
    this.#textures.forEach((texture, attachment) => {
      this.gl.framebufferTexture2D(
        this.gl.FRAMEBUFFER,
        attachment,
        this.gl.TEXTURE_2D,
        texture.handle,
        0
      );
    });
    this.unbind();
    const status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
    if (status !== this.gl.FRAMEBUFFER_COMPLETE) {
      switch (status) {
        case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error(
            "The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete"
          );
        case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error("There is no attachment");
        case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error(" Height and width of the attachment are not the same.");
        case this.gl.FRAMEBUFFER_UNSUPPORTED:
          throw new Error(
            "The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer"
          );
      }
    }
    return this.handle;
  }
  clear() {
    this.bind();
    let flags = 0;
    if (this.clearColors[0]) {
      const color = this.clearColors[0];
      this.gl.clearColor(color[0], color[1], color[2], color[3]);
      flags |= this.gl.COLOR_BUFFER_BIT;
    }
    if (isNumber(this.#clearDepth)) {
      this.gl.clearDepth(this.#clearDepth);
      flags |= this.gl.DEPTH_BUFFER_BIT;
    }
    if (isNumber(this.#clearStencil)) {
      this.gl.clearStencil(this.#clearStencil);
      flags |= this.gl.STENCIL_BUFFER_BIT;
    }
    this.gl.clear(flags);
    this.unbind();
  }
  getTexture(key) {
    return this.#textures.get(key);
  }
  resize(width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.#textures.forEach((texture) => {
        if (texture.width !== width || texture.height !== height) {
          texture.width = width;
          texture.height = height;
          texture.needsUpdate = true;
          texture.update();
        }
      });
      this.#renderBuffers.forEach((rbo) => {
        rbo.resize(width, height);
      });
      this.viewport.set(0, 0, width, height);
    }
  }
  bind(fbo = this.gl.FRAMEBUFFER) {
    this.gl.bindFramebuffer(fbo, this.handle);
  }
  unbind(fbo = this.gl.FRAMEBUFFER) {
    this.gl.bindFramebuffer(fbo, null);
  }
  removeStats() {
  }
  destroy() {
    this.#textures.forEach((texture) => {
      texture.destroy();
    });
    this.#renderBuffers.forEach((buffer) => {
      buffer.destroy();
    });
    this.deleteHandle();
  }
  createHandle() {
    return this.gl.createFramebuffer();
  }
  deleteHandle() {
    this.handle && this.gl.deleteFramebuffer(this.handle);
  }
  toString() {
    return `RenderTarget(${this.id},${this.width}x${this.height})`;
  }
}

function getPlaneBuffer(position, normal, uv, index, width = 1, height = 1, depth = 0, widthSegments = 1, heightSegments = 1, u = 0, v = 1, w = 2, uDir = 1, vDir = -1, i = 0, ii = 0) {
  const consti = i;
  const widthHalf = width / 2;
  const heightHalf = height / 2;
  const depthHalf = depth / 2;
  const gridX = Math.floor(widthSegments);
  const gridY = Math.floor(heightSegments);
  const gridX1 = gridX + 1;
  const gridY1 = gridY + 1;
  const segmentWidth = width / gridX;
  const segmentHeight = height / gridY;
  for (let iy = 0; iy < gridY1; iy++) {
    const y = iy * segmentHeight - heightHalf;
    for (let ix = 0; ix < gridX1; ix++) {
      position[i * 3 + u] = (ix * segmentWidth - widthHalf) * uDir;
      position[i * 3 + v] = y * vDir;
      position[i * 3 + w] = depthHalf;
      normal[i * 3 + u] = 0;
      normal[i * 3 + v] = 0;
      normal[i * 3 + w] = depth >= 0 ? 1 : -1;
      uv[i * 2] = ix / gridX;
      uv[i * 2 + 1] = 1 - iy / gridY;
      i++;
      if (iy === gridY || ix === gridX)
        continue;
      const a = consti + ix + gridX1 * iy;
      const b = consti + ix + gridX1 * (iy + 1);
      const c = consti + ix + 1 + gridX1 * (iy + 1);
      const d = consti + ix + 1 + gridX1 * iy;
      index[ii * 6] = a;
      index[ii * 6 + 1] = b;
      index[ii * 6 + 2] = d;
      index[ii * 6 + 3] = b;
      index[ii * 6 + 4] = c;
      index[ii * 6 + 5] = d;
      ii++;
    }
  }
}
class Plane extends Geometry {
  constructor(renderer, {
    width = 1,
    height = 1,
    widthSegments = 1,
    heightSegments = 1,
    attributes = {}
  } = {}) {
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const num = gridX1 * gridY1;
    const numIndices = gridX * gridY * 6;
    const position = new Float32Array(num * 3);
    const normal = new Float32Array(num * 3);
    const uv = new Float32Array(num * 2);
    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);
    getPlaneBuffer(position, normal, uv, index, width, height, 0, widthSegments, heightSegments);
    super(renderer, {
      ...attributes,
      position: {
        size: 3,
        data: position
      },
      normal: {
        size: 3,
        data: normal
      },
      uv: {
        size: 2,
        data: uv
      },
      index: {
        data: index
      }
    });
  }
}

class Box extends Geometry {
  constructor(renderer, {
    width = 1,
    height = 1,
    depth = 1,
    widthSegments = 1,
    heightSegments = 1,
    depthSegments = 1,
    attributes = {}
  } = {}) {
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridZ = Math.floor(depthSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const gridZ1 = gridZ + 1;
    const num = gridX1 * gridY1 * 2 + gridX1 * gridZ1 * 2 + gridY1 * gridZ1 * 2;
    const numIndices = (gridX * gridY * 2 + gridX * gridZ * 2 + gridY * gridZ * 2) * 6;
    const position = new Float32Array(num * 3);
    const normal = new Float32Array(num * 3);
    const uv = new Float32Array(num * 2);
    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);
    let i = 0;
    let ii = 0;
    const d = gridZ1 * gridY1;
    const w = gridX1 * gridZ1;
    const h = gridX1 * gridY1;
    const dt = gridZ * gridY;
    const wt = gridX * gridZ;
    const ht = gridX * gridY;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index,
      depth,
      height,
      width,
      depthSegments,
      heightSegments,
      2,
      1,
      0,
      -1,
      -1,
      i,
      ii
    );
    i += d;
    ii += dt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index,
      depth,
      height,
      -width,
      depthSegments,
      heightSegments,
      2,
      1,
      0,
      1,
      -1,
      i,
      ii
    );
    i += d;
    ii += dt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index,
      width,
      depth,
      height,
      depthSegments,
      widthSegments,
      0,
      2,
      1,
      1,
      1,
      i,
      ii
    );
    i += w;
    ii += wt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index,
      width,
      depth,
      -height,
      depthSegments,
      widthSegments,
      0,
      2,
      1,
      1,
      -1,
      i,
      ii
    );
    i += w;
    ii += wt;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index,
      width,
      height,
      -depth,
      widthSegments,
      heightSegments,
      0,
      1,
      2,
      -1,
      -1,
      i,
      ii
    );
    i += h;
    ii += ht;
    getPlaneBuffer(
      position,
      normal,
      uv,
      index,
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      0,
      1,
      2,
      1,
      -1,
      i,
      ii
    );
    super(renderer, {
      ...attributes,
      position: {
        size: 3,
        data: position
      },
      normal: {
        size: 3,
        data: normal
      },
      uv: {
        size: 2,
        data: uv
      },
      index: {
        data: index
      }
    });
  }
}

const ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
const cachedIds = {};
function genShaderName(key = "id") {
  cachedIds[key] = cachedIds[key] || 1;
  const idx = cachedIds[key];
  cachedIds[key] += 1;
  return "".concat(key, "-").concat(idx);
}
const getTypeName = (ctx, shaderType) => {
  switch (shaderType) {
    case ctx.VERTEX_SHADER:
      return "vertex-shader";
    case ctx.FRAGMENT_SHADER:
      return "fragment-shader";
    default:
      return "unknown";
  }
};
const getShaderType = (ctx, type) => {
  switch (type) {
    case "fragment":
      return ctx.FRAGMENT_SHADER;
    case "vertex":
      return ctx.VERTEX_SHADER;
    default:
      return;
  }
};
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
class Shader extends Resource {
  #shaderType;
  #includes;
  sourceCode;
  constructor(renderer, sourceCode, type, includes = {}) {
    const shaderType = getShaderType(renderer.gl, type);
    super(renderer, {
      name: getShaderName(sourceCode) || genShaderName(getTypeName(renderer, shaderType))
    });
    console.assert(typeof sourceCode === "string", ERR_SOURCE);
    this.#includes = includes;
    this.#shaderType = shaderType;
    this.sourceCode = this.injectShaderModule(sourceCode, includes || {}).replace(
      /\n\n+/gm,
      "\n\n"
    );
    this.createShader(this.sourceCode);
  }
  injectShaderModule(shader, modules = {}) {
    const regExp = /^[\t ]*#glsl_include +<([\w.]+)>/gm;
    const replacement = (substring, r) => {
      let module = modules[r];
      if (module === void 0)
        throw new Error("Cannot resolve #include <".concat(r, ">"));
      module = module.replace(/#include </g, "#glsl_include <");
      return this.injectShaderModule(module, modules);
    };
    return shader.replace(regExp, replacement);
  }
  createShader(source = this.source) {
    let s = source.replace(/#include </g, "#glsl_include <");
    s = this.injectShaderModule(s, this.#includes || {}).replace(/\n\n+/gm, "\n\n");
    this.gl.shaderSource(this.handle, s);
    this.gl.compileShader(this.handle);
    if (!this.gl.getShaderParameter(this.handle, this.gl.COMPILE_STATUS)) {
      const log = this.gl.getShaderInfoLog(this.handle) || "";
      this.gl.deleteShader(this.handle);
      throw new Error(`${this.toString()}
${log}
${addLineNumbers(s)}`);
    }
  }
  get source() {
    return this.sourceCode;
  }
  get shaderType() {
    return this.#shaderType;
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  setSource(source) {
    const name = getShaderName(source);
    if (name) {
      this.name = genShaderName(name);
    }
    this.createShader(source);
  }
  removeStats() {
  }
  deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  toString() {
    return `${getTypeName(this.gl, this.shaderType)}:${this.id}`;
  }
}
class VertexShader extends Shader {
  constructor(renderer, sourceCode, includes) {
    super(renderer, sourceCode, "vertex", includes);
  }
  createHandle() {
    return this.gl.createShader(this.gl.VERTEX_SHADER);
  }
}
class FragmentShader extends Shader {
  constructor(renderer, sourceCode, includes) {
    super(renderer, sourceCode, "fragment", includes);
  }
  createHandle() {
    return this.gl.createShader(this.gl.FRAGMENT_SHADER);
  }
}

const getDefines = (t) => {
  const defines = [];
  return defines.map((d) => "#define ".concat(d));
};
const arrayCacheF32 = {};
function flatten(a) {
  const arrayLen = a.length;
  const valueLen = a[0].length;
  if (valueLen === void 0)
    return a;
  const length = arrayLen * valueLen;
  let value = arrayCacheF32[length];
  if (!value)
    arrayCacheF32[length] = value = new Float32Array(length);
  for (let i = 0; i < arrayLen; i++)
    value.set(a[i], i * valueLen);
  return value;
}
function setUniform(gl, type, location, value) {
  value = value.length ? flatten(value) : value;
  const isArray = value.length;
  switch (type) {
    case WebGLRenderingContext.FLOAT:
      return isArray ? gl.uniform1fv(location, value) : gl.uniform1f(location, value);
    case WebGLRenderingContext.FLOAT_VEC2:
      return gl.uniform2fv(location, value);
    case WebGLRenderingContext.FLOAT_VEC3:
      return gl.uniform3fv(location, value);
    case WebGLRenderingContext.FLOAT_VEC4:
      return gl.uniform4fv(location, value);
    case WebGLRenderingContext.BOOL:
    case WebGLRenderingContext.INT:
    case WebGLRenderingContext.SAMPLER_2D:
    case WebGLRenderingContext.SAMPLER_CUBE:
      return isArray ? gl.uniform1iv(location, value) : gl.uniform1i(location, value);
    case WebGLRenderingContext.BOOL_VEC2:
    case WebGLRenderingContext.INT_VEC2:
      return gl.uniform2iv(location, value);
    case WebGLRenderingContext.BOOL_VEC3:
    case WebGLRenderingContext.INT_VEC3:
      return gl.uniform3iv(location, value);
    case WebGLRenderingContext.BOOL_VEC4:
    case WebGLRenderingContext.INT_VEC4:
      return gl.uniform4iv(location, value);
    case WebGLRenderingContext.FLOAT_MAT2:
      return gl.uniformMatrix2fv(location, false, value);
    case WebGLRenderingContext.FLOAT_MAT3:
      return gl.uniformMatrix3fv(location, false, value);
    case WebGLRenderingContext.FLOAT_MAT4:
      return gl.uniformMatrix4fv(location, false, value);
  }
}
class Program extends Resource {
  attributeOrder;
  uniforms;
  #uniformLocations;
  #attributeLocations;
  #vs;
  #fs;
  #renderState;
  constructor(renderer, options = {}) {
    super(renderer, options);
    const {
      id,
      vertexShader,
      fragmentShader,
      uniforms = {},
      transparent = false,
      defines = [],
      includes = {},
      cullFace,
      frontFace = renderer.gl.CCW,
      depthTest = true,
      depthWrite = true,
      depthFunc = renderer.gl.LESS,
      blending = 1,
      blendFunc,
      blendEquation
    } = options;
    this.id = id || uid("program");
    const defs = [
      ...getDefines({
        ...options,
        ...uniforms
      }),
      ...defines
    ].map((str) => !str.startsWith("#define ") ? "#define ".concat(str) : str);
    if (!vertexShader || !fragmentShader) {
      throw new Error(`Program: ${this.id}\uFF1Amust provide vertexShader and fragmentShader`);
    }
    this.#vs = typeof vertexShader === "string" ? new VertexShader(renderer, parseShader(vertexShader, defs), includes) : vertexShader;
    this.#fs = typeof fragmentShader === "string" ? new FragmentShader(renderer, parseShader(fragmentShader, defs), includes) : fragmentShader;
    this.gl.attachShader(this.handle, this.#vs.handle);
    this.gl.attachShader(this.handle, this.#fs.handle);
    this.gl.linkProgram(this.handle);
    this.gl.validateProgram(this.handle);
    if (!this.gl.getProgramParameter(this.handle, this.gl.LINK_STATUS)) {
      throw new Error(
        "Program:".concat(this.id, ": Error linking ").concat(this.gl.getProgramInfoLog(this.handle))
      );
    }
    this.uniforms = uniforms;
    this.#renderState = {
      blending,
      cullFace,
      frontFace,
      depthTest,
      depthWrite,
      depthFunc,
      blendFunc,
      blendEquation
    };
    this.#uniformLocations = /* @__PURE__ */ new Map();
    this.#attributeLocations = /* @__PURE__ */ new Map();
    this.#assignUniforms(uniforms);
    this.#assignAttributes();
    if (transparent && !blendFunc?.src) {
      if (this.renderer.premultipliedAlpha) {
        this.#renderState.blendFunc = {
          ...blendFunc,
          src: this.gl.ONE,
          dst: this.gl.ONE_MINUS_SRC_ALPHA
        };
      } else {
        this.#renderState.blendFunc = {
          ...blendFunc,
          src: this.gl.SRC_ALPHA,
          dst: this.gl.ONE_MINUS_SRC_ALPHA
        };
      }
    }
  }
  get uniformLocations() {
    return this.#uniformLocations;
  }
  get attributeLocations() {
    return this.#attributeLocations;
  }
  get vertexShader() {
    return this.#vs;
  }
  get fragmentShader() {
    return this.#fs;
  }
  use() {
    const programActive = this.rendererState.currentProgramId === this.id;
    let textureUnit = -1;
    if (!programActive) {
      this.gl.useProgram(this.handle);
      this.rendererState.currentProgramId = this.id;
    }
    this.#uniformLocations.forEach((location, activeUniform) => {
      const name = activeUniform.name;
      const uniform = this.uniforms[name];
      if (!uniform) {
        console.warn("Program:".concat(this.id, ": Active uniform ").concat(name, " has not been supplied"));
        return;
      }
      if (uniform && (isUndef(uniform.value) || isNull(uniform.value))) {
        console.warn("Program:".concat(this.id, ": Uniform ").concat(name, " is missing a value parameter"));
        return;
      }
      let value = uniform?.value;
      if (value instanceof Texture) {
        textureUnit += 1;
        uniform.value.update(textureUnit);
        return setUniform(this.gl, activeUniform.type, location.location, textureUnit);
      }
      if (value instanceof Matrix || value instanceof Vector) {
        value = uniform.value.toArray();
      } else if (value instanceof Color) {
        value = uniform.value.toArray();
      }
      if (value && value.length > 0 && value[0] instanceof Texture) {
        const units = [];
        for (let i = 0; i < uniform.value.length; i++) {
          const v = value[i];
          textureUnit += 1;
          v.update(textureUnit);
          units.push(textureUnit);
        }
        return setUniform(this.gl, activeUniform.type, location.location, units);
      }
      setUniform(this.gl, activeUniform.type, location.location, value);
    });
    this.applyState();
  }
  setStates(states, merge = true) {
    if (!merge) {
      this.#renderState = states;
    } else {
      this.#renderState = {
        ...this.#renderState,
        ...omit(states, ["blendFunc", "blendEquation"])
      };
      if (states.blendFunc) {
        this.#renderState.blendFunc = {
          ...this.#renderState.blendFunc,
          ...states.blendFunc
        };
      }
      if (states.blendEquation) {
        this.#renderState.blendEquation = {
          ...this.#renderState.blendEquation,
          ...states.blendEquation
        };
      }
    }
  }
  applyState() {
    this.rendererState.apply(this.#renderState);
  }
  setUniform(key, value) {
    if (this.uniforms[key]) {
      this.uniforms[key].value = value;
    }
  }
  bind() {
    this.gl.useProgram(this.handle);
  }
  unbind() {
    this.gl.useProgram(null);
  }
  createHandle() {
    return this.gl.createProgram();
  }
  deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  #assignUniforms(uniforms = {}) {
    const numUniforms = this.gl.getProgramParameter(this.handle, this.gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < numUniforms; i++) {
      const uniformInfo = this.gl.getActiveUniform(this.handle, i);
      if (!uniformInfo)
        break;
      const name = uniformInfo.name;
      const split = name.match(/(\w+)/g);
      const uniformData = {
        location: this.gl.getUniformLocation(this.handle, name),
        type: uniformInfo.type,
        name: split[0],
        isStruct: false
      };
      if (split.length === 3) {
        uniformData.isStructArray = true;
        uniformData.structIndex = Number(split[1]);
        uniformData.structProperty = split[2];
      } else if (split.length === 2 && isNaN(Number(split[1]))) {
        uniformData.isStruct = true;
        uniformData.structProperty = split[1];
      }
      const v = uniforms[name]?.value;
      if (!isUndef(v) && !isNull(v)) {
        uniformData.value = uniforms[name].value;
      }
      this.uniforms[name] = uniformData;
      this.#uniformLocations.set(uniformInfo, uniformData);
    }
  }
  #assignAttributes() {
    const numAttribs = this.gl.getProgramParameter(this.handle, this.gl.ACTIVE_ATTRIBUTES);
    const locations = [];
    for (let i = 0; i < numAttribs; i++) {
      const attribInfo = this.gl.getActiveAttrib(this.handle, i);
      if (!attribInfo)
        break;
      const location = this.gl.getAttribLocation(this.handle, attribInfo.name);
      locations[location] = attribInfo.name;
      this.#attributeLocations.set(attribInfo, location);
    }
    this.attributeOrder = locations.join("");
  }
  destroy() {
    this.unbind();
    this.deleteHandle();
  }
}

class Texture3D extends Texture {
  needsUpdate = false;
  textureUnit = 0;
  depth;
  #state = {};
  constructor(renderer, options = {}) {
    const gl = renderer.gl;
    const defaultOptions = {
      target: gl.TEXTURE_3D,
      type: gl.UNSIGNED_BYTE,
      format: gl.RGBA,
      internalFormat: options.format || gl.RGBA,
      wrapS: gl.CLAMP_TO_EDGE,
      wrapT: gl.CLAMP_TO_EDGE,
      wrapR: gl.CLAMP_TO_EDGE,
      generateMipmaps: true,
      minFilter: gl.LINEAR,
      magFilter: gl.LINEAR,
      premultiplyAlpha: false,
      unpackAlignment: 4,
      flipY: false,
      level: 0,
      depth: 0
    };
    const opt = Object.assign({}, defaultOptions, options);
    super(renderer, opt, false);
    this.needsUpdate = true;
    this.depth = this.options.depth;
    this.#state.version = -1;
    this.update();
  }
  get gl() {
    return this.renderer.gl;
  }
  setData(image, width = this.width, height = this.height, depth = this.depth) {
    this.image = image;
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.needsUpdate = true;
  }
  setOptions(options) {
    this.options = Object.assign(this.options, options);
    this.width = this.options.width;
    this.height = this.options.height;
    this.depth = this.options.depth;
    this.needsUpdate = true;
  }
  update(units = 0) {
    const needUpdate = !(this.image === this.#state.image && !this.needsUpdate);
    const checked = needUpdate || this.rendererState.textureUnits[units] !== this.id || this.rendererState.activeTextureUnit !== units;
    if (checked) {
      this.rendererState.setActiveTexture(units);
      this.bind(units);
    }
    if (!needUpdate)
      return;
    this.needsUpdate = false;
    if (this.options.wrapS !== this.#state.wrapS) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.options.wrapS);
      this.#state.wrapS = this.options.wrapS;
    }
    if (this.options.wrapT !== this.#state.wrapT) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.options.wrapT);
      this.#state.wrapT = this.options.wrapT;
    }
    if (this.options.wrapR !== this.#state.wrapR) {
      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.options.wrapR);
      this.#state.wrapR = this.options.wrapR;
    }
    if (this.options.minFilter !== this.#state.minFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MIN_FILTER,
        this.options.minFilter
      );
      this.#state.minFilter = this.options.minFilter;
    }
    if (this.options.magFilter !== this.#state.magFilter) {
      this.gl.texParameteri(
        this.target,
        this.gl.TEXTURE_MAG_FILTER,
        this.options.magFilter
      );
      this.#state.magFilter = this.options.magFilter;
    }
    if (this.options.flipY !== this.rendererState.flipY) {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.options.flipY);
      this.rendererState.flipY = this.options.flipY;
    }
    if (this.options.premultiplyAlpha !== this.rendererState.premultiplyAlpha) {
      this.gl.pixelStorei(
        this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        this.options.premultiplyAlpha
      );
      this.rendererState.premultiplyAlpha = this.options.premultiplyAlpha;
    }
    if (this.options.unpackAlignment !== this.rendererState.unpackAlignment) {
      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.options.unpackAlignment);
      this.rendererState.unpackAlignment = this.options.unpackAlignment;
    }
    if (this.options.anisotropy && this.options.anisotropy !== this.rendererState.anisotropy) {
      const extTextureFilterAnisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
      if (extTextureFilterAnisotropic) {
        const max = this.gl.getParameter(
          extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
        );
        let v = this.options.anisotropy;
        if (this.options.anisotropy > max) {
          v = max;
          console.warn(
            `[Texture]: Texture.anisotropy option exceeded the maximum allowed value ${max} of the device`
          );
        }
        this.gl.texParameterf(
          this.target,
          extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
          v
        );
      }
      this.rendererState.anisotropy = this.options.anisotropy;
    }
    if (this.image) {
      if (this.image.width) {
        this.width = this.image.width;
        this.height = this.image.height;
      }
      if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
        this.gl.texImage3D(
          this.target,
          this.options.level,
          this.options.internalFormat,
          this.width,
          this.height,
          this.depth,
          0,
          this.options.format,
          this.options.type,
          this.image,
          this.options.offset
        );
      } else {
        if (ArrayBuffer.isView(this.image)) {
          this.gl.texImage3D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            this.depth,
            0,
            this.options.format,
            this.options.type,
            this.image
          );
        } else {
          this.gl.texImage3D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            this.depth,
            0,
            this.options.format,
            this.options.type,
            this.image
          );
        }
      }
      if (this.options.generateMipmaps) {
        if (this.renderer.isWebGL2 || isPowerOfTwo(this.image.width) && isPowerOfTwo(this.image.height)) {
          this.gl.generateMipmap(this.target);
        } else {
          this.options.generateMipmaps = false;
          this.options.wrapS = this.gl.CLAMP_TO_EDGE;
          this.options.wrapT = this.options.wrapS;
          this.options.minFilter = this.gl.LINEAR;
        }
      }
    } else {
      if (this.width > 0) {
        this.gl.texImage3D(
          this.target,
          this.options.level,
          this.options.internalFormat,
          this.width,
          this.height,
          this.depth,
          0,
          this.options.format,
          this.options.type,
          null
        );
      } else {
        this.gl.texImage3D(
          this.target,
          0,
          this.gl.RGBA,
          1,
          1,
          this.depth,
          0,
          this.gl.RGBA,
          this.gl.UNSIGNED_BYTE,
          emptyPixel
        );
      }
    }
    this.#state.image = this.image;
    this.#state.version += 1;
  }
  removeStats() {
    this.#state = {
      version: -1
    };
  }
  toString() {
    return `Texture3D(${this.id},${this.width}x${this.height})`;
  }
}

const tempMat4 = new Matrix4();
const tempVec3a = new Vector3();
const tempVec3b = new Vector3();
const ERR_CAMERA_METHOD_UNDEFINED = "Camera subclass must define virtual methods";
class Camera extends Object3D {
  cameraType;
  projectionMatrix;
  viewMatrix;
  projectionViewMatrix;
  worldPosition;
  #near;
  #far;
  #fov;
  #aspect;
  #zoom;
  #bounds;
  frustum;
  constructor({
    near = 0.1,
    far = 100,
    fov = 45,
    aspect = 1,
    bounds,
    zoom = 1
  } = {}) {
    super();
    this.cameraType = "perspective";
    this.projectionMatrix = new ProjectionMatrix();
    this.viewMatrix = new Matrix4();
    this.projectionViewMatrix = new ProjectionMatrix();
    this.worldPosition = new Vector3();
    this.frustum = new Matrix4();
    this.#near = near;
    this.#far = far;
    this.#fov = fov;
    this.#aspect = aspect;
    this.#bounds = bounds;
    this.#zoom = zoom;
    const {
      left,
      right,
      top,
      bottom
    } = bounds || {};
    this.cameraType = left || right ? "orthographic" : "perspective";
    if (this.cameraType === "orthographic") {
      this.orthographic(left, right, top, bottom, near, far, zoom);
    } else {
      this.perspective(fov, aspect, near, far);
    }
  }
  get near() {
    return this.#near;
  }
  set near(n) {
    this.#near = n;
    this.updateProjectionMatrix();
  }
  get far() {
    return this.#far;
  }
  set far(f) {
    this.#far = f;
    this.updateProjectionMatrix();
  }
  get fov() {
    return this.#fov;
  }
  set fov(f) {
    this.#fov = f;
    this.updateProjectionMatrix();
  }
  get aspect() {
    return this.#aspect;
  }
  set aspect(aspect) {
    this.#aspect = aspect;
    this.updateProjectionMatrix();
  }
  get zoom() {
    return this.#zoom;
  }
  set zoom(zoom) {
    this.#zoom = zoom;
    this.updateProjectionMatrix();
  }
  get bounds() {
    return this.#bounds;
  }
  set bounds(bounds) {
    this.#bounds = bounds;
    this.updateProjectionMatrix();
  }
  perspective(fov = this.fov, aspect = this.aspect, near = this.near, far = this.far) {
    this.#fov = fov;
    this.#aspect = aspect;
    this.#near = near;
    this.#far = far;
    this.projectionMatrix.fromPerspective(fov, aspect, near, far);
    this.cameraType = "perspective";
  }
  orthographic(left, right, top, bottom, near = this.near, far = this.far, zoom = 1) {
    this.#bounds = {
      left,
      right,
      top,
      bottom
    };
    this.near = near;
    this.far = far;
    this.projectionMatrix.orthographic(
      left / zoom,
      right / zoom,
      top / zoom,
      bottom / zoom,
      near,
      far
    );
    this.cameraType = "orthographic";
    this.projectionMatrix.frustum(this.frustum, this.#bounds.left, this.#bounds.right, this.#bounds.top, this.#bounds.bottom, this.#near, this.#far);
  }
  lookAt(t) {
    super.lookAt(t, true);
    return this;
  }
  updateMatrixWorld() {
    super.updateMatrixWorld();
    this.viewMatrix.invert(this.worldMatrix);
    this.worldMatrix.getTranslation(this.worldPosition);
    this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);
    return this;
  }
  frustumIntersectsMesh(node, worldMatrix = node.worldMatrix) {
    if (!node.geometry.attributes.position)
      return true;
    if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity)
      node.geometry.computeBoundingSphere();
    if (!node.geometry.bounds)
      return true;
    const center = tempVec3a;
    center.copy(node.geometry.bounds.center);
    center.applyMatrix4(worldMatrix);
    const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();
    return this.frustumIntersectsSphere(center, radius);
  }
  frustumIntersectsSphere(center, radius) {
    const normal = tempVec3b;
    for (let i = 0; i < 6; i++) {
      const plane = this.frustum[i];
      const distance = normal.copy(plane).dot(center) + plane.constant;
      if (distance < -radius)
        return false;
    }
    return true;
  }
  project(v) {
    v.applyMatrix4(this.viewMatrix);
    v.applyMatrix4(this.projectionMatrix);
    return this;
  }
  unproject(v) {
    v.applyMatrix4(tempMat4.invert(this.projectionMatrix));
    v.applyMatrix4(this.worldMatrix);
    return this;
  }
  updateProjectionMatrix() {
    throw new Error(ERR_CAMERA_METHOD_UNDEFINED);
  }
}

class PerspectiveCamera extends Camera {
  constructor(fov, aspect, near, far) {
    super({
      fov,
      aspect,
      near,
      far
    });
  }
  updateProjectionMatrix() {
    this.projectionMatrix.fromPerspective(this.fov, this.aspect, this.near, this.far);
  }
}

class OrthographicCamera extends Camera {
  constructor(left, right, top, bottom, near, far, zoom = 1) {
    super({
      bounds: {
        left,
        right,
        top,
        bottom
      },
      near,
      far,
      zoom
    });
  }
  updateProjectionMatrix() {
    const {
      left,
      right,
      top,
      bottom
    } = this.bounds;
    const { zoom } = this;
    this.projectionMatrix.orthographic(
      left / zoom,
      right / zoom,
      top / zoom,
      bottom / zoom,
      this.near,
      this.far
    );
  }
}

exports.BlendType = BlendType;
exports.Box = Box;
exports.BufferAttribute = BufferAttribute;
exports.Camera = Camera;
exports.Clock = Clock;
exports.Color = Color;
exports.DataTexture = DataTexture;
exports.Euler = Euler;
exports.EventEmitter = EventEmitter;
exports.Geometry = Geometry;
exports.Matrix3 = Matrix3;
exports.Matrix4 = Matrix4;
exports.Mesh = Mesh;
exports.Object3D = Object3D;
exports.OrthographicCamera = OrthographicCamera;
exports.PerspectiveCamera = PerspectiveCamera;
exports.Plane = Plane;
exports.Program = Program;
exports.ProjectionMatrix = ProjectionMatrix;
exports.Quaternion = Quaternion;
exports.Raf = Raf;
exports.RenderBuffer = RenderBuffer;
exports.RenderTarget = RenderTarget;
exports.Renderer = Renderer;
exports.Resource = Resource;
exports.Scene = Scene;
exports.State = State;
exports.Texture = Texture;
exports.Texture3D = Texture3D;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.Vector4 = Vector4;
exports.getPlaneBuffer = getPlaneBuffer;
exports.highPrecision = highPrecision;
exports.utils = index;
//# sourceMappingURL=index.cjs.js.map
