import * as colord from 'colord';
import { AnyColor } from 'colord';

/**
 * 时钟对象，默认内部会使用 [performance.now](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) 否则会
 * 回退到 `Date.now()`.
 * ```ts
 * const clock = new Clock();
 * ```
 */
declare class Clock {
    #private;
    running: boolean;
    /**
     * Constructor
     * @param running 时钟状态
     */
    constructor(running?: boolean);
    /**
     * 启动时钟
     */
    start(): void;
    /**
     * 停止时钟
     */
    stop(): void;
    /**
     * 重置时钟状态
     */
    reset(): void;
    /**
     * 获取自时钟启动以来经过的秒数
     */
    getElapsedTime(): number;
    /**
     * 计算时钟总启动时间，并将当前时间设置赋值到 `lastTime`
     */
    getDelta(): number;
}

/**
 * Raf 配置项
 */
interface RafOptions {
    /**
     * @defaultValue `true`, 是否在创建 raf 实例后自动启动
     */
    autoStart: boolean;
}
/**
 * 优化的 raf 管理
 * ```ts
 * const raf = new Raf();
 * ```
 */
declare class Raf {
    #private;
    options: Partial<RafOptions>;
    constructor(cb: any, options?: Partial<RafOptions>);
    /**
     * 获取当前页面是否可见
     */
    get visible(): boolean;
    /**
     * 获取当前`raf` 状态
     */
    get animating(): boolean;
    /**
     * 重置当前 `raf` 状态
     */
    reset(): void;
    /**
     * 获取总时长
     */
    get elapsedTime(): number;
    /**
     * 启动 `raf`
     */
    start(): void;
    /**
     * 停止 `raf`
     */
    stop(): void;
    tick(): void;
    /**
     * 处理页面可见和不可见逻辑
     * @private
     */
    private onVisibilityChange;
}

type IOptions = {
    /**
     * 指定事件名称的合法值的正则表达式
     */
    validEventTypes?: RegExp[];
};
declare class Event {
    readonly type: string;
    constructor(type: string, params?: {});
}
/**
 * 事件中心（实现的发布订阅者模式）
 *
 * 简单使用：
 * ```
 * const e = new EventEmitter();
 *
 * const handler = (data) => {
 *   console.log(data);
 * };
 *
 * e.on('eventName', handler);
 *
 * e.emit('eventName', { data: 'data' });
 *
 * // 取消订阅
 * e.off('eventName', handler);
 *
 * // 清除所有的订阅者
 * e.clear();
 * ```
 */
declare class EventEmitter<EventsMap extends Record<string, any> = Event> {
    private fns;
    private readonly validateEventTypes;
    constructor({ validEventTypes }?: IOptions);
    /**
     * 判断事件类型是否合法
     * @param type
     * @private
     */
    private validateEventType;
    /**
     * 添加订阅者
     * @param type 事件类型
     * @param handler 回调函数
     * @param context 上下文
     */
    on(type: any, handler: any, context?: any): this;
    /**
     * 添加一次性订阅者
     * @param type
     * @param handler
     * @param context
     */
    once(type: any, handler: any, context?: any): this;
    /**
     * 取消监听
     * @param type
     * @param handler
     * @param context
     */
    off(type: any, handler?: any, context?: any): this;
    /**
     * 触发事件
     * @param type
     * @param args
     */
    emit(type: any, args?: any): any;
    has(type: any): any;
    /**
     * 清空所有的订阅者
     */
    clear(): this;
}

type ICallback = () => void;
type WithNull<T> = T | null;
type WithUndef<T> = T | undefined;

declare class Vector {
    /**
     * 向量数据
     * @private
     */
    elements: Float32Array | Float64Array;
    /**
     * 从数组构建向量数据
     * @param array 原始数组
     * @param offset 数组偏移量
     */
    fromArray(array: any, offset?: number): this;
    /**
     * 从向量转换到数组
     * @param out 输出数据
     * @param offset 偏移量
     */
    toArray(out?: number[] | Float32Array | Float64Array, offset?: number): Float32Array | Float64Array | number[];
}

declare class Matrix {
    /**
     * 矩阵数据
     * @private
     */
    elements: Float32Array | Float64Array;
    /**
     * 从数组构建矩阵
     * @param array 原始数组
     * @param offset 数组偏移量
     */
    fromArray(array: any, offset?: number): this;
    /**
     * 从矩阵转换到数组
     * @param out 输出数据
     * @param offset 偏移量
     */
    toArray(out?: number[] | Float32Array | Float64Array, offset?: number): Float32Array | Float64Array | number[];
}

/**
 * 一个表示 4*4 的矩阵
 * 1--0--0--0
 * |  |  |  |
 * 0--1--0--0
 * |  |  |  |
 * 0--0--1--0
 * |  |  |  |
 * 0--0--0--1
 * ```ts
 * const m = new Matrix4();
 * ```
 */
declare class Matrix4 extends Matrix {
    elements: Float32Array | Float64Array;
    /**
     * @param m00 第一行第一列，默认是 1
     * @param m01 第一行第二列，默认是 0
     * @param m02 第一行第三列，默认是 0
     * @param m03 第一行第四列，默认是 0
     * @param m10 第二行第一列，默认是 0
     * @param m11 第二行第二列，默认是 1
     * @param m12 第二行第三列，默认是 0
     * @param m13 第二行第四列，默认是 0
     * @param m20 第三行第一列，默认是 0
     * @param m21 第三行第二列，默认是 0
     * @param m22 第三行第三列，默认是 1
     * @param m23 第三行第四列，默认是 0
     * @param m30 第四行第一列，默认是 0
     * @param m31 第四行第二列，默认是 0
     * @param m32 第四行第三列，默认是 0
     * @param m33 第四行第四列，默认是 1
     */
    constructor(m00?: number, m01?: number, m02?: number, m03?: number, m10?: number, m11?: number, m12?: number, m13?: number, m20?: number, m21?: number, m22?: number, m23?: number, m30?: number, m31?: number, m32?: number, m33?: number);
    /**
     * 获取向量 x 值
     * @return number;
     */
    get x(): number;
    /**
     * 获取向量 y 值
     * @return number;
     */
    get y(): number;
    /**
     * 获取向量 z 值
     * @return number;
     */
    get z(): number;
    /**
     * 获取向量 w 值
     * @return number;
     */
    get w(): number;
    /**
     * 获取单位矩阵
     */
    static get identity(): Matrix4;
    /**
     * 将此矩阵的每一项设置为给定的值
     * @param m00
     * @param m01
     * @param m02
     * @param m03
     * @param m10
     * @param m11
     * @param m12
     * @param m13
     * @param m20
     * @param m21
     * @param m22
     * @param m23
     * @param m30
     * @param m31
     * @param m32
     * @param m33
     */
    set(m00: any, m01: any, m02: any, m03: any, m10: any, m11: any, m12: any, m13: any, m20: any, m21: any, m22: any, m23: any, m30: any, m31: any, m32: any, m33: any): this;
    /**
     * 将此矩阵转换为转置矩阵
     * @return {Matrix4} this
     */
    transpose(): this;
    /**
     * 将此矩阵转换为逆矩阵
     * @param m 默认为当前实例
     * @return Matrix4
     */
    invert(m?: this): this;
    /**
     * 计算此矩阵的伴随矩阵
     * @param m 默认为当前实例
     */
    adjoint(m?: this): this;
    /**
     * 计算行列式
     * @return {Number}
     */
    determinant(): any;
    /**
     * 将两个 Matrix4 矩阵相加
     * @param {Matrix4} a
     * @param {Matrix4} [b] 如果不传，计算 this 和 a 的和
     * @return {Matrix4} this
     */
    add(a: Matrix4, b?: Matrix4): this;
    /**
     * 将两个 Matrix4 矩阵相减
     * @param {Matrix4} a
     * @param {Matrix4} [b] 如果不传，计算 this 和 a 的差
     * @return {Matrix4} this
     */
    subtract(a: Matrix4, b?: Matrix4): this;
    /**
     * 计算两个 Matrix4 矩阵的乘积
     * @param  {Matrix4} a
     * @param  {Matrix4} [b] 如果不传，计算 this 和 a 的乘积
     * @return {Matrix4} this
     */
    multiply(a: Matrix4, b?: Matrix4): this;
    /**
     * 计算 Matrix4 与标量的乘积
     * @param a 如果不传，计算 this 和 b 的乘积
     * @param b
     */
    multiplyScalar(a?: Matrix4, b?: number): this;
    /**
     * 左乘
     * @param  {Matrix4} a
     * @param  {Matrix4} b 如果不传，计算 this 和 a 的左乘
     * @return {Matrix4}  this
     */
    premultiply(a: Matrix4, b?: Matrix4): this;
    /**
     * 通过给定的向量 Vector3 平移此矩阵
     * @param  {Vector3} v 向量
     * @return {Matrix4} this
     */
    translate(v: Vector3): this;
    /**
     * 旋转此矩阵
     * @param  {Number} rad 弧度
     * @return {Matrix4} this
     */
    rotate(rad: number): this;
    /**
     * 通过给定的 Vector3 向量缩放此矩阵
     * @param vec3
     */
    scale(vec3: Vector3): this;
    /**
     * 通过标量 s 缩放此矩阵，默认在内部构建一个三维向量 [s, s, s]
     * @param s
     */
    scaleScalar(s: number): this;
    /**
     * 从平移向量创建矩阵
     * @param vec
     */
    fromTranslation(vec: Vector3): this;
    /**
     * 从给定轴和旋转角度创建矩阵
     * @param rad 弧度
     * @param axis 轴
     */
    fromRotation(rad: number, axis: any): this;
    /**
     * 从绕 X 轴的给定角度创建矩阵
     * @param rad
     */
    fromRotationX(rad: number): this;
    /**
     * 从绕 Y 轴的给定角度创建矩阵
     * @param rad
     */
    fromRotationY(rad: number): this;
    /**
     * 从绕 Z 轴的给定角度创建矩阵
     * @param rad
     */
    fromRotationZ(rad: any): this;
    /**
     * 从缩放向量计算矩阵
     * @param vec
     */
    fromScale(vec: Vector3): this;
    /**
     * 从平移向量和四元数计算矩阵
     * @param quat
     * @param v
     */
    fromRotationTranslation(quat: Quaternion, v: Vector3): this;
    /**
     * 创建一个透视投影矩阵
     * @param fov
     * @param aspect
     * @param near
     * @param far
     */
    fromPerspective(fov: any, aspect: any, near: any, far: any): this;
    /**
     * 创建一个正交投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    fromOrthogonal(left: any, right: any, bottom: any, top: any, near: any, far: any): this;
    /**
     * 从给定的四元数计算矩阵
     * @param q
     */
    fromQuat(q: Quaternion): this;
    /**
     * 判断两个矩阵是否近似相等
     * @param mat4
     */
    equals(mat4: any): any;
    /**
     * 获取旋转向量
     * @param q
     */
    getRotation(q?: Quaternion): Quaternion;
    /**
     * 获取缩放向量
     * @param v
     */
    getScale(v?: Vector3): Vector3;
    /**
     * 获取平移向量
     * @param v
     */
    getTranslation(v?: Vector3): Vector3;
    /**
     * 围绕 X 轴按给定弧度旋转矩阵
     * @param rad
     */
    rotateX(rad: any): this;
    /**
     * 围绕 Y 轴按给定弧度旋转矩阵
     * @param rad
     */
    rotateY(rad: any): this;
    /**
     * 围绕 Z 轴按给定弧度旋转矩阵
     * @param rad
     */
    rotateZ(rad: any): this;
    /**
     * 从四元数旋转、平移和缩放创建矩阵
     * @param v
     * @param q
     * @param s
     */
    compose(v: Vector3, q: Quaternion, s: Vector3): this;
    /**
     * 从矩阵转换到四元数、平移和缩放向量
     */
    decompose(): {
        rotation: Quaternion;
        scale: Vector3;
        translation: Vector3;
    };
    /**
     * 将传入的 Matrix4 复制到此矩阵
     * @param  {Matrix4} m 源矩阵
     * @return {Matrix4} this
     */
    copy(m: Matrix4): this;
    /**
     * 从此矩阵创建一个新的 4*4 矩阵
     * @return {Matrix4} a new Matrix4
     */
    clone(): Matrix4;
    /**
     * 转换为字符串
     */
    toString(): string;
}

/**
 * 二维向量
 *
 * 代码示例:
 * ```ts
 * const a = new Vector2(0, 1);
 *
 * const b = new Vector2();
 *
 * const d = a.distanceTo(b);
 * ```
 */
declare class Vector2 extends Vector {
    elements: Float32Array | Float64Array;
    /**
     * @param x 向量的x值，默认为0
     * @param y 向量的y值，默认为0
     */
    constructor(x?: number, y?: number);
    /**
     * 获取向量 x 值
     * @return number;
     */
    get x(): number;
    /**
     * 设置向量 x 值
     * @param x
     */
    set x(x: number);
    /**
     * 获取向量 y 值
     * @return number;
     */
    get y(): number;
    /**
     * 设置向量 y 值
     * @param y
     */
    set y(y: number);
    /**
     * 从对象赋值 Vector2 的 x、y 值
     * @param object
     */
    fromObject(object: any): this;
    /**
     * 转换到对象
     */
    toObject(): {
        x: number;
        y: number;
    };
    /**
     * 设置向量的 x 和 y 值
     * @param x
     * @param y
     */
    set(x: any, y: any): this;
    /**
     * 将向量的每个值设置为标量 s
     * @param s
     */
    setScalar(s: any): this;
    /**
     * 将传入的向量vec和这个向量相加
     * @param vec 传入的 Vector2
     */
    add(vec: Vector2): this;
    /**
     * 将传入的标量 v 和这个向量相加，默认构建一个二维向量 [v, v]
     * @param v 标量值
     */
    addScalar(v: number): this;
    /**
     * 从此向量减去 vec 二维向量
     * @param vec 传入的 Vector2
     */
    subtract(vec: Vector2): this;
    /**
     * 从此向量各分量减去标量 v，默认构建一个二维向量 [v, v]
     * @param v 标量值
     */
    subtractScalar(v: number): this;
    /**
     * 将此向量与 vec 向量相乘
     * @param vec
     */
    multiply(vec: Vector2): this;
    /**
     * 从此向量各分量与标量 v 相乘，默认构建一个二维向量 [v, v]
     * @param v 标量值
     */
    multiplyScalar(v: number): this;
    /**
     * 将此向量与 vec 向量相除
     * @param vec
     */
    divide(vec: Vector2): this;
    /**
     * 从此向量各分量与标量 v 相除，默认构建一个二维向量 [v, v]
     * @param v 标量值
     */
    divideScalar(v: number): this;
    /**
     * 缩放此向量
     * @param s
     */
    scale(s: number): this;
    /**
     * 计算该向量到所传入的 v 间的距离
     * @param vec
     */
    distanceTo(vec: Vector2): any;
    /**
     * 计算从 `[0, 0]` 到此向量的直线距离
     */
    length(): any;
    /**
     * 计算该向量到传入的v的平方距离
     * @param v
     */
    distanceToSquared(v: Vector2): any;
    /**
     * 计算此向量相对于正 x 轴的弧度角
     */
    angle(): any;
    /**
     * 以弧度返回该向量与向量 v 之间的角度
     */
    angleTo(v: Vector2): any;
    /**
     * 计算此向量与 vec 向量的点积
     * @param vec
     */
    dot(vec: Vector2): any;
    /**
     * 判断传入的向量 vec 与此向量是否相等
     * @param vec
     */
    equals(vec: Vector2): any;
    /**
     * 将该向量设置为它本身与传入的vec的叉积
     * @param vec
     */
    cross(vec: Vector2): this;
    /**
     * 针对此向量取反
     */
    negate(): this;
    /**
     * 针对此向量取倒数
     */
    inverse(): this;
    /**
     * 从此向量到 vec 向量进行插值
     * @param vec 目标向量
     * @param t 插值因数，范围一般在[0-1]，通常在这两个值之间
     */
    lerp(vec: Vector2, t: number): this;
    /**
     * 将此向量转换为单位向量 (将其设置为与此向量具有相同方向但长度为 1 的向量)
     */
    normalize(): this;
    /**
     * 将此向量（隐含的 1 作为第三个分量）乘以 Matrix3
     * @param matrix
     */
    applyMatrix3(matrix: Matrix3): this;
    /**
     * 将此向量乘以 Matrix4
     * @param matrix
     */
    applyMatrix4(matrix: Matrix4): this;
    /**
     * 将传递的 vec2 的 x 和 y 属性的值复制到此 Vector2
     * @param vec2
     */
    copy(vec2: Vector2): this;
    /**
     * 克隆此向量
     */
    clone(): Vector2;
    /**
     * 转换为字符串
     */
    toString(): string;
}

/**
 * 一个表示 3*3 的矩阵
 * 1--0--0
 * |  |  |
 * 0--1--0
 * |  |  |
 * 0--0--1
 * ```ts
 * const m = new Matrix3();
 * ```
 */
declare class Matrix3 extends Matrix {
    elements: Float32Array | Float64Array;
    /**
     * @param m00 第一行第一列，默认是 1
     * @param m01 第一行第二列，默认是 0
     * @param m02 第一行第三列，默认是 0
     * @param m10 第二行第一列，默认是 0
     * @param m11 第二行第二列，默认是 1
     * @param m12 第二行第三列，默认是 0
     * @param m20 第三行第一列，默认是 0
     * @param m21 第三行第二列，默认是 0
     * @param m22 第三行第三列，默认是 1
     */
    constructor(m00?: number, m01?: number, m02?: number, m10?: number, m11?: number, m12?: number, m20?: number, m21?: number, m22?: number);
    /**
     * 获取向量 x 值
     * @return number;
     */
    get x(): number;
    /**
     * 获取向量 y 值
     * @return number;
     */
    get y(): number;
    /**
     * 获取向量 z 值
     * @return number;
     */
    get z(): number;
    /**
     * 获取单位矩阵
     */
    static get identity(): Matrix3;
    /**
     * 将此矩阵的每一项设置为给定的值
     * @param {Number} m00
     * @param {Number} m01
     * @param {Number} m02
     * @param {Number} m10
     * @param {Number} m11
     * @param {Number} m12
     * @param {Number} m20
     * @param {Number} m21
     * @param {Number} m22
     * @return {Matrix3} this
     */
    set(m00: any, m01: any, m02: any, m10: any, m11: any, m12: any, m20: any, m21: any, m22: any): this;
    /**
     * 将此矩阵转换为转置矩阵
     * @return {Matrix3} this
     */
    transpose(): this;
    /**
     * 将此矩阵转换为逆矩阵
     * @param  {Matrix3} [m = this]
     * @return {Matrix3} this
     */
    invert(m?: this): this;
    /**
     * 计算此矩阵的伴随矩阵
     * @param  {Matrix3} [m=this]
     * @return {Matrix3} this
     */
    adjoint(m?: this): this;
    /**
     * 计算行列式
     * @return {Number}
     */
    determinant(): any;
    /**
     * 计算两个Matrix3矩阵的乘积
     * @param  {Matrix3} a
     * @param  {Matrix3} [b] 如果不传，计算 this 和 a 的乘积
     * @return {Matrix3} this
     */
    multiply(a: Matrix3, b?: Matrix3): this;
    /**
     * 左乘
     * @param  {Matrix3} a
     * @param  {Matrix3} b 如果不传，计算 this 和 a 的左乘
     * @return {Matrix3}  this
     */
    premultiply(a: Matrix3, b?: Matrix3): this;
    /**
     * 通过给定的向量 Vector2 平移此矩阵
     * @param  {Vector2} v 向量
     * @return {Matrix3} this
     */
    translate(v: Vector2): this;
    /**
     * 旋转此矩阵
     * @param  {Number} rad 弧度
     * @return {Matrix3} this
     */
    rotate(rad: number): this;
    /**
     * 通过给定的 Vector2 向量缩放此矩阵
     * @param  {Vector2} v 向量
     * @return {Matrix3} this
     */
    scale(v: Vector2): this;
    /**
     * 计算单位矩阵平移后的矩阵
     * @param  {Vector2} v 平移的向量
     * @return {Matrix3} this
     */
    fromTranslation(v: Vector2): this;
    /**
     * 计算单位矩阵旋转后的矩阵
     * @param  {Number} rad 旋转弧度
     * @return {Matrix3} this
     */
    fromRotation(rad: number): this;
    /**
     * 计算单位矩阵缩放后的矩阵
     * @param  {Vector2} v Scaling vector
     * @return {Matrix3} this
     */
    fromScaling(v: any): this;
    /**
     * 根据给定的四元数计算矩阵
     * @param  {Quaternion} q Quaternion to create matrix from
     * @return {Matrix3} this
     */
    fromQuat(q: Quaternion): this;
    /**
     * 从 4x4 矩阵计算 3x3 正态矩阵（转置逆矩阵）
     * @param  {Matrix4} m 给定的 Matrix4 矩阵
     * @return {Matrix3} this
     */
    normalFromMat4(m: any): this;
    /**
     * 将 Matrix4 左上角的 3x3 值复制到给定的 Matrix3 中。
     * @param  {Matrix4} m 源矩阵
     * @return {Matrix3} this
     */
    fromMat4(m: any): this;
    /**
     * 计算此矩阵的 Frobenius 范数
     * @return {Number} Frobenius 范数
     */
    frob(): any;
    /**
     * 将两个 Matrix3 矩阵相加
     * @param {Matrix3} a
     * @param {Matrix3} [b] 如果不传，计算 this 和 a 的和
     * @return {Matrix3} this
     */
    add(a: Matrix3, b?: Matrix3): this;
    /**
     * 将两个 Matrix3 矩阵相减
     * @param {Matrix3} a
     * @param {Matrix3} [b] 如果不传，计算 this 和 a 的差
     * @return {Matrix3} this
     */
    subtract(a: Matrix3, b?: Matrix3): this;
    /**
     * 判断两个矩阵是否近似相等
     * @param {Matrix3} a
     * @param {Matrix3} [b] 如果不传，比较 this 和 a 是否近似相等
     * @return {Boolean}
     */
    equals(a: Matrix3, b?: Matrix3): any;
    /**
     * 从给定的旋转角度，位置（二维向量），缩放计算矩阵
     * @param rotation
     * @param  {Number} x
     * @param  {Number} y
     * @param  {Number} scaleX
     * @param  {Number} scaleY
     * @return {Matrix3}
     */
    fromRotationTranslationScale(rotation: any, x: any, y: any, scaleX: any, scaleY: any): this;
    /**
     * 从 4x4 矩阵计算 3x3 正态矩阵（转置逆矩阵）
     * 这个值传递给着色器，用于计算物体的光照。 它是物体的modelViewMatrix矩阵中，左上角3x3子矩阵的逆的转置矩阵
     * @param m
     */
    getNormalMatrix(m: Matrix4): this;
    /**
     * 将传入的 Matrix3 复制到此矩阵
     * @param  {Matrix3} m 源矩阵
     * @return {Matrix3} this
     */
    copy(m: Matrix3): this;
    /**
     * 从此矩阵创建一个新的 3*3 矩阵
     * @return {Matrix3} a new Matrix3
     */
    clone(): Matrix3;
    /**
     * 转换为字符串
     */
    toString(): string;
}

/**
 * 三维向量，三维向量表示的是一个有顺序的、三个为一组的数字组合，可以用来描述：
 * - 一个位于三维空间中的点。
 * - 一个在三维空间中的方向与长度的定义
 * ```ts
 * const a = new Vector3(0, 1, 0);
 *
 * const b = new Vector3(0, 0, 0);
 *
 * const d = a.distanceTo(b);
 * ```
 */
declare class Vector3 extends Vector {
    elements: Float32Array | Float64Array;
    /**
     * @param x 向量的x值，默认为0
     * @param y 向量的y值，默认为0
     * @param z 向量的z值，默认为0
     */
    constructor(x?: number, y?: number, z?: number);
    /**
     * 获取向量 x 值
     * @return number;
     */
    get x(): number;
    /**
     * 设置向量 x 值
     * @param x
     */
    set x(x: number);
    /**
     * 获取向量 y 值
     * @return number;
     */
    get y(): number;
    /**
     * 设置向量 y 值
     * @param y
     */
    set y(y: number);
    /**
     * 获取向量 z 值
     * @return number;
     */
    get z(): number;
    /**
     * 设置向量 z 值
     * @param z
     */
    set z(z: number);
    /**
     * 从对象赋值 Vector3 的 x、y、z 值
     * @param object
     */
    fromObject(object: any): this;
    /**
     * 转换到对象
     */
    toObject(): {
        x: number;
        y: number;
        z: number;
    };
    /**
     * 设置向量的 x、y、z
     * @param x
     * @param y
     * @param z
     */
    set(x: any, y: any, z: any): this;
    /**
     * 将向量的每个值设置为标量 s
     * @param s
     */
    setScalar(s: any): this;
    /**
     * 计算从 `[0, 0, 0]` 到此向量的直线距离
     */
    length(): any;
    /**
     * 将传入的向量vec和这个向量相加，会改变当前向量
     * @param vec 传入的 Vector3
     */
    add(vec: Vector3): this;
    /**
     * 将传入的标量量 v 和这个向量相加，会改变当前向量
     * @param v 传入的 标量值
     */
    addScalar(v: number): this;
    /**
     * 从此向量减去 vec 三维向量
     * @param vec 传入的 Vector3
     */
    subtract(vec: Vector3): this;
    /**
     * 从此向量各分量减去标量 v，默认构建一个三维向量 [v, v, v]
     * @param v 标量值
     */
    subtractScalar(v: number): this;
    /**
     * 将向量 a 与向量 b 相减后的向量赋值给此向量
     * @param a
     * @param b
     */
    subVectors(a: Vector3, b: Vector3): this;
    /**
     * 将此向量与 vec 向量相乘
     * @param vec
     */
    multiply(vec: Vector3): this;
    /**
     * 从此向量各分量与标量 v 相乘，默认构建一个三维向量 [v, v, v]
     * @param v 标量值
     */
    multiplyScalar(v: number): this;
    /**
     * 将此向量与 vec 向量相除
     * @param vec
     */
    divide(vec: any): this;
    /**
     * 从此向量各分量与标量 v 相除，默认构建一个三维向量 [v, v, v]
     * @param v 标量值
     */
    divideScalar(v: any): this;
    /**
     * 缩放此向量
     * @param s
     */
    scale(s: number): this;
    /**
     * 按标量缩放 v 向量后与此向量相加
     * @param v
     * @param s
     */
    scaleAndAdd(v: Vector3, s: number): this;
    /**
     * 计算该向量到所传入的 vec 间的距离
     * @param vec
     */
    distanceTo(vec: Vector3): any;
    /**
     * 计算两个 vec3 之间的平方距离
     * @param vec
     */
    distanceToSquared(vec: Vector3): any;
    /**
     * 计算此向量相对于正 x 轴的弧度角
     * @param vector
     */
    angle(vector: Vector3): any;
    /**
     * 以弧度返回该向量与向量 v 之间的角度
     */
    angleTo(vector: Vector3): any;
    /**
     * 计算此向量与 vec 向量的点积
     * @param vec
     */
    dot(vec: Vector3): any;
    /**
     * 判断传入的向量 vec 与此向量是否相等
     * @param vec
     */
    equals(vec: Vector3): any;
    /**
     * 将该向量设置为它本身与传入的vec的叉积
     * @param vec
     */
    cross(vec: Vector3): this;
    /**
     * 针对此向量取反
     */
    negate(): this;
    /**
     * 针对此向量取倒数
     */
    inverse(): this;
    /**
     * 从此向量到 vec 向量进行插值
     * @param vec 目标向量
     * @param t 插值因数，范围一般在[0-1]，通常在这两个值之间
     */
    lerp(vec: Vector3, t: number): this;
    /**
     * 将此向量转换为单位向量 (将其设置为与此向量具有相同方向但长度为 1 的向量)
     */
    normalize(): this;
    /**
     * 通过将Euler（欧拉）对象转换为Quaternion（四元数）并应用， 将欧拉变换应用到此向量上
     * @param euler
     */
    applyEuler(euler: any): this;
    /**
     * 将此向量乘以 Matrix3
     * @param matrix
     */
    applyMatrix3(matrix: Matrix3): this;
    /**
     * 将此向量乘以 Matrix4
     * @param matrix
     */
    applyMatrix4(matrix: Matrix4): this;
    /**
     * 将 Quaternion 变换应用到该向量
     * @param quaternion
     */
    applyQuaternion(quaternion: Quaternion): this;
    /**
     * 将传递的 Vector3 的 x 和 y, z 属性的值复制到此 Vector3
     * @param vec3
     */
    copy(vec3: Vector3): this;
    /**
     * 克隆此向量
     */
    clone(): Vector3;
    /**
     * 转换为字符串
     */
    toString(): string;
}

type ANGLE_ORDER = 'zyx' | 'xyz' | 'yxz' | 'yzx' | 'zxy' | 'xzy';
/**
 * 欧拉角描述一个旋转变换，通过指定轴顺序和其各个轴向上的指定旋转角度来旋转一个物体
 *
 * ```ts
 * const a = new Euler(0, 1, 1.57, 'xyz' )
 * ```
 */
declare class Euler extends Vector {
    #private;
    elements: Float32Array | Float64Array;
    /**
     * @param x 用弧度表示x轴旋转量，默认值是 0
     * @param y 用弧度表示y轴旋转量，默认值是 0
     * @param z 用弧度表示z轴旋转量，默认值是 0
     * @param order 表示旋转顺序的字符串，默认为'xyz'
     */
    constructor(x?: number, y?: number, z?: number, order?: ANGLE_ORDER);
    /**
     * 获取 x 值
     * @return number;
     */
    get x(): number;
    /**
     * 设置 x 值
     * @param x
     */
    set x(x: number);
    /**
     * 获取 y 值
     * @return number;
     */
    get y(): number;
    /**
     * 设置 y 值
     * @param y
     */
    set y(y: number);
    /**
     * 获取 z 值
     * @return number;
     */
    get z(): number;
    /**
     * 设置 z 值
     * @param z
     */
    set z(z: number);
    /**
     * 获取旋转顺序
     */
    get order(): ANGLE_ORDER;
    /**
     * 设置旋转顺序
     * @param order
     */
    set order(order: ANGLE_ORDER);
    get roll(): number;
    set roll(roll: number);
    get pitch(): number;
    set pitch(pitch: number);
    get yaw(): number;
    set yaw(yaw: number);
    /**
     * 从对象创建欧拉角
     * @param x
     * @param y
     * @param z
     * @param order
     */
    fromObject({ x, y, z, order }: {
        x: any;
        y: any;
        z: any;
        order: any;
    }): this;
    /**
     * 转换到对象
     */
    toObject(): {
        x: number;
        y: number;
        z: number;
        order: ANGLE_ORDER;
    };
    /**
     * 从 Matrix4 创建欧拉角
     * @param m
     * @param order
     * @param update
     */
    fromRotationMatrix(m: Matrix4, order?: ANGLE_ORDER, update?: boolean): this;
    /**
     * 从四元数创建欧拉角
     * @param q
     */
    fromQuaternion(q: Quaternion): Euler;
    /**
     * 从 Vector3 创建欧拉角
     * @param vec3
     * @param order
     */
    fromVector3(vec3: any, order?: ANGLE_ORDER): this;
    /**
     * 转换到四元数
     */
    toQuaternion(): Quaternion;
    /**
     * 转换到 Vector3
     */
    toVector3(): Vector3;
    /**
     * 设置欧拉角的 x、y、z、order
     * @param x
     * @param y
     * @param z
     * @param order
     */
    set(x: any, y: any, z: any, order?: ANGLE_ORDER): this;
    /**
     * 克隆此欧拉角对象
     */
    clone(): Euler;
    /**
     * 将传入的 euler 的各数值复制到此欧拉角
     * @param euler
     */
    copy(euler: Euler): this;
    /**
     * 判断两个欧拉角是否相同
     * @param e
     */
    equals(e: Euler): boolean;
    /**
     * 监听欧拉角变更
     * @param cb 回调函数
     */
    onChange(cb: ICallback): void;
    /**
     * 触发所有的回调函数
     */
    triggerChange(): void;
    /**
     * 转换为字符串
     */
    toString(): string;
}

/**
 * 四元数，主要用于在三维世界描述旋转
 * ```ts
 * const a = new Quaternion(0, 0, 0, 0);
 * ```
 */
declare class Quaternion extends Vector {
    #private;
    elements: Float32Array | Float64Array;
    /**
     * @param x x 坐标，默认为 0
     * @param y y 坐标，默认为 0
     * @param z z 坐标，默认为 0
     * @param w w 坐标，默认为 0
     */
    constructor(x?: number, y?: number, z?: number, w?: number);
    /**
     * 获取 x 值
     * @return number;
     */
    get x(): number;
    /**
     * 设置 x 值
     * @param x
     */
    set x(x: number);
    /**
     * 获取 y 值
     * @return number;
     */
    get y(): number;
    /**
     * 设置 y 值
     * @param y
     */
    set y(y: number);
    /**
     * 获取 z 值
     * @return number;
     */
    get z(): number;
    /**
     * 设置 z 值
     * @param z
     */
    set z(z: number);
    /**
     * 获取 w 值
     * @return number;
     */
    get w(): number;
    /**
     * 设置 w 值
     * @param w
     */
    set w(w: number);
    /**
     * 从对象赋值 Quaternion 的 x、y、z、w 值
     * @param object
     */
    fromObject({ x, y, z, w }: {
        x: any;
        y: any;
        z: any;
        w: any;
    }): this;
    /**
     * 转换到对象
     */
    toObject(): {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    /**
     * 给定的角度和旋转轴设置此四元数的值
     * @param axis
     * @param rad
     */
    fromAxisAngle(axis: Vector3, rad: number): this;
    /**
     * 从此四元数获取旋转轴和旋转角度
     * @param axis
     */
    getAxisAngle(axis?: Vector3): any;
    /**
     * 从给定的欧拉角 e 创建四元数
     * @param e
     */
    fromEuler(e: Euler): this;
    /**
     * 从给定的 3x3 旋转矩阵创建四元数
     * @param m
     */
    fromMat3(m: Matrix3): this;
    set(x: any, y: any, z: any, w: any): this;
    /**
     * 计算四元数的直线长度
     */
    length(): any;
    /**
     * 计算四元数的乘积
     * @param a
     * @param b
     */
    multiply(a: Quaternion, b?: Quaternion): this;
    /**
     * 处理四元数之间的球面线性插值
     * @param q
     * @param t
     */
    slerp(q: Quaternion, t: number): this;
    /**
     * 翻转该四元数
     */
    invert(): this;
    /**
     * 计算此四元数的旋转共轭（围绕旋转轴在相反方向上的旋转）
     */
    conjugate(): this;
    /**
     * （归一化）四元数。 即计算与该四元数具有相同旋转、但长度为1的四元数
     */
    normalize(): this;
    /**
     * 计算四元数 q 与当前四元数的点积
     * @param q
     */
    dot(q: Quaternion): any;
    /**
     * 以弧度返回该四元数与四元数 q 之间的夹角。
     * @param q
     */
    angleTo(q: Quaternion): any;
    /**
     * 创建一个与该四元数具有相同x、y、z和w 属性的四元数
     */
    clone(): Quaternion;
    /**
     * 复制四元数 q 的 x、y、z 和 w 属性到该四元数中。
     * @param q
     */
    copy(q: Quaternion): this;
    /**
     * 比较两个四元数是否相同
     * @param q
     */
    equals(q: Quaternion): any;
    /**
     * 监听四元数变更
     * @param fn 回调函数
     */
    onChange(fn: ICallback): void;
    /**
     * 触发所有的回调函数
     */
    triggerChange(): void;
    /**
     * 转换为字符串
     */
    toString(): string;
}

/**
 * 四维向量，四维向量表示的是一个有顺序的、四个为一组的数字组合，可以用来描述：
 * - 一个位于四维空间中的点。
 * - 一个在四维空间中的方向与长度的定义。
 * ```ts
 * const a = new Vector4(0, 1, 0);
 *
 * const b = new Vector4(0, 0, 0);
 *
 * const d = a.distanceTo(b);
 * ```
 */
declare class Vector4 extends Vector {
    elements: Float32Array | Float64Array;
    /**
     * @param x 向量的x值，默认为0
     * @param y 向量的y值，默认为0
     * @param z 向量的z值，默认为0
     * @param w 向量的w值，默认为0
     */
    constructor(x?: number, y?: number, z?: number, w?: number);
    /**
     * 获取向量 x 值
     * @return number;
     */
    get x(): number;
    /**
     * 设置向量 x 值
     * @param x
     */
    set x(x: number);
    /**
     * 获取向量 y 值
     * @return number;
     */
    get y(): number;
    /**
     * 设置向量 y 值
     * @param y
     */
    set y(y: number);
    /**
     * 获取向量 z 值
     * @return number;
     */
    get z(): number;
    /**
     * 设置向量 z 值
     * @param z
     */
    set z(z: number);
    /**
     * 获取向量 w 值
     * @return number;
     */
    get w(): number;
    /**
     * 设置向量 w 值
     * @param w
     */
    set w(w: number);
    /**
     * 从对象赋值 Vector3 的 x、y、z、w 值
     * @param object
     */
    fromObject(object: any): this;
    /**
     * 转换到对象
     */
    toObject(): {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    /**
     * 设置向量的 x、y、z、w
     * @param x
     * @param y
     * @param z
     * @param w
     */
    set(x: any, y: any, z: any, w: any): this;
    /**
     * 将向量的每个值设置为标量 s
     * @param s
     */
    setScalar(s: any): this;
    /**
     * 将传入的向量vec和这个向量相加，会改变当前向量
     * @param vec 传入的 Vector4
     */
    add(vec: Vector4): this;
    /**
     * 将传入的标量量 v 和这个向量相加，会改变当前向量
     * @param v 传入的 标量值
     */
    addScalar(v: any): this;
    /**
     * 从此向量减去 vec 四维向量
     * @param vec 传入的 Vector4
     */
    subtract(vec: Vector4): this;
    /**
     * 从此向量各分量减去标量 v，默认构建一个四维向量 [v, v, v, v]
     * @param v 标量值
     */
    subtractScalar(v: any): this;
    /**
     * 将向量 a 与向量 b 相减后的向量赋值给此向量
     * @param a
     * @param b
     */
    subVectors(a: Vector4, b: Vector4): this;
    /**
     * 将此向量与 vec 向量相乘
     * @param vec
     */
    multiply(vec: Vector4): this;
    /**
     * 从此向量各分量与标量 v 相乘，默认构建一个四维向量 [v, v, v, v]
     * @param v 标量值
     */
    multiplyScalar(v: number): this;
    /**
     * 将此向量与 vec 向量相除
     * @param vec
     */
    divide(vec: Vector4): this;
    /**
     * 从此向量各分量与标量 v 相除，默认构建一个四维向量 [v, v, v, v]
     * @param v 标量值
     */
    divideScalar(v: any): this;
    /**
     * 缩放此向量
     * @param s
     */
    scale(s: number): this;
    /**
     * 按标量缩放 v 向量后与此向量相加
     * @param v
     * @param s
     */
    scaleAndAdd(v: Vector4, s: number): this;
    /**
     * 计算该向量到所传入的 v 间的距离
     * @param vec
     */
    distanceTo(vec: Vector4): any;
    /**
     * 计算两个 Vector4 之间的平方距离
     * @param vec
     */
    distanceToSquared(vec: Vector4): any;
    /**
     * 计算从 `[0, 0, 0, 0]` 到此向量的直线距离
     */
    length(): any;
    /**
     * 计算此向量与 vec 向量的点积
     * @param vec
     */
    dot(vec: Vector4): any;
    /**
     * 判断传入的向量 vec 与此向量是否相等
     * @param vec
     */
    equals(vec: Vector4): any;
    /**
     * 将该向量设置为它本身与传入的vec的叉积
     * @param vec
     */
    cross(vec: Vector4): this;
    /**
     * 针对此向量取反
     */
    negate(): this;
    /**
     * 针对此向量取倒数
     */
    inverse(): this;
    /**
     * 从此向量到 vec 向量进行插值
     * @param vec 目标向量
     * @param t 插值因数，范围一般在[0-1]，通常在这两个值之间
     */
    lerp(vec: Vector4, t: number): this;
    /**
     * 将此向量转换为单位向量 (将其设置为与此向量具有相同方向但长度为 1 的向量)
     */
    normalize(): this;
    /**
     * 将此向量乘以 Matrix4
     * @param matrix
     */
    applyMatrix4(matrix: Matrix4): this;
    /**
     * 将 Quaternion 变换应用到该向量
     * @param quaternion
     */
    applyQuaternion(quaternion: Quaternion): this;
    /**
     * 将传递的 Vector4 的 x 、y、 z、w 属性的值复制到此 Vector4
     * @param vec4
     */
    copy(vec4: Vector4): this;
    /**
     * 克隆此向量
     */
    clone(): Vector4;
    /**
     * 转换为字符串
     */
    toString(): string;
}

/**
 * 一个表示颜色的类，可以使用这个类来初始化颜色
 * ```ts
 * // 默认是白色
 * const color1 = new Color();
 *
 * // 16进制颜色
 * const color2 = new Color('#ff0000');
 *
 * // RGB
 * const color3 = new Color('rgb(255, 0, 0)');
 * const color3 = new Color({ r: 255, g: 255, b: 255 });
 * const color3 = new Color({ r: 255, g: 255, b: 255, a: 1 });
 *
 * // css 颜色名称
 * const color5 = new Color('skyblue');
 *
 * // HSL
 * const color6 = new Color('hsl(0, 100%, 50%)');
 *
 * // HSV
 * const color6 = new Color({ h: 360, s: 100, v: 100, a: 1 });
 *
 * // 设置 rgba 值, 支持归一化和非归一化的值
 * const color7 = new Color(1, 0, 0);
 * const color7 = new Color(1, 0, 0, 1, true);
 * ```
 */
declare class Color {
    r: number;
    g: number;
    b: number;
    a: number;
    /**
     * @param v 可以是 rgba 的 r 通道值，也可以是 AnyColor
     * @param g g 通道
     * @param b b 通道
     * @param a alpha 通道
     * @param isNormalized 是否是归一化的数值
     */
    constructor(v?: number | AnyColor, g?: number, b?: number, a?: number, isNormalized?: boolean);
    /**
     * 解析颜色，凡是可以被 [colord](https://github.com/omgovich/colord) 解析的都可以使用
     * @param c
     */
    fromColor(c: AnyColor): this;
    /**
     * 解析 hsl 颜色
     * @param h
     * @param s
     * @param l
     * @param a
     */
    fromHSL(h: any, s: any, l: any, a?: number): this;
    /**
     * 解析 hsv 颜色
     * @param h
     * @param s
     * @param v
     * @param a
     */
    fromHSV(h: any, s: any, v: any, a?: number): this;
    /**
     * 设置 rgb 数值
     * @param r r 值，一般为 0-255
     * @param g g 值，一般为 0-255
     * @param b b 值，一般为 0-255
     */
    setRGB(r: number, g: number, b: number): this;
    /**
     * 设置各通道的值
     * @param r red 通道
     * @param g green 通道
     * @param b blue 通道
     * @param a alpha 通道
     * @param isNormalized 是否已经归一化（一般从颜色字符串解析的都是未归一化的）
     */
    setRGBA(r: any, g: any, b: any, a: any, isNormalized?: boolean): this;
    /**
     * 设置 alpha 通道
     * @param alpha
     */
    setAlpha(alpha: any): this;
    /**
     * 输出 16 进制字符串
     */
    toHex(): string;
    /**
     * 输出 hsl 对象
     */
    toHSL(): colord.HslaColor;
    /**
     * 输出 hsv 对象
     */
    toHSV(): colord.HsvaColor;
    /**
     * 将颜色转换为对象
     * @param isNormalized 是否进行归一化，默认采用 0-255
     */
    toObject(isNormalized?: boolean): {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    /**
     * 转换为数组（一般已经归一化。可以直接传递给 gl）
     */
    toArray(): number[];
    /**
     * 转换为 Vector4
     */
    toVector(): Vector4;
    /**
     * 转换为 Vector3
     */
    toVector3(): Vector3;
    /**
     * 转换为字符串
     */
    toString(): string;
}
type ColorLike = Color | {
    r: number;
    g: number;
    b: number;
    a?: number;
};

/**
 * 这是一个基类，主要用于暴露 `renderer` 和 `gl` 以及 `rendererState`
 */
declare class Base {
    renderer: Renderer;
    constructor(renderer: Renderer);
    /**
     * 获取 `webgl` 实例
     */
    get gl(): WebGLRenderingContext | WebGL2RenderingContext;
    /**
     * 获取渲染状态
     */
    get rendererState(): State;
}

declare enum BlendType {
    NoBlending = 0,
    NormalBlending = 1,
    AdditiveBlending = 2,
    SubtractiveBlending = 3,
    MultiplyBlending = 4,
    CustomBlending = 5
}
type IBlendType = BlendType;
type FBOData = {
    target?: GLenum;
    buffer: WithNull<WebGLFramebuffer>;
};
interface StateOptions {
    textureUnits: (number | string)[];
    activeTextureUnit: number;
    activeGeometryId: string | number;
    currentProgramId: string | number;
    boundBuffer: WebGLBuffer | null;
    colorMask: boolean;
    blending: IBlendType;
    premultiplyAlpha: boolean;
    blendFunc: {
        src: number;
        dst: number;
        srcAlpha?: number;
        dstAlpha?: number;
    };
    blendEquation: {
        modeRGB: number;
        modeAlpha?: number;
    };
    stencil: {
        mask: GLenum;
        func: {
            cmp: GLenum;
            ref: GLenum;
            mask: GLenum;
        };
        opFront: {
            fail: GLenum;
            zFail: GLenum;
            zPass: GLenum;
        };
        opBack: {
            fail: GLenum;
            zFail: GLenum;
            zPass: GLenum;
        };
    };
    clearAlpha: number;
    clearColor: ColorLike;
    cullFace: GLenum;
    frontFace: GLenum;
    depthMask: boolean;
    depthFunc: GLenum;
    depthTest: boolean;
    depthWrite: boolean;
    unpackAlignment: number;
    flipY: boolean;
    anisotropy: number;
    lineWidth: number;
    polygonOffset: boolean;
    polygonOffsetFactor: GLenum;
    polygonOffsetUnits: GLenum;
    framebuffer: WithNull<WebGLFramebuffer>;
    viewport: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
}
interface IState extends StateOptions {
    framebuffer: WithNull<WebGLFramebuffer>;
}
/**
 * 渲染状态管理，目的是减少CPU与GPU的交互，一般我们不需要主动创建，它默认包含在 `Renderer` 实例中。
 */
declare class State extends Base {
    #private;
    constructor(renderer: Renderer, options?: Partial<StateOptions>);
    /**
     * 获取所有状态
     */
    get state(): IState;
    /**
     * 获取视图
     */
    get viewport(): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    /**
     * 获取当前 `gl` 的纹理单位
     */
    get textureUnits(): (string | number)[];
    /**
     * 获取已激活的纹理
     */
    get activeTextureUnit(): number;
    /**
     * 设置当前激活的纹理
     * @param activeTextureUnit
     */
    set activeTextureUnit(activeTextureUnit: number);
    /**
     * 获取当前的 `Program` id
     */
    get currentProgramId(): string | number;
    /**
     * 设置当前的 `Program` id
     * @param id
     */
    set currentProgramId(id: string | number);
    /**
     * 获取当前激活的几何体 id
     */
    get activeGeometryId(): string | number;
    /**
     * 设置当前激活的几何体 id
     * @param id
     */
    set activeGeometryId(id: string | number);
    /**
     * 设置 `flipY`
     * @param flipY
     */
    set flipY(flipY: boolean);
    /**
     * 获取 `flipY` 配置
     */
    get flipY(): boolean;
    /**
     * 设置 `unpackAlignment`
     * @param unpackAlignment
     */
    set unpackAlignment(unpackAlignment: number);
    /**
     * 获取 `unpackAlignment` 配置
     */
    get unpackAlignment(): number;
    /**
     * 设置 `premultipliedAlpha`
     * @param premultiplyAlpha
     */
    set premultiplyAlpha(premultiplyAlpha: boolean);
    /**
     * 获取 `premultipliedAlpha` 配置
     */
    get premultiplyAlpha(): boolean;
    /**
     * 设置最后一次绑定的顶点数据
     * @param boundBuffer
     */
    set boundBuffer(boundBuffer: WebGLBuffer | null);
    /**
     * 获取最后一次绑定的顶点数据
     */
    get boundBuffer(): WebGLBuffer | null;
    /**
     * 配置 `anisotropy`
     * @param anisotropy
     */
    set anisotropy(anisotropy: number);
    /**
     * 获取 `anisotropy` 配置
     */
    get anisotropy(): number;
    /**
     * apply options 并且更新状态
     * @param options
     */
    apply(options: Partial<StateOptions>): void;
    /**
     * 开启诸如 `DEPTH_TEST`、`BLEND` 等功能
     * @param id
     */
    enable(id: any): void;
    /**
     * 关闭诸如 `DEPTH_TEST`、`BLEND` 等功能
     * @param id
     */
    disable(id: any): void;
    /**
     * 设置 Viewport
     * @param width
     * @param height
     * @param x
     * @param y
     */
    setViewport(width: any, height: any, x?: number, y?: number): void;
    /**
     * 设置颜色缓冲的状态
     * 模板缓冲可以实现渲染剔除，需要遮罩的话，可能希望只绘制模板缓冲而不绘制颜色缓冲
     * gl.colorMask(false, false, false, false)：关闭颜色缓冲的所有通道
     * gl.colorMask(true, true, true, true)：开启颜色缓冲的所有通道
     * @param colorMask
     */
    setMask(colorMask: boolean): void;
    /**
     * 指定渲染时的颜色混合方式
     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc
     * @param blending
     * @param options
     */
    setBlending(blending: IBlendType, options?: Partial<StateOptions>): void;
    /**
     * 设置混合方式
     * @param src
     * @param dst
     * @param srcAlpha
     * @param dstAlpha
     */
    setBlendFunc(src: number, dst: number, srcAlpha?: number, dstAlpha?: number): void;
    /**
     * 设置 blendEquation
     * gl.FUNC_ADD：相加处理
     * gl.FUNC_SUBTRACT：相减处理
     * gl.FUNC_REVERSE_SUBSTRACT：反向相减处理，即 dest 减去 source
     *
     * @param modeRGB
     * @param modeAlpha
     */
    setBlendEquation(modeRGB: number, modeAlpha?: number): void;
    /**
     * 设置当前 State 下的清屏的透明度
     * @param alpha
     */
    setClearAlpha(alpha: number): void;
    /**
     * 设置清屏颜色和透明度值
     * @param color 颜色
     * @param alpha 透明度
     */
    setClearColor(color: ColorLike, alpha?: number): void;
    /**
     * 设置背面剔除方式
     * @param cullFace
     */
    setCullFace(cullFace: GLenum): void;
    /**
     * 设置正面三角形顶点顺序
     * 绘制立体图形时会使用三角形的顶点顺序来决定三角形的面是否朝向观察者，背向观察者的三角形一般不进行光栅化处理，绘制时会被剔除
     * @param frontFace
     */
    setFrontFace(frontFace: GLenum): void;
    /**
     * 设置深度缓冲区的写入操作方式（只读或者可写）
     * @param mask
     */
    setDepthMask(mask: boolean): void;
    /**
     * 指定将输入像素深度与当前深度缓冲区值进行比较的函数
     * @param func
     */
    setDepthFunc(func: GLenum): void;
    /**
     * 设置是否开启深度测试
     * @param state
     */
    setDepthTest(state: boolean): void;
    /**
     * 设置模板缓冲测试方式
     * @param cmp 指定比较方式
     * @param ref 用来做stencil测试的参考值
     * @param mask 指定操作掩码，在测试的时候会先将ref与mask进行与运算
     * @param face
     */
    setStencilFunc(cmp: GLenum, ref: GLenum, mask: GLenum, face?: GLenum): void;
    /**
     * 设置模板测试的操作
     * @param fail 指定模板测试失败时要使用的操作。默认值为 `gl.KEEP`
     * @param zFail 指定模板测试通过但深度测试失败时要使用的操作。默认值为 `gl.KEEP`
     * @param zPass 指定当模板测试和深度测试都通过时使用的操作，或者当模板测试通过但没有深度缓冲区或深度测试被禁用时使用的操作。默认值为 `gl.KEEP`
     * @param face
     */
    setStencilOp(fail: any, zFail: any, zPass: any, face?: GLenum): boolean | undefined;
    /**
     * 设置模版测试的操作掩码
     * @param mask
     * @param face
     */
    setStencilMask(mask: any, face?: GLenum): void;
    /**
     * 设置当前激活的纹理单位
     * @param unit
     */
    setActiveTexture(unit: any): void;
    /**
     * 设置 webgl 的线宽（注意大部分浏览器下是有 BUG 的）
     * @param width
     */
    setLineWidth(width: any): void;
    /**
     * 设置深度值的偏移量，主要可以用于解决当几何图形或物体的两个表面非常接近时会出现的深度冲突(Z fighting)。
     * 原因是因为两个表面过于接近，深度缓冲区有限的精度无法区分哪个在前哪个在后。
     *
     * gl.polygonOffset(factor, units)方法指定加到每个顶点绘制后Z值上的偏移量，
     * 偏移量按照公式 `m*factor+r*units` 计算，其中m表示顶点所在表面相对于观察者的视线的角度，
     * 而r表示硬件能够区分两个Z值之差的最小值
     * @param polygonOffset
     * @param factor
     * @param units
     */
    setPolygonOffset(polygonOffset: any, factor: any, units: any): void;
    /**
     * 绑定或者解绑 FBO
     * @param v
     */
    bindFramebuffer(v?: FBOData): void;
    /**
     * 设置当前激活的 Geometry
     * @param id
     */
    setActiveGeometry(id: any): void;
    /**
     * 重置 `State`
     * @param force
     */
    reset(force?: boolean): void;
}

interface ResourceOptions {
    id: string;
    name: string;
    handle: any;
    userData: any;
}
declare class Resource<T extends ResourceOptions> extends Base {
    #private;
    id: string;
    name: WithUndef<string>;
    userData: any;
    byteLength: number;
    options: Partial<T>;
    constructor(renderer: Renderer, options?: Partial<T>);
    get handle(): any;
    /**
     * 交换为新的 `handle`（一般我们会用在虚拟 webgl 环境中）
     * @param handle
     */
    swapHandle(handle: any): void;
    /**
     * 恢复为原有 `handle`
     */
    restoreHandle(): void;
    /**
     * 销毁相关资源
     */
    destroy(): void;
    delete({ deleteChildren }?: {
        deleteChildren?: boolean | undefined;
    }): this;
    bind(funcOrHandle?: any): void;
    unbind(): void;
    removeStats(): void;
    createHandle(): void;
    deleteHandle(): void;
    toString(): string;
}

interface TextureOptions extends ResourceOptions {
    /**
     * 默认为 `gl.TEXTURE_2D`
     */
    target: GLenum;
    /**
     * 纹理宽度，默认为 0
     */
    width: number;
    /**
     * 纹理高度，默认为 0
     */
    height: number;
    /**
     * 纹理放大时使用的过滤类型。
     * 可能的值：`gl.NEAREST`，`gl.LINEAR`
     */
    magFilter: number;
    /**
     * 纹理缩小时使用的过滤类型。
     * 可能的值：`gl.NEAREST`，`gl.LINEAR`
     */
    minFilter: number;
    /**
     * 水平采样纹理时使用的行为。
     * 可能的值：`gl.REPEAT`，`gl.MIRRORED_REPEAT`，`gl.CLAMP_TO_EDGE`
     */
    wrapS: number;
    /**
     * 垂直采样纹理时使用的行为。
     * 可能的值：`gl.REPEAT`，`gl.MIRRORED_REPEAT`，`gl.CLAMP_TO_EDGE`
     */
    wrapT: number;
    /**
     * 纹理数据的格式，在 WebGL 1 中，它必须与 internalformat 相同。
     * 可能的值：`gl.RGBA`，`gl.RGB`，`gl.LUMINANCE`，`gl.LUMINANCE_ALPHA`
     */
    format: number;
    /**
     * 用于指定纹理图像的内部格式
     * 可能的值：`gl.RGBA`，`gl.RGB`，`gl.ALPHA` 等等
     */
    internalFormat: number;
    /**
     * 指定纹理数据的数据类型。
     * 可能的值：`gl.UNSIGNED_BYTE`，`gl.FLOAT`，`gl.UNSIGNED_SHORT`，`gl.UNSIGNED_INT` 等等
     */
    type: number;
    /**
     * 配置是否启用 `mipmap`，默认为`true`
     * `generateMipmaps`会自动生成若干小尺寸的纹理，根据当前三维物体在屏幕上的大小来自动选择最合适的尺寸。
     * 在 `webgl2` 使用`mipmap` 不再强制要求纹理的长度和宽度必须是2的整数次幂。
     */
    generateMipmaps: boolean;
    /**
     * 设置纹理上传时是否翻转 Y 轴，默认为 `false`
     */
    flipY: boolean;
    /**
     *  沿通过具有最高纹理像素密度的像素的坐标轴取样的数量。默认情况下，此值为 `1`。
     *  较高的值会产生比基本mipmap更少的模糊结果，但需要使用更多纹理样本。通常我们在实现让物体缩小时
     *  获取更高的清晰度，可以将此值设大，注意需要 `gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT)`
     *  获取允许的最大值。（see: https://developer.mozilla.org/en-US/docs/Web/API/EXT_texture_filter_anisotropic）
     */
    anisotropy: number;
    /**
     * 指定内存中每个像素行起点的对齐要求。
     * 可能的值: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
     */
    unpackAlignment: number;
    /**
     * 设置纹理上传时是否预乘 `alpha` 值，默认为 `false`
     */
    premultiplyAlpha: boolean;
    /**
     * 指定mipmap的精细度，级别 0 是基础图像级别，级别 n 是第 n 个 mipmap 缩减级别。默认为 `0`。
     */
    level: number;
    /**
     * [GLintptr](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Types) 类型偏移到 [WebGLBuffer](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLBuffer) 的数据存储中。用于上传数据到当前范围 [WebGLTexture](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLTexture) 从WebGLBuffer 范围到PIXEL_UNPACK_BUFFER 目标
     */
    offset?: number;
    /**
     * 纹理数据
     */
    image: any;
}
/**
 * 纹理
 * 一般在 `webgl` 中会将纹理用于贴图，或者作为 `renderTarget`
 *
 * 代码示例：
 * ```ts
 * const texture = new ve.Texture(renderer, {
 *   generateMipmaps: true,
 *   flipY: true,
 * });
 *
 * const image = new Image();
 *
 * image.onload = () => {
 *   texture.setData(image, image.width, image.height);
 * };
 *
 * image.src = './assets/posx.jpg';
 * ```
 */
declare class Texture<T extends TextureOptions = TextureOptions> extends Resource<T> {
    #private;
    /**
     * 设置纹理是否需要更新，一般我们会在纹理数据或者配置变更时将此配置项设置为 `true`
     * 这样会在下一次渲染时应用对应的纹理数据和配置。
     */
    needsUpdate: boolean;
    /**
     * 设置纹理单位
     */
    textureUnit: number;
    /**
     * 纹理数据
     */
    image: any;
    /**
     * 纹理宽度
     */
    width: number;
    /**
     * 纹理高度
     */
    height: number;
    /**
     * `texImage2D` target
     */
    target: GLenum;
    /**
     * @param renderer Renderer 对象
     * @param options 配置项
     * @param needsUpdate 是否需要`update`
     */
    constructor(renderer: Renderer, options?: Partial<T>, needsUpdate?: boolean);
    /**
     * 设置纹理数据
     * @param image 纹理数据
     * @param width 纹理宽度，默认为原始宽度
     * @param height 纹理高度，默认为原始高度
     */
    setData(image: any, width?: number, height?: number): void;
    /**
     * 设置纹理配置（默认进行合并）
     * @param options 配置项
     */
    setOptions(options: Partial<T>): void;
    /**
     * 从 Url 设置纹理对象的数据，会默认标记为需要更新 `needsUpdate = true`
     * @param url
     */
    fromSrc(url: string): Promise<unknown>;
    /**
     * 更新纹理数据或者纹理相关配置
     * @param units 纹理单位，默认为 0
     */
    update(units?: number): void;
    /**
     * 绑定纹理
     * @param unit 纹理单位，默认为 `this.textureUnit`
     */
    bind(unit?: number): void;
    /**
     * 解绑纹理
     */
    unbind(): void;
    /**
     * 销毁纹理
     */
    destroy(): void;
    /**
     * 移除相关状态
     */
    removeStats(): void;
    /**
     * @private
     * 创建纹理对象
     */
    createHandle(): WebGLTexture | null;
    /**
     * @private
     */
    deleteHandle(): void;
    /**
     * 获取字符串数据
     */
    toString(): string;
}

interface DataTextureOptions extends TextureOptions {
    data: any;
}
/**
 * 数据纹理对象，常用于结构化数据的纹理对象。
 *
 * 代码实例：
 *
 * ```ts
 * const texture = new DataTexture(renderer, opt);
 * ```
 */
declare class DataTexture extends Texture<DataTextureOptions> {
    /**
     * 设置纹理是否需要更新，一般我们会在纹理数据或者配置变更时将此配置项设置为 `true`
     * 这样会在下一次渲染时应用对应的纹理数据和配置。
     */
    needsUpdate: boolean;
    constructor(renderer: any, options?: Partial<DataTextureOptions>);
}

interface RenderBufferOptions extends ResourceOptions {
    /**
     * 缓冲区宽度
     */
    width: number;
    /**
     * 缓冲区高度
     */
    height: number;
    /**
     * 指定渲染缓冲区的内部格式。更多文档请参考：[renderbufferStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/renderbufferStorage)
     */
    format: GLenum;
}
/**
 * 渲染缓冲区对象。
 * 由于渲染缓冲区对象是只写的，因此它们通常用作深度和模板关联对象。
 *
 * 实例代码：
 * ```ts
 * const renderBuffer = new RenderBuffer(renderer, {
 *   format: renderer.gl.DEPTH_COMPONENT16,
 *   width: 1920,
 *   height: 1080,
 * });
 *
 * renderBuffer.bind();
 * renderBuffer.unbind();
 * ```
 */
declare class RenderBuffer extends Resource<RenderBufferOptions> {
    #private;
    /**
     * 渲染缓冲区宽度
     */
    width: number;
    /**
     * 渲染缓冲区高度
     */
    height: number;
    constructor(renderer: Renderer, options?: Partial<RenderBufferOptions>);
    /**
     * 设置此渲染对象的的大小
     * @param width
     * @param height
     */
    resize(width: any, height: any): void;
    /**
     * 绑定渲染缓冲
     */
    bind(): void;
    /**
     * 解绑渲染缓冲
     */
    unbind(): void;
    removeStats(): void;
    /**
     * 销毁此渲染对象
     */
    destroy(): void;
    /**
     * 创建 `RBO`
     */
    createHandle(): WebGLRenderbuffer | null;
    /**
     * 移除 `RBO`
     */
    deleteHandle(): void;
}

type Attachment = [GLenum, Texture | DataTexture | RenderBuffer];
interface RenderTargetOptions extends ResourceOptions {
    /**
     * 非图片和 canvas 数据，传入的是一组结构化数组，这里我们先不去指定数据类型
     */
    data: any;
    /**
     * 设置此 `RenderTarget` 的名称，方便我们区分不同的 `RenderTarget`。
     */
    name: string;
    /**
     * `RenderTarget` 的宽度
     */
    width: number;
    /**
     * `RenderTarget` 的高度
     */
    height: number;
    /**
     * 颜色关联对象的数量，默认是`1`。
     * 可以理解为整个帧缓存对象就是一张纹理，这个纹理的颜色就保存在`color attachment`中。
     */
    color: number;
    /**
     * 关联对象，此参数是一个数组，可以指定多组关联对象
     */
    attachments: Attachment[];
    /**
     * 是否包含深度关联对象
     */
    depth: boolean;
    /**
     * 是否包含模版关联对象
     */
    stencil: boolean;
    /**
     * 是否是深度纹理，默认是`false`。
     */
    depthTexture: boolean;
}
/**
 * `RenderTarget` 是一种用于将场景渲染到纹理的方法，主要用于做离屏渲染和后处理等效果。
 *
 * 示例代码：
 * ```ts
 * const options = {
 *   width: 256,
 *   height: 256,
 *   minFilter: renderer.gl.NEAREST,
 *   magFilter: renderer.gl.NEAREST
 * };
 * const current = new RenderTarget(renderer, options);
 *
 * current.resize(width, height);
 * current.bind();
 * renderer.setViewport(0, 0, width, height);
 * mesh.updateMatrixWorld();
 * mesh.draw();
 * current.unbind();
 * ```
 */
declare class RenderTarget extends Resource<RenderTargetOptions> {
    #private;
    depth: boolean;
    /**
     * `RenderTarget` 宽度
     */
    width: number;
    /**
     * `RenderTarget` 高度
     */
    height: number;
    /**
     * `RenderTarget` 视图大小，默认是一个四维向量
     */
    viewport: Vector4;
    /**
     * 绘制对象是否变化
     */
    drawBuffersChanged: boolean;
    /**
     * 绘制缓存(绘制缓存设置了上一次绑定帧缓存状态，如果没有帧缓存可用的话，则用绘制缓存)
     */
    drawBuffers: number[];
    /**
     * @param renderer `Renderer` 对象
     * @param options 配置项，详见 #RenderTargetOptions
     */
    constructor(renderer: Renderer, options?: Partial<RenderTargetOptions>);
    get texture(): any;
    /**
     * 设置清屏颜色值
     * @param colors
     */
    set clearColors(colors: [number, number, number, number][]);
    /**
     * 获取清屏颜色值
     */
    get clearColors(): [number, number, number, number][];
    /**
     * 设置清除深度缓冲区的深度值
     * @param depth 深度值
     */
    set clearDepth(depth: number);
    /**
     * 获取深度缓冲区的深度值
     */
    get clearDepth(): number;
    /**
     * 设置清除模版缓冲区的默认值
     * @param stencil 模版缓冲区默认值
     */
    set clearStencil(stencil: number);
    /**
     * 获取缓冲区的默认值
     */
    get clearStencil(): number;
    /**
     * 创建帧缓冲关联对象
     * @param attachments
     */
    create(attachments: Attachment[]): any;
    /**
     * 清空此帧缓冲区
     */
    clear(): void;
    getTexture(key: any): any;
    /**
     * 重新设置此帧缓冲区的大小
     * @param width 宽度
     * @param height 高度
     */
    resize(width: number, height: number): void;
    /**
     * 绑定帧缓冲区
     * @param fbo 如果未传入 `fbo`，默认是此 `RenderTarget` 创建的帧缓冲
     */
    bind(fbo?: number): void;
    /**
     * 解绑帧缓冲区
     * @param fbo 如果未传入 `fbo`，默认是此 `RenderTarget` 创建的帧缓冲
     */
    unbind(fbo?: number): void;
    removeStats(): void;
    /**
     * 销毁此 `RenderTarget`
     * - 销毁关联的纹理缓冲区
     * - 销毁关联的渲染缓冲区
     * - 销毁帧缓冲区
     */
    destroy(): void;
    /**
     * 创建帧缓冲区
     */
    createHandle(): WebGLFramebuffer | null;
    /**
     * 移除帧缓冲区
     */
    deleteHandle(): void;
    /**
     * 将此实例转换为字符串标识
     */
    toString(): string;
}

declare class ProjectionMatrix extends Matrix4 {
    /**
     * 一般用于生成相机的视椎体，用来做视椎剔除加速渲染
     * @param mat4
     * @param left
     * @param right
     * @param top
     * @param bottom
     * @param near
     * @param far
     */
    frustum(mat4: any, left: any, right: any, top: any, bottom: any, near: any, far: any): this;
    /**
     * 生成平面相机投影矩阵
     * @param left
     * @param right
     * @param top
     * @param bottom
     * @param near
     * @param far
     */
    orthographic(left: any, right: any, top: any, bottom: any, near: any, far: any): this;
    /**
     * 生成透视相机投影矩阵
     * @param fovy
     * @param aspect
     * @param near
     * @param far
     */
    perspective(fovy: any, aspect: any, near: any, far: any): this;
    /**
     * 设置物体的朝向
     * @param eye
     * @param target
     * @param up
     */
    lookAt(eye: any, target?: Vector3, up?: Vector3): this;
    /**
     * 转换为字符串
     */
    toString(): string;
}

/**
 * 三维物体，是大部分对象的基类，提供了一系列的属性和方法来对三维空间中的物体进行操作
 */
declare class Object3D {
    /**
     * 是否可见
     */
    visible: boolean;
    /**
     * 局部变换矩阵
     */
    localMatrix: ProjectionMatrix;
    /**
     * 物体的世界变换矩阵 (如果没有父级，那么他和局部变化矩阵相同)
     */
    worldMatrix: ProjectionMatrix;
    /**
     * 当这个属性设置了之后，它将计算每一帧的位移、旋转（四元变换）和缩放矩阵，并重新计算 `worldMatrix` 属性
     */
    matrixAutoUpdate: boolean;
    /**
     * 物体局部位置
     */
    position: Vector3;
    /**
     * 物体的局部缩放
     */
    scale: Vector3;
    /**
     * 物体的局部旋转
     */
    rotation: Euler;
    /**
     * 物体的局部旋转
     */
    quaternion: Quaternion;
    /**
     * 物体的朝向
     */
    up: Vector3;
    /**
     * 对象子级
     */
    children: Object3D[];
    /**
     * 对象父级
     */
    parent: WithNull<Object3D>;
    /**
     * 当这个属性设置了之后，它将计算在那一帧中的 `worldMatrix`，并将这个值重置为false。默认值为false
     */
    worldMatrixNeedsUpdate: boolean;
    constructor();
    /**
     * 添加对象到这个对象的子级
     * @param object
     * @param notifyChild
     */
    add(object: Object3D, notifyChild?: boolean): void;
    /**
     * 从此对象移除传入的对象（如果存在）
     * @param object
     * @param notifyChild
     */
    remove(object: Object3D, notifyChild?: boolean): void;
    /**
     * 判断此渲染对象的子集是否包含传入的渲染对象
     * @param object
     */
    contains(object: Object3D): boolean;
    /**
     * 设置此渲染对象的父集
     * @param object 渲染对象
     * @param notifyParent 设置是否将此渲染对象添加到传入的渲染对象中
     */
    setParent(object: any, notifyParent?: boolean): void;
    /**
     * 遍历此对象（包含子对象）
     * @param callback 回调函数
     */
    traverse(callback: any): void;
    /**
     * 旋转物体使其在世界空间中面朝一个点
     * @param eye 朝向位置
     * @param invert 是否反转
     */
    lookAt(eye: Vector3, invert?: boolean): void;
    /**
     * 更新渲染对象的世界矩阵
     * @param force 是否更新次渲染对象的子集
     */
    updateMatrixWorld(force?: boolean): void;
    /**
     * 更新局部变换矩阵
     */
    updateMatrix(): void;
    /**
     * 从局部矩阵计算位置，旋转和缩放
     */
    decompose(): void;
    /**
     * 克隆此渲染对象
     */
    clone(): Object3D;
    /**
     * 复制给定的对象到这个对象中
     * @param object 渲染对象
     * @param recursive 设置是否复制子对象
     */
    copy(object: Object3D, recursive?: boolean): this;
}

/**
 * 场景对象，一般我们会将创建的网格渲染对象添加到场景中进行渲染
 *
 * 代码示例：
 * ```ts
 * const scene = new Scene();
 *
 * const points = new Mesh(renderer, { mode: renderer.gl.POINTS, geometry, program });
 *
 * points.position.set(-1, 1, 0);
 *
 * scene.add(points);
 * ```
 */
declare class Scene extends Object3D {
    /**
     * 克隆场景对象
     */
    clone(): Scene;
    /**
     * 将传入的场景对象的各属性复制到此场景实例中
     * @param source 源场景
     * @param recursive 设置是否复制子对象
     */
    copy(source: any, recursive: any): this;
}

declare const innerExtensionKeys: readonly ["ANGLE_instanced_arrays", "OES_vertex_array_object"];
type InnerExtensionKeys = typeof innerExtensionKeys[number];
/**
 * 仅在 webgl 1 中使用的扩展，webgl2 直接支持
 */
declare const external1ExtensionKeys: readonly ["WEBGL_depth_texture", "OES_texture_half_float", "OES_texture_float", "OES_standard_derivatives", "OES_element_index_uint", "EXT_frag_depth", "EXT_blend_minmax", "EXT_shader_texture_lod", "WEBGL_draw_buffers", "WEBGL_color_buffer_float"];
/**
 * 仅在 webgl 2 中支持的扩展
 */
declare const external2ExtensionKeys: readonly ["EXT_color_buffer_float"];
/**
 * 在 webgl1 和 webgl2 都支持的扩展
 */
declare const external12ExtensionKeys: readonly ["WEBGL_lose_context", "OES_texture_half_float_linear", "OES_texture_float_linear", "EXT_color_buffer_half_float", "WEBGL_debug_renderer_info", "EXT_texture_filter_anisotropic"];
type External1ExtensionKeys = typeof external1ExtensionKeys[number];
type External2ExtensionKeys = typeof external2ExtensionKeys[number];
type External12ExtensionKeys = typeof external12ExtensionKeys[number];
type ExternalExtensionKeys = External1ExtensionKeys | External2ExtensionKeys | External12ExtensionKeys;
type ExtensionKeys = InnerExtensionKeys | ExternalExtensionKeys;
type Extensions = ANGLE_instanced_arrays | OES_vertex_array_object | WEBGL_depth_texture | OES_texture_half_float | OES_texture_float | OES_texture_half_float_linear | OES_texture_float_linear | OES_standard_derivatives | OES_element_index_uint | EXT_frag_depth | EXT_blend_minmax | EXT_shader_texture_lod | WEBGL_draw_buffers;
interface RendererOptions {
    /**
     * 指定 `devicePixelRatio`
     */
    dpr: number;
    /**
     * 指定是否开启自动清除
     */
    autoClear: boolean;
    /**
     * 指定是否开启深度检测
     */
    depth: boolean;
    /**
     * 指定画布是否包含alpha缓冲区，仅在传入的是 `canvas` 对象时有用
     */
    alpha: boolean;
    /**
     * 指定是否开启抗锯齿，仅在传入的是 `canvas` 对象时有用
     */
    antialias: boolean;
    /**
     * 指定是否开启模板缓冲区
     */
    stencil: boolean;
    /**
     * 指定GPU的性能配置，仅在传入的是 `canvas` 对象时有用
     */
    powerPreference: WebGLPowerPreference;
    /**
     * 指定是否开启预乘alpha
     */
    premultipliedAlpha: boolean;
    /**
     * 是否开启绘制缓冲区，仅在传入的是 `canvas` 对象时有用
     */
    preserveDrawingBuffer: boolean;
    /**
     * 获取 `webgl2` 实例，仅在传入的是 `canvas` 对象时有用
     */
    requestWebGl2: boolean;
    /**
     * 是否开启视锥剔除，默认不开启
     */
    frustumCull: boolean;
    /**
     * WebGL 上下文支持的扩展列表。默认 []
     */
    extensions: ExternalExtensionKeys[];
}
interface RenderParams {
    /**
     * 场景对象
     */
    scene: Scene;
    /**
     * 相机对象
     */
    camera: any;
    /**
     * 指定渲染目标 `RenderTarget`，常用于在多个 `RenderPass` 做流转，用来实现诸如后处理 `PostProcessing`。
     */
    target?: RenderTarget;
    /**
     * 指定是否强制更新
     */
    update?: boolean;
    /**
     * 指定是否进行渲染对象的排序
     */
    sort?: boolean;
    /**
     * 是否开启进行视锥剔除（通过计算各渲染对象的包围盒，完全在视锥外的排除在`RendererList` 之外）。
     */
    frustumCull?: boolean;
    /**
     * 指定是否进行（颜色、深度、模版）缓冲区清除
     */
    clear?: boolean;
}
/**
 * 渲染器
 */
declare class Renderer {
    #private;
    vertexAttribDivisor: ANGLE_instanced_arrays['vertexAttribDivisorANGLE'] | WebGL2RenderingContext['vertexAttribDivisor'];
    drawArraysInstanced: ANGLE_instanced_arrays['drawArraysInstancedANGLE'] | WebGL2RenderingContext['drawArraysInstanced'];
    drawElementsInstanced: ANGLE_instanced_arrays['drawElementsInstancedANGLE'] | WebGL2RenderingContext['drawElementsInstanced'];
    createVertexArray: OES_vertex_array_object['createVertexArrayOES'] | WebGL2RenderingContext['createVertexArray'];
    bindVertexArray: OES_vertex_array_object['bindVertexArrayOES'] | WebGL2RenderingContext['bindVertexArray'];
    deleteVertexArray: OES_vertex_array_object['deleteVertexArrayOES'] | WebGL2RenderingContext['deleteVertexArray'];
    width: number;
    height: number;
    constructor(gl: WebGLRenderingContext | WebGL2RenderingContext | HTMLCanvasElement, opts?: Partial<RendererOptions>);
    /**
     * 获取 gl 实例
     */
    get gl(): WebGLRenderingContext | WebGL2RenderingContext;
    /**
     * 获取 `Renderer` 的内部属性值
     */
    get attributes(): {
        dpr: number;
        flipY: boolean;
        depth: WithUndef<boolean>;
        color: boolean;
        antialias: WithUndef<boolean>;
        alpha: WithUndef<boolean>;
        stencil: WithUndef<boolean>;
        autoClear: boolean;
        frustumCull: boolean;
        premultipliedAlpha: WithUndef<boolean>;
        preserveDrawingBuffer: WithUndef<boolean>;
    };
    /**
     * 获取 canvas 实例
     */
    get canvas(): HTMLCanvasElement | OffscreenCanvas;
    /**
     * 判断是否是 `webgl1`
     */
    get isWebGL(): boolean;
    /**
     * 判断是否是 `webgl2`
     */
    get isWebGL2(): boolean;
    /**
     * 获取已开启的扩展
     */
    get extensions(): {
        ANGLE_instanced_arrays: Extensions;
        EXT_texture_filter_anisotropic: Extensions;
        EXT_blend_minmax: Extensions;
        EXT_color_buffer_float: Extensions;
        EXT_color_buffer_half_float: Extensions;
        EXT_frag_depth: Extensions;
        EXT_shader_texture_lod: Extensions;
        OES_element_index_uint: Extensions;
        OES_standard_derivatives: Extensions;
        OES_texture_float: Extensions;
        OES_texture_float_linear: Extensions;
        OES_texture_half_float: Extensions;
        OES_texture_half_float_linear: Extensions;
        OES_vertex_array_object: Extensions;
        WEBGL_color_buffer_float: Extensions;
        WEBGL_debug_renderer_info: Extensions;
        WEBGL_depth_texture: Extensions;
        WEBGL_draw_buffers: Extensions;
        WEBGL_lose_context: Extensions;
    };
    /**
     * 获取指定的扩展
     * @param key
     */
    extension(key: ExtensionKeys): Extensions;
    /**
     * 获取 canvas 画布大小
     */
    get size(): {
        width: number;
        height: number;
    };
    /**
     * 获取 `renderState`
     */
    get state(): State;
    /**
     * 获取 `premultipliedAlpha` 配置
     */
    get premultipliedAlpha(): WithUndef<boolean>;
    /**
     * 设置画布宽高
     * @param width 宽
     * @param height 高
     */
    setSize(width: number, height: number): void;
    /**
     * 设置 `webgl` 的 `viewport`
     * @param width
     * @param height
     * @param x
     * @param y
     */
    setViewport(width: any, height: any, x?: number, y?: number): void;
    /**
     * @private
     * 获取扩展
     * @param extension
     * @param method
     * @param extFunc
     */
    getExtension(extension: any, method: any, extFunc: any): any;
    /**
     * 获取渲染列表（排序先不实现）
     * @param scene
     * @param camera
     */
    getRenderList({ scene, camera }: {
        scene: any;
        camera: any;
    }): any[];
    /**
     * 渲染函数，一般会在每一帧中调用此方法
     * @param params
     */
    render(params: RenderParams): void;
    /**
     * 清空画布
     * @param color 颜色
     * @param depth 深度
     * @param stencil 模板
     */
    clear(color?: boolean, depth?: WithUndef<boolean>, stencil?: WithUndef<boolean>): void;
    /**
     * 重置内部 `WebGL` 状态。
     * 需要注意的是一般单独使用时我们不需要去重置状态，但是在跨多个 `WebGL` 库共享单个 `WebGL` 上下文时我们需要关注此方法。默认情况下
     * 我们会重置所有的状态，但是当我们确认多个共享库使用的状态完全相同时我们可以考虑仅重置部分状态以提高性能。但是有可能会出现无法预料的情况
     * 请在你确认状态完全匹配时使用 `force = false` 重置部分状态。
     * @param force 是否强制重置所用状态，默认是 `true`
     * @param vao
     */
    resetState(force?: boolean, vao?: WithNull<WebGLVertexArrayObject | WebGLVertexArrayObjectOES>): void;
}

/**
 * `attribute` 支持的数据类型
 */
type DataType = Float32Array | Float64Array | Uint32Array | Uint16Array | Uint8Array | Uint8ClampedArray | Int32Array | Int16Array | Int8Array;
interface Attribute {
    /**
     * `Attribute` 数据，必须是 `TypedArray` 类型
     */
    data: DataType;
    /**
     * 指定缓冲区每个顶点分量的个数, 一般为 1-4
     */
    size?: number;
    /**
     * 指定数组中每个元素的数据类型，一般我们不传时会由内部进行判断。
     */
    type?: GLenum;
    /**
     * 指定当整数值转换为浮点数时是否应该将整数数值归一化到特定的范围。
     * - 对于 `gl.BYTE` 和 `gl.SHORT`，当设置为`true`时，归一化到 [-1, 1]。
     * - 对于 `gl.UNSIGNED_BYTE` 和 `gl.UNSIGNED_SHORT`，当设置为`true`时，归一化到 [0, 1]。
     * - 对于 `gl.FLOAT` 和 `gl.HALF_FLOAT`，此参数无效。
     */
    normalized?: boolean;
    /**
     * 指定实例化渲染的数量，仅当 `ANGLE_instanced_arrays` 扩展可用时才支持此参数，在
     * `webgl2` 中默认支持，调用函数为 `vertexAttribDivisor`
     */
    divisor?: number;
    /**
     * 以字节为单位指定连续顶点属性开始之间的偏移量(即数组中一行长度)
     */
    stride?: number;
    /**
     * 指定顶点属性数组中第一部分的字节偏移量。必须是类型的字节长度的倍数
     */
    offset?: number;
    /**
     * 顶点数量
     */
    count?: number;
    /**
     * 指定缓冲区对象，常用的值为`gl.ARRAY_BUFFER` 和 `gl.ELEMENT_ARRAY_BUFFER`。当然在`webgl2` 中有一些新的可用值，如 `gl.UNIFORM_BUFFER`和 `gl.TRANSFORM_FEEDBACK_BUFFER`。
     */
    target?: GLenum;
    /**
     * 标记如何使用这些数据，`webgl` 会针对性的做一些优化，默认是 `gl.STATIC_DRAW`，即标记数据不会经常性改变。
     * 其他可用值请参考 https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData。
     */
    usage?: GLenum;
    /**
     * `WebGLBuffer`，一般我们不需要指定，会在内部进行创建
     */
    buffer?: WebGLBuffer;
    /**
     * 标记此 `Attribute` 是否需要重新上传 `GPU`，一般我们在数据改变时需要将此值设置为`true`。
     */
    needsUpdate?: boolean;
}
/**
 * 存储和 `BufferAttribute` 相关的属性
 */
declare class BufferAttribute {
    /**
     * `BufferAttribute` 的 `id`，不传时由内部生成。
     */
    id: string;
    /**
     * `Attribute` 数据，必须是 `TypedArray` 类型
     */
    data: DataType;
    /**
     * `BufferAttribute`中元素的数据类型
     */
    type: GLenum;
    /**
     * `BufferAttribute`中缓冲区每个顶点分量的个数, 一般为 1-4
     */
    size: number;
    /**
     * `BufferAttribute` 是否是实例化数据
     */
    instanced: boolean;
    /**
     * `BufferAttribute`中缓冲区顶点的偏移量
     */
    stride: number;
    /**
     * `BufferAttribute`中顶点属性数组中第一部分的字节偏移量
     */
    offset: number;
    /**
     * 指定实例化渲染的数量
     */
    divisor: number;
    /**
     * 当整数值转换为浮点数时是否应该将整数数值归一化到特定的范围
     */
    normalized: boolean;
    /**
     * 标记此 `BufferAttribute` 是否需要重新上传 `GPU`，一般我们在数据改变时需要将此值设置为`true`。
     */
    needsUpdate: boolean;
    /**
     * 顶点数量
     */
    count: number;
    /**
     * 标记如何使用这些数据，`webgl` 会针对性的做一些优化，默认是 `gl.STATIC_DRAW`，即标记数据不会经常性改变。
     * 其他可用值请参考 https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData。
     */
    usage: GLenum;
    /**
     * 缓冲区对象，常用的值为`gl.ARRAY_BUFFER` 和 `gl.ELEMENT_ARRAY_BUFFER`。当然在`webgl2` 中有一些新的可用值，如 `gl.UNIFORM_BUFFER`和 `gl.TRANSFORM_FEEDBACK_BUFFER`。
     */
    target: GLenum;
    /**
     * WebGLBuffer
     */
    buffer: WithNull<WebGLBuffer>;
    constructor(renderer: Renderer, attribute: Attribute);
}

declare function parseShader(shader: any, defines?: string[], includes?: never[]): any;
declare function defineShader(shader: any, defines?: {}): any;
/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */
declare function getShaderName(shader: string, defaultName?: string): string;
/**
 * 根据顶点索引重新构建 `Wireframe` 索引
 * @param position 顶点数据
 * @param indices 索引数据
 * @param numIndices 索引数量
 * @param data 原始索引数据
 */
declare function getWireframeIndex(position: DataType, indices: number[], numIndices: number, data?: Uint16Array | Uint32Array): number[];
/**
 * 判断是否是独立的边
 * @param start
 * @param end
 * @param position
 * @param edges
 */
declare function isUniqueEdge(start: any, end: any, position: any, edges: any): boolean;

declare const DEG_TO_RAD: number;
declare const RAD_TO_DEG: number;
/**
 * 度转弧度
 * @param deg 度
 */
declare function degToRad(deg: number): number;
/**
 * 弧度转度
 * @param a 弧度
 */
declare function radToDeg(a: number): number;
/**
 * 将值限定在最大最小值中间
 * @param val 当前值
 * @param min 最小值
 * @param max 最大值
 */
declare function clamp(val: number, min: number, max: number): number;
/**
 * 判断数值是否是 2 的 n 次方
 * @param value
 */
declare function isPowerOfTwo(value: any): boolean;
/**
 * 设置是否使用双精度浮点数
 * @param b
 * @param notifyGlMatrix 如果不想影响 `gl-matrix` 的构造器，需要设定为 `false`，这在我们公用 `gl-matrix` 并且其他库使用构造器的 `instanceof`
 * 做相关判断时可以避免受到影响。
 */
declare function highPrecision(b: boolean, notifyGlMatrix?: boolean): void;
/**
 * 获取 FloatArray 构造器
 */
declare function getFloatArrayConstructor(): Float32ArrayConstructor | Float64ArrayConstructor;

/**
 * 判断是否是 webgl
 * @param gl
 */
declare function isWebGL(gl: any): boolean;
/**
 * 判断是否是 webgl2
 * @param gl
 */
declare function isWebGL2(gl: any): boolean;
interface GlOptions {
    /**
     * 指定画布是否包含alpha缓冲区
     */
    alpha: boolean;
    /**
     * 指定是否开启抗锯齿。
     */
    antialias: boolean;
    /**
     * 指定是否开启深度检测。
     */
    depth: boolean;
    /**
     *  表示绘图缓冲区的深度缓冲区至少为16位。
     */
    desynchronized: boolean;
    /**
     * 指定是否开启模板缓冲区。
     */
    stencil: boolean;
    /**
     * 指定如果系统性能较低，是否创建上下文。
     */
    failIfMajorPerformanceCaveat: boolean;
    /**
     * 指定是否开启预乘alpha。
     */
    premultipliedAlpha: boolean;
    /**
     * 是否开启绘制缓冲区。
     */
    preserveDrawingBuffer: boolean;
    /**
     * 指定GPU的性能配置。
     */
    powerPreference: WebGLPowerPreference;
}
/**
 * 获取 webgl 实例
 * @param canvas
 * @param glOptions
 * @param requestWebGl2
 * @returns {null}
 */
declare function getContext(canvas: HTMLCanvasElement, glOptions?: Partial<GlOptions>, requestWebGl2?: boolean): WebGLRenderingContext | null;

/**
 * 获取当前秒数，自动回退
 * @return number
 */
declare const now: () => number;
/**
 * 返回数据类型
 * @param value
 * @return string
 */
declare function typeOf(value: any): string;
/**
 * 判断是否是字符串
 * @param s
 * @return boolean
 */
declare function isString(s: any): s is string;
/**
 * 判断是否是 undefined
 * @param s
 * @return boolean
 */
declare function isUndef(s: any): s is undefined;
/**
 * 简单判断是否是 16 进制字符串（需要完善）
 * @param string
 */
declare function isHex(string: any): boolean;
/**
 * 判断是否是数字
 * @param s
 * @return boolean
 */
declare function isNumber(s: any): s is number;
/**
 * 判断是否是正则
 * @param obj
 */
declare function isRegexp(obj: any): obj is RegExp;
/**
 * 判断是否是 null
 * @param value
 */
declare function isNull(value: any): boolean;
/**
 * 判断是否是对象
 * @param value
 */
declare function isObject(value: any): boolean;
declare function hasValue(v: any, state: any): boolean;
/**
 * 获取 uid
 * @param id= - Identifier base name
 * @return uid
 **/
declare function uid(id?: string): string;
/**
 * 排除对象的 key
 * @param obj
 * @param keys
 */
declare function omit<T, K extends keyof T>(obj: T, keys?: K[]): Omit<T, K>;
/**
 * pick object
 * @param obj
 * @param keys
 */
declare function pick<T, K extends keyof T>(obj: T, keys?: K[]): Omit<T, K>;
declare function requestAnimationFrame(cb: any): number;
declare function cancelAnimationFrame(cb: any): void;

declare const index_DEG_TO_RAD: typeof DEG_TO_RAD;
type index_GlOptions = GlOptions;
declare const index_RAD_TO_DEG: typeof RAD_TO_DEG;
declare const index_cancelAnimationFrame: typeof cancelAnimationFrame;
declare const index_clamp: typeof clamp;
declare const index_defineShader: typeof defineShader;
declare const index_degToRad: typeof degToRad;
declare const index_getContext: typeof getContext;
declare const index_getFloatArrayConstructor: typeof getFloatArrayConstructor;
declare const index_getShaderName: typeof getShaderName;
declare const index_getWireframeIndex: typeof getWireframeIndex;
declare const index_hasValue: typeof hasValue;
declare const index_highPrecision: typeof highPrecision;
declare const index_isHex: typeof isHex;
declare const index_isNull: typeof isNull;
declare const index_isNumber: typeof isNumber;
declare const index_isObject: typeof isObject;
declare const index_isPowerOfTwo: typeof isPowerOfTwo;
declare const index_isRegexp: typeof isRegexp;
declare const index_isString: typeof isString;
declare const index_isUndef: typeof isUndef;
declare const index_isUniqueEdge: typeof isUniqueEdge;
declare const index_isWebGL: typeof isWebGL;
declare const index_isWebGL2: typeof isWebGL2;
declare const index_now: typeof now;
declare const index_omit: typeof omit;
declare const index_parseShader: typeof parseShader;
declare const index_pick: typeof pick;
declare const index_radToDeg: typeof radToDeg;
declare const index_requestAnimationFrame: typeof requestAnimationFrame;
declare const index_typeOf: typeof typeOf;
declare const index_uid: typeof uid;
declare namespace index {
  export {
    index_DEG_TO_RAD as DEG_TO_RAD,
    index_GlOptions as GlOptions,
    index_RAD_TO_DEG as RAD_TO_DEG,
    index_cancelAnimationFrame as cancelAnimationFrame,
    index_clamp as clamp,
    index_defineShader as defineShader,
    index_degToRad as degToRad,
    index_getContext as getContext,
    index_getFloatArrayConstructor as getFloatArrayConstructor,
    index_getShaderName as getShaderName,
    index_getWireframeIndex as getWireframeIndex,
    index_hasValue as hasValue,
    index_highPrecision as highPrecision,
    index_isHex as isHex,
    index_isNull as isNull,
    index_isNumber as isNumber,
    index_isObject as isObject,
    index_isPowerOfTwo as isPowerOfTwo,
    index_isRegexp as isRegexp,
    index_isString as isString,
    index_isUndef as isUndef,
    index_isUniqueEdge as isUniqueEdge,
    index_isWebGL as isWebGL,
    index_isWebGL2 as isWebGL2,
    index_now as now,
    index_omit as omit,
    index_parseShader as parseShader,
    index_pick as pick,
    index_radToDeg as radToDeg,
    index_requestAnimationFrame as requestAnimationFrame,
    index_typeOf as typeOf,
    index_uid as uid,
  };
}

type ShaderType = 'vertex-shader' | 'fragment-shader' | 'unknown';
declare class Shader extends Resource<ResourceOptions> {
    #private;
    sourceCode: string;
    constructor(renderer: Renderer, sourceCode: any, type: any, includes?: {});
    injectShaderModule(shader: any, modules?: {}): any;
    createShader(source?: string): void;
    get source(): string;
    get shaderType(): ShaderType;
    getSource(): string | null;
    setSource(source: any): void;
    removeStats(): void;
    deleteHandle(): void;
    toString(): string;
}
/**
 * 顶点着色器
 */
declare class VertexShader extends Shader {
    constructor(renderer: Renderer, sourceCode: string, includes: any);
    createHandle(): WebGLShader | null;
}
/**
 * 片段着色器
 */
declare class FragmentShader extends Shader {
    constructor(renderer: Renderer, sourceCode: string, includes: any);
    createHandle(): WebGLShader | null;
}

type Uniforms = any;
interface UniformData {
    location: WithNull<WebGLUniformLocation>;
    type: GLenum;
    name: string;
    value?: any;
    isStruct: boolean;
    isStructArray?: boolean;
    structIndex?: number;
    structProperty?: string;
}
interface ProgramRenderState {
    /**
     * 指定正面或背面多边形是否可以剔除
     * 可能的值：`gl.FRONT`、`gl.FRONT_AND_BACK` 和 `gl.BACK`
     */
    cullFace: GLenum;
    /**
     * 指定图形顶点以顺时针是正面还是逆时针方向是正面：
     * 可能的值：`gl.CW` 和 `gl.CCW`
     */
    frontFace: GLenum;
    /**
     * 是否启用深度测试，默认启用
     */
    depthTest: boolean;
    /**
     * 是否开启深度值写入
     */
    depthWrite: boolean;
    /**
     * 指定深度检测的参数，即什么情况算失败、什么情况算作通过，默认是 `gl.LESS`。
     * 可能的值：
     * - gl.NEVER （总不通过）
     * - gl.LESS（如果新值小于缓冲区中的值则通过）
     * - gl.EQUAL（如果新值等于缓冲区中的值则通过）
     * - gl.LEQUAL（如果新值小于等于缓冲区中的值则通过）
     * - gl.GREATER（如果新值大于缓冲区中的值则通过）
     * - gl.NOTEQUAL（如果新值不等于缓冲区中的值则通过）
     * - gl.GEQUAL（如果新值大于等于缓冲区中的值则通过）
     * - gl.ALWAYS（总通过）
     */
    depthFunc: GLenum;
    /**
     * blend 类型
     */
    blending: BlendType;
    /**
     * 指定颜色混合算法
     * 可能的值可以参考：https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/blendFunc 和 https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFuncSeparate
     */
    blendFunc: {
        src: number;
        dst: number;
        srcAlpha?: number;
        dstAlpha?: number;
    };
    /**
     * 指定颜色混合方程式
     * 可能的值可以参考：https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation 和 https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquationSeparate
     */
    blendEquation: {
        modeRGB: number;
        modeAlpha?: number;
    };
}
interface ProgramOptions extends ProgramRenderState, ResourceOptions {
    /**
     * 指定 `id`
     */
    id: string;
    /**
     * 顶点着色器
     */
    vertexShader: string | VertexShader;
    /**
     * 片段着色器
     */
    fragmentShader: string | FragmentShader;
    /**
     * uniform
     */
    uniforms?: Uniforms;
    /**
     * 配置是否是透明渲染
     */
    transparent?: boolean;
    /**
     * 指定着色的宏定义
     */
    defines?: string[];
    /**
     * 着色器模块，会在着色器中遇到 `#include <xxx>` 会自动替换此配置项对应的着色器片段。
     */
    includes?: {
        [key: string]: string;
    };
}
/**
 * 着色器程序对象封装，主要功能如下：
 * - 创建Program管线，编译顶点着色器和片段着色器源码；
 * - 管理`Attribute`属性
 * - 管理`Uniform`属性
 * - 渲染状态的切换
 *
 * 示例代码：
 * ```jsx live
 * function render(props) {
 *   const drawModelVertex = `
 *     attribute vec2 uv;
 *     attribute vec3 position;
 *     uniform mat4 modelViewMatrix;
 *     uniform mat4 projectionMatrix;
 *
 *     varying vec2 vUv;
 *
 *     void main() {
 *         vUv = uv;
 *
 *         gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
 *
 *         // gl_PointSize only applicable for gl.POINTS draw mode
 *         gl_PointSize = 5.0;
 *     }
 *     `;
 *
 *   const drawModelFragment = `
 *     precision highp float;
 *
 *     uniform float uTime;
 *     varying vec2 vUv;
 *
 *     void main() {
 *         gl_FragColor.rgb = 0.5 + 0.3 * sin(vUv.yxx + uTime) + vec3(0.2, 0.0, 0.1);
 *         gl_FragColor.a = 1.0;
 *     }
 *     `;
 *
 *   const refDom = useRef(null);
 *
 *
 *
 *   const init = () => {
 *     const canvas = refDom.current;
 *
 *     canvas.width = canvas.clientWidth;
 *     canvas.height = canvas.clientHeight;
 *     const renderer = new Renderer(canvas, {
 *       alpha: true,
 *     });
 *
 *     const fov = 15;
 *     const nearZ = 0.1;
 *
 *     const farZ = 100;
 *     const camera = new PerspectiveCamera(fov, canvas.width / canvas.height, nearZ, farZ);
 *     camera.position.z = 15;
 *
 *     function resize(target) {
 *       const { width, height } = target.getBoundingClientRect();
 *       renderer.setSize(width, height);
 *       camera.aspect = width / height;
 *     }
 *
 *     const scene = new Scene();
 *
 *     const geometry = new Geometry(renderer, {
 *       position: {
 *         size: 3,
 *         data: new Float32Array([
 *           -0.5, 0.5, 0,
 *           -0.5, -0.5, 0,
 *           0.5, 0.5, 0,
 *           0.5, -0.5, 0
 *         ])
 *       },
 *       uv: {
 *         size: 2,
 *         data: new Float32Array([0, 1, 1, 1, 0, 0, 1, 0])
 *       },
 *       index: {
 *         data: new Uint16Array([0, 1, 2, 1, 3, 2])
 *       },
 *     });
 *
 *     const program = new Program(renderer, {
 *       vertexShader: drawModelVertex,
 *       fragmentShader: drawModelFragment,
 *       uniforms: {
 *         uTime: { value: 0 },
 *       },
 *     });
 *
 *     const points = new Mesh(renderer, { mode: renderer.gl.POINTS, geometry, program });
 *     points.setParent(scene);
 *     points.position.set(-1, 1, 0);
 *
 *     const lineStrip = new Mesh(renderer, { mode: renderer.gl.LINES, geometry, program });
 *     lineStrip.setParent(scene);
 *     lineStrip.position.set(1, 1, 0);
 *
 *     const lineLoop = new Mesh(renderer, { mode: renderer.gl.LINE_LOOP, geometry, program });
 *     lineLoop.setParent(scene);
 *     lineLoop.position.set(-1, -1, 0);
 *
 *     const triangles = new Mesh(renderer, { mode: renderer.gl.TRIANGLES, geometry, program });
 *     triangles.setParent(scene);
 *     triangles.position.set(1, -1, 0);
 *
 *     const raf = new Raf((t) => {
 *       program.setUniform('uTime', t);
 *       renderer.render({ scene, camera });
 *     });
 *
 *     return {
 *       canvas,
 *       resize,
 *     }
 *   }
 *
 *   useEffect(() => {
 *     const { canvas, resize } = init();
 *
 *     observe(canvas, resize);
 *
 *     return () => {
 *       unobserve(canvas, resize);
 *     };
 *   }, []);
 *
 *   return (
 *     <div className="live-wrap">
 *       <canvas className="scene-canvas" ref={refDom}></canvas>
 *     </div>
 *   );
 * }
 * ```
 */
declare class Program extends Resource<ProgramOptions> {
    #private;
    attributeOrder: string;
    uniforms: Uniforms;
    constructor(renderer: any, options?: Partial<ProgramOptions>);
    get uniformLocations(): Map<any, any>;
    get attributeLocations(): Map<any, any>;
    /**
     * 获取 `VertexShader` 对象
     */
    get vertexShader(): VertexShader;
    /**
     * 获取 `FragmentShader` 对象
     */
    get fragmentShader(): FragmentShader;
    /**
     *
     */
    use(): void;
    /**
     * 设置 Program 的 render state
     * @param states
     * @param merge 是否使用合并模式，如果为 `false` 则直接替换
     */
    setStates(states: Partial<ProgramRenderState>, merge?: boolean): void;
    applyState(): void;
    /**
     * 设置对应的 Uniform 值
     * @param key
     * @param value
     */
    setUniform(key: any, value: any): void;
    /**
     * 使用此 Program
     */
    bind(): void;
    /**
     * 取消使用此 `Program`
     */
    unbind(): void;
    createHandle(): WebGLProgram | null;
    deleteHandle(): void;
    /**
     * 销毁此`Program`
     */
    destroy(): void;
}

interface Attributes {
    [key: string]: Attribute;
}
/**
 * 几何体对象，包含了顶点位置，面片索引、法向量、颜色值、UV 坐标和自定义缓存属性值等，这些数据最终会上传到`GPU`中。
 *
 * 示例代码：
 *
 * ```ts
 * const geometry = new ve.Geometry(renderer, {
 *     position: {
 *       size: 3,
 *       data: new Float32Array([
 *         -0.5, 0.5, 0,
 *         -0.5, -0.5, 0,
 *         0.5, 0.5, 0,
 *         0.5, -0.5, 0
 *       ])
 *     },
 *     uv: {
 *       size: 2,
 *       data: new Float32Array([0, 1, 1, 1, 0, 0, 1, 0])
 *     },
 *     index: {
 *       data: new Uint16Array([0, 1, 2, 1, 3, 2])
 *     },
 *   });
 * ```
 */
declare class Geometry extends Base {
    #private;
    drawRange: any;
    instancedCount: number;
    isInstanced: boolean;
    drawMode: number;
    /**
     * @param renderer 渲染器
     * @param attributes 属性信息（顶点数据）
     */
    constructor(renderer: Renderer, attributes?: Attributes);
    /**
     * 获取当前几何体数据的唯一标识
     */
    get id(): string;
    /**
     * 获取全部的属性信息
     */
    get attributes(): Map<string, BufferAttribute>;
    /**
     * 获取属性数据
     */
    get attributesData(): Attributes;
    /**
     * 获取顶点索引属性
     */
    get index(): BufferAttribute | undefined;
    /**
     * 获取当前几何体的包围盒
     */
    get bounds(): any;
    /**
     * 手动设置包围盒，一般我们只需要内部计算
     * @param bounds
     */
    set bounds(bounds: any);
    /**
     * 添加对应的属性信息（顶点数据）
     * @param name
     * @param attribute
     */
    addAttribute(name: string, attribute: BufferAttribute): void;
    /**
     * 获取对应的属性信息（顶点数据）
     * @param name
     */
    getAttribute(name: any): BufferAttribute | undefined;
    /**
     * 设置对应的属性数据
     * @param name
     * @param data
     */
    setAttributeData(name: any, data: any): void;
    /**
     * 更新顶点属性数据
     * @param attribute
     */
    updateAttribute(attribute: any): void;
    /**
     * 移除属性信息
     * @param attribute
     */
    removeAttribute(attribute: any): void;
    /**
     * 设置顶点索引数据
     * @param index
     */
    setIndex(index: any): void;
    /**
     * 设置顶点数据
     * @param data
     */
    setVertices(data: any): void;
    /**
     * 设置顶点法向量数据
     * @param data
     */
    setNormals(data: any): void;
    /**
     * 设置纹理 UV 数据
     * @param data
     */
    setUVs(data: any): void;
    /**
     * 设置顶点颜色数据
     * @param colors
     */
    setColors(colors: (Vector4 | Vector3 | number[] | Float32Array | Float64Array)[]): void;
    /**
     * 设置顶点渲染的开始索引和数量
     * @param start 开始索引
     * @param count 数量
     */
    setDrawRange(start: number, count: number): void;
    /**
     * 设置实例化渲染的数量
     * @param count 数量
     */
    setInstancedCount(count: number): void;
    /**
     * 创建 Vao
     * @param program
     */
    createVAO(program: Program): void;
    /**
     * 绑定顶点属性数据
     * https://devdocs.io/dom/webgl2renderingcontext/vertexattribipointer
     * @param program
     */
    bindAttributes(program: Program): void;
    /**
     * 计算当前几何体的的矩形边界（立方体包围盒）
     * @param vertices 外部传入的顶点数据
     */
    computeBoundingBox(vertices?: DataType | number[]): any;
    /**
     * 计算当前几何体的的球形边界（球形包围盒）
     * @param vertices 外部传入的顶点数据
     */
    computeBoundingSphere(vertices?: DataType | number[]): void;
    /**
     * 执行绘制
     * @param program Program 对象
     * @param drawMode 绘制模式
     */
    draw(program: any, drawMode?: number): void;
    /**
     * 将传入的几何体对象的属性值拷贝到此对象
     * @param source 源几何体对象
     */
    copy(source: Geometry): this;
    /**
     * 克隆此几何体对象
     */
    clone(): Geometry;
    /**
     * 销毁几何体对象
     */
    destroy(): void;
}

/**
 * 相机类型，默认有两种：`perspective` 透视相机和`orthographic`平面相机。
 */
type CameraType = 'perspective' | 'orthographic';
type Bounds = {
    /**
     * 像机视锥体左侧面
     */
    left: number;
    /**
     * 像机视锥体右侧面
     */
    right: number;
    /**
     * 像机视锥体上侧面
     */
    top: number;
    /**
     * 像机视锥体下侧面
     */
    bottom: number;
};
interface CameraOptions {
    /**
     * 像机的近端面，默认值是0.1
     */
    near: number;
    /**
     * 像机的远端面，默认值是 100
     */
    far: number;
    /**
     * 摄像机视锥体垂直视野角度，从视图的底部到顶部，以角度来表示，默认为 `45`
     */
    fov?: number;
    /**
     * 相机视锥体的纵横比
     */
    aspect?: number;
    /**
     * 像机视锥体配置
     */
    bounds?: Bounds;
    /**
     * 相机缩放倍数
     */
    zoom?: number;
}
/**
 * 相机基类
 */
declare class Camera extends Object3D {
    #private;
    /**
     * 相机类型（默认有两种相机：perspective和orthographic）
     */
    cameraType: CameraType;
    /**
     * 投影矩阵
     */
    projectionMatrix: ProjectionMatrix;
    /**
     * 视图矩阵
     */
    viewMatrix: Matrix4;
    /**
     * pv矩阵，它是 `projectionMatrix`和`viewMatrix` 的乘积
     */
    projectionViewMatrix: ProjectionMatrix;
    /**
     * 世界位置坐标
     */
    worldPosition: Vector3;
    frustum: Matrix4;
    constructor({ near, far, fov, aspect, bounds, zoom, }?: CameraOptions);
    /**
     * 获取像机的近端面
     */
    get near(): number;
    /**
     * 设置像机的近端面，并更新摄像机投影矩阵
     * @param n near
     */
    set near(n: number);
    /**
     * 获取像机的远端面
     */
    get far(): number;
    /**
     * 设置像机的远端面，并更新摄像机投影矩阵
     * @param f
     */
    set far(f: number);
    /**
     * 获取摄像机视锥体垂直视野角度
     */
    get fov(): number;
    /**
     * 设置摄像机视锥体垂直视野角度，并更新摄像机投影矩阵
     * @param f 角度值
     */
    set fov(f: number);
    /**
     * 获取相机视锥体的纵横比
     */
    get aspect(): number;
    /**
     * 设置相机视锥体的纵横比，并更新摄像机投影矩阵
     * @param aspect
     */
    set aspect(aspect: number);
    /**
     * 获取相机的缩放倍数
     */
    get zoom(): number;
    /**
     * 设置相机的缩放倍数，并更新摄像机投影矩阵
     * @param zoom
     */
    set zoom(zoom: number);
    /**
     * 获取像机视锥体的范围
     */
    get bounds(): WithUndef<Bounds>;
    /**
     * 设置相机像机视锥体的范围，并更新摄像机投影矩阵
     * @param bounds
     */
    set bounds(bounds: WithUndef<Bounds>);
    /**
     * 创建或者更新 `projectionMatrix` 透视相机矩阵
     * @param fov
     * @param aspect
     * @param near
     * @param far
     */
    perspective(fov?: number, aspect?: number, near?: number, far?: number): void;
    /**
     * 创建或者更新 `projectionMatrix` 平面相机矩阵
     * @param left
     * @param right
     * @param top
     * @param bottom
     * @param near
     * @param far
     * @param zoom
     */
    orthographic(left: any, right: any, top: any, bottom: any, near?: number, far?: number, zoom?: number): void;
    /**
     * 设置相机的朝向
     * @param t 朝向位置，是一个三维向量
     */
    lookAt(t: any): this;
    /**
     * 用于更新一个对象的世界矩阵。
     * 每个可视对象都有一个叫做 `worldMatrix` 的矩阵，表示这个对象在世界坐标系中的位置和方向。
     * 当您修改对象的位置、旋转或缩放时，对象的 `worldMatrix` 矩阵会发生变化。如果您希望将这些变化反映到场景中，就需要调用 `updateMatrixWorld` 函数。
     */
    updateMatrixWorld(): this;
    /**
     * 判断 mesh 是否在相机视椎体内
     * @param node
     * @param worldMatrix
     */
    frustumIntersectsMesh(node: any, worldMatrix?: any): boolean;
    /**
     * @private
     * @param center
     * @param radius
     */
    frustumIntersectsSphere(center: any, radius: any): boolean;
    /**
     * 转换到世界坐标
     * @param v
     */
    project(v: any): this;
    unproject(v: any): this;
    /**
     * 更新摄像机投影矩阵，必须由子类实现
     */
    updateProjectionMatrix(): void;
}

/**
 * 透视相机
 *
 * 代码示例：
 * ```ts
 * const camera = new PerspectiveCamera(45, width / height, 1, 1000)
 * scene.add(camera);
 * ```
 */
declare class PerspectiveCamera extends Camera {
    constructor(fov: any, aspect: any, near: any, far: any);
    /**
     * 更新投影矩阵
     */
    updateProjectionMatrix(): void;
}

/**
 * 正交相机（在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变）
 *
 * 代码示例：
 * ```ts
 * const camera = new OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
 * scene.add(camera);
 * ```
 */
declare class OrthographicCamera extends Camera {
    constructor(left: any, right: any, top: any, bottom: any, near: any, far: any, zoom?: number);
    /**
     * 更新投影矩阵
     */
    updateProjectionMatrix(): void;
}

interface MeshOptions {
    /**
     * `Mesh` 的`id`
     */
    id?: string;
    /**
     * 几何体`Geometry`对象
     */
    geometry: Geometry;
    /**
     * `Program` 对象
     */
    program: Program;
    /**
     * 渲染方式，默认值为`gl.TRIANGLES`。
     * 其他可用值如下：
     * - `gl.POINTS`: 绘制一系列点。
     * - `gl.LINE_STRIP`: 绘制一个线条。即，绘制一系列线段，上一点连接下一点。
     * - `gl.LINE_LOOP`: 绘制一个线圈。即，绘制一系列线段，上一点连接下一点，并且最后一点与第一个点相连。
     * - `gl.LINES`: 绘制一系列单独线段。每两个点作为端点，线段之间不连接。
     * - `gl.TRIANGLE_STRIP`：绘制一个三角带。
     * - `gl.TRIANGLE_FAN`：绘制一个三角扇。
     * - `gl.TRIANGLES`: 绘制一系列三角形。每三个点作为顶点。
     */
    mode?: GLenum;
    /**
     * 是否启用视锥体剔除
     */
    frustumCulled?: boolean;
    /**
     * 指定`Mesh` 的渲染顺序值
     */
    renderOrder?: number;
    /**
     * 设置是否是网格渲染，默认是 `false`。当此值为 `true` 时，会去构建 `wireframeIndex` 索引。
     */
    wireframe?: boolean;
}
interface MeshDrawOptions {
    /**
     * 渲染器
     */
    renderer: Renderer;
    /**
     * 相机
     */
    camera: PerspectiveCamera | OrthographicCamera;
    /**
     * 指定渲染目标 `RenderTarget`，常用于在多个 `RenderPass` 做流转，用来实现诸如后处理 `PostProcessing`。
     */
    target: RenderTarget;
}
/**
 * 网格渲染对象
 *
 * 代码示例：
 *
 * ```ts
 * const points = new Mesh(renderer, { mode: renderer.gl.POINTS, geometry, program });
 * points.setParent(scene);
 * points.position.set(-1, 1, 0);
 * ```
 */
declare class Mesh extends Object3D {
    #private;
    gl: WebGLRenderingContext | WebGL2RenderingContext;
    modelViewMatrix: Matrix4;
    normalMatrix: Matrix3;
    renderOrder: number;
    zDepth: number;
    frustumCulled: boolean;
    mode: GLenum;
    renderer: Renderer;
    /**
     * @param renderer 渲染器
     * @param options MeshOptions
     */
    constructor(renderer: any, options?: MeshOptions);
    /**
     * 获取当前 `Mesh` 的 `id`
     */
    get id(): string;
    /**
     * 获取当前 `Mesh` 的几何体信息
     */
    get geometry(): Geometry;
    /**
     * 获取当前 `Mesh` 的 `program` 对象
     */
    get program(): Program;
    /**
     * 设置是否是网格渲染
     * @param wireframe
     */
    set wireframe(wireframe: boolean);
    /**
     * 获取是否是网格渲染
     */
    get wireframe(): boolean;
    /**
     * 执行`Mesh` 的渲染，一般由`Renderer` 渲染器进行调度。
     * @param options
     */
    draw(options?: MeshDrawOptions): void;
    /**
     * 更新网格几何体数据，主要是顶点索引数据
     * @param wireframe 是否更新索引数据为网格数据
     * @param force 是否强制更新
     */
    updateWireframeGeometry(wireframe: any, force?: boolean): void;
    /**
     * 更新几何体信息，如果开启了 `wireframe` 还需要更新 `WireframeGeometry`
     * @param geometry 几何体
     * @param destroy 是否销毁上一个几何体
     */
    updateGeometry(geometry: any, destroy?: boolean): void;
    /**
     * 更新 `Program` 对象
     * @param program
     * @param destroy 是否销毁上一个 program
     */
    updateProgram(program: any, destroy?: boolean): void;
    /**
     * 销毁此 `Mesh`
     */
    destroy(): void;
    /**
     * 克隆 `Mesh` 对象
     */
    clone(): Mesh;
    /**
     * 将给定的 `Mesh` 对象复制到此对象
     * @param mesh 源对象
     * @param recursive 设置是否复制子对象
     */
    copy(mesh: any, recursive?: boolean): this;
}

interface PlaneOptions {
    /**
     * 平面几何体沿着`X`轴的宽度，默认值是`1`。
     */
    width: number;
    /**
     * 平面几何体沿着`Y`轴的宽度，默认值是`1`。
     */
    height: number;
    /**
     * 宽度分段数，默认值是`1`。
     */
    widthSegments: number;
    /**
     * 高度分段数，默认值是`1`。
     */
    heightSegments: number;
    /**
     * 顶点数据
     */
    attributes: Attributes;
}
/**
 * 获取平面几何体数据
 * @param position
 * @param normal
 * @param uv
 * @param index
 * @param width
 * @param height
 * @param depth
 * @param widthSegments
 * @param heightSegments
 * @param u
 * @param v
 * @param w
 * @param uDir
 * @param vDir
 * @param i
 * @param ii
 */
declare function getPlaneBuffer(position: Float32Array, normal: Float32Array, uv: Float32Array, index: Uint32Array | Uint16Array, width?: number, height?: number, depth?: number, widthSegments?: number, heightSegments?: number, u?: number, v?: number, w?: number, uDir?: number, vDir?: number, i?: number, ii?: number): void;
/**
 * 平面几何体
 *
 * 代码示例：
 * ```ts
 * const plane - new Plane(renderer);
 *
 * const plane = new Mesh(renderer, { geometry: planeGeometry, program });
 * scene.add(plane);
 * ```
 */
declare class Plane extends Geometry {
    /**
     * @param renderer 渲染器
     * @param width 平面几何体沿着`X`轴的宽度，默认值是`1`。
     * @param height 平面几何体沿着`Y`轴的宽度，默认值是`1`。
     * @param widthSegments 宽度分段数，默认值是`1`。
     * @param heightSegments 高度分段数，默认值是`1`。
     * @param attributes 顶点数据
     */
    constructor(renderer: Renderer, { width, height, widthSegments, heightSegments, attributes, }?: Partial<PlaneOptions>);
}

interface BoxOptions {
    /**
     * 几何体沿着`X`轴的宽度，默认值是`1`。
     */
    width: number;
    /**
     * 几何体沿着`Y`轴的宽度，默认值是`1`。
     */
    height: number;
    /**
     * 几何体沿着`Z`轴的深度，默认值是`1`。
     */
    depth: number;
    /**
     * 宽度分段数，默认值是`1`。
     */
    widthSegments: number;
    /**
     * 高度分段数，默认值是`1`。
     */
    heightSegments: number;
    /**
     * 深度分段数，默认值是`1`。
     */
    depthSegments: number;
    /**
     * 顶点数据
     */
    attributes: Attributes;
}
/**
 * 立方体，通常用来创建立方体或者不规则四边形。
 *
 * 代码示例：
 * ```ts
 * const boxGeometry - new Box(renderer);
 *
 * const box = new Mesh(renderer, { geometry: boxGeometry, program });
 * scene.add(box);
 * ```
 */
declare class Box extends Geometry {
    /**
     * @param renderer 渲染器
     * @param width 几何体沿着`X`轴的宽度，默认值是`1`。
     * @param height 几何体沿着`Y`轴的宽度，默认值是`1`。
     * @param depth 几何体沿着`Z`轴的深度，默认值是`1`。
     * @param widthSegments 宽度分段数，默认值是`1`。
     * @param heightSegments 高度分段数，默认值是`1`。
     * @param depthSegments 深度分段数，默认值是`1`。
     * @param attributes 顶点数据
     */
    constructor(renderer: Renderer, { width, height, depth, widthSegments, heightSegments, depthSegments, attributes, }?: Partial<BoxOptions>);
}

interface Texture3DOptions extends TextureOptions {
    /**
     * 默认为 `gl.TEXTURE_3D`
     */
    target: GLenum;
    /**
     * 深度采样纹理时使用的行为, 仅在 `Texture3D` 时可用。
     * 可能的值：`gl.REPEAT`，`gl.MIRRORED_REPEAT`，`gl.CLAMP_TO_EDGE`
     */
    wrapR: number;
    /**
     * [GLenum](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Types) 制定纹素的版本。正确的 内部格式 组合被列举在 [这个列表](https://www.khronos.org/registry/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE)。
     */
    format: number;
    /**
     * 用于指定纹理图像的内部格式
     * 可能的值：`gl.RGBA`，`gl.RGB`，`gl.ALPHA` 等等
     */
    internalFormat: number;
    /**
     * 指定纹理数据的数据类型。
     * 可能的值：`gl.UNSIGNED_BYTE`，`gl.FLOAT`，`gl.UNSIGNED_SHORT`，`gl.UNSIGNED_INT` 等等
     * 可以查看[texImage3D](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL2RenderingContext/texImage3D) 来
     * 获取更多信息
     */
    type: number;
    /**
     * 指定纹理深度，默认为`0`
     */
    depth: number;
    /**
     * 纹理数据
     */
    image: any;
}
/**
 * 纹理
 * 一般在 `webgl` 中会将纹理用于贴图，或者作为 `renderTarget`
 * 代码示例：
 * ```ts
 * const texture = new ve.Texture3D(renderer, {
 *   generateMipmaps: true,
 *   flipY: true,
 * });
 *
 * const image = new Image();
 *
 * image.onload = () => {
 *   texture.setData(image, image.width, image.height);
 * };
 *
 * image.src = './assets/posx.jpg';
 * ```
 */
declare class Texture3D extends Texture<Texture3DOptions> {
    #private;
    /**
     * 设置纹理是否需要更新，一般我们会在纹理数据或者配置变更时将此配置项设置为 `true`
     * 这样会在下一次渲染时应用对应的纹理数据和配置。
     */
    needsUpdate: boolean;
    /**
     * 设置纹理单位
     */
    textureUnit: number;
    /**
     * 纹理深度
     */
    depth: number;
    /**
     * @param renderer Renderer 对象
     * @param options 配置项
     */
    constructor(renderer: Renderer, options?: Partial<Texture3DOptions>);
    /**
     * 获取 `webgl` 实例
     */
    get gl(): WebGL2RenderingContext;
    /**
     * 设置纹理数据
     * @param image 纹理数据
     * @param width 纹理宽度，默认为原始宽度
     * @param height 纹理高度，默认为原始高度
     * @param depth
     */
    setData(image: any, width?: number, height?: number, depth?: number): void;
    /**
     * 设置纹理配置（默认进行合并）
     * @param options 配置项
     */
    setOptions(options: Partial<Texture3DOptions>): void;
    /**
     * 更新纹理数据或者纹理相关配置
     * @param units 纹理单位，默认为 0
     */
    update(units?: number): void;
    /**
     * 移除相关状态
     */
    removeStats(): void;
    /**
     * 获取字符串数据
     */
    toString(): string;
}

export { Attachment, Attribute, Attributes, BlendType, Bounds, Box, BoxOptions, BufferAttribute, Camera, CameraOptions, CameraType, Clock, Color, ColorLike, DataTexture, DataTextureOptions, DataType, Euler, EventEmitter, Geometry, Matrix3, Matrix4, Mesh, MeshDrawOptions, MeshOptions, Object3D, OrthographicCamera, PerspectiveCamera, Plane, PlaneOptions, Program, ProgramOptions, ProgramRenderState, ProjectionMatrix, Quaternion, Raf, RafOptions, RenderBuffer, RenderBufferOptions, RenderTarget, RenderTargetOptions, Renderer, RendererOptions, Resource, ResourceOptions, Scene, State, Texture, Texture3D, Texture3DOptions, TextureOptions, UniformData, Uniforms, Vector2, Vector3, Vector4, getPlaneBuffer, highPrecision, index as utils };
