(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ve = {}));
})(this, (function (exports) { 'use strict';

  function parseShader(shader, defines = [], includes = []) {
    return shader.replace(/#defines/, defines.join("\n")).replace(/#includes/, includes.join("\n"));
  }
  function defineShader(shader, defines = {}) {
    return Object.keys(defines).reduce((str, key) => defines[key] ? `#define ${key} ${defines[key]}
${str}` : str, shader);
  }
  function getShaderName(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define\s*SHADER_NAME\s*([A-Za-z0-9_-]+)\s*/;
    const match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
  }
  function getWireframeIndex(position, indices, numIndices, data) {
    const edges = /* @__PURE__ */ new Set();
    if (data) {
      for (let j = 0, l = numIndices; j < l; j += 3) {
        const a = data[j];
        const b = data[j + 1];
        const c = data[j + 2];
        const array = [a, b, b, c, c, a];
        for (let i = 0; i < array.length; i += 2) {
          if (isUniqueEdge(array[i] * 3, array[i + 1] * 3, position, edges)) {
            indices.push(array[i], array[i + 1]);
          }
        }
      }
    } else {
      for (let j = 0, l = numIndices; j < l; j += 3) {
        const a = j;
        const b = j + 1;
        const c = j + 2;
        const array = [a, b, b, c, c, a];
        for (let i = 0; i < array.length; i += 2) {
          if (isUniqueEdge(array[i] * 3, array[i + 1] * 3, position, edges)) {
            indices.push(array[i], array[i + 1]);
          }
        }
      }
    }
    return indices;
  }
  function isUniqueEdge(start, end, position, edges) {
    const hash1 = `${position[start]},${position[start + 1]},${position[start + 2]}-${position[end]},${position[end + 1]},${position[end + 2]}`;
    const hash2 = `${position[end]},${position[end + 1]},${position[end + 2]}-${position[start]},${position[start + 1]},${position[start + 2]}`;
    if (edges.has(hash1) === true || edges.has(hash2) === true) {
      return false;
    } else {
      edges.add(hash1);
      edges.add(hash2);
      return true;
    }
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  /**
   * Sets the type of array used when creating new vectors and matrices
   *
   * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
   */

  function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
  }
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$4() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {ReadonlyMat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function copy$3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */

  function set$4(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */

  function identity$1(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function transpose$1(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }

    return out;
  }
  /**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function invert$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function adjoint$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  /**
   * Calculates the determinant of a mat3
   *
   * @param {ReadonlyMat3} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$1(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function multiply$5(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  /**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to translate
   * @param {ReadonlyVec2} v vector to translate by
   * @returns {mat3} out
   */

  function translate$1(out, a, v) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        x = v[0],
        y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  /**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function rotate$1(out, a, rad) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  /**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/

  function scale$4(out, a, v) {
    var x = v[0],
        y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Translation vector
   * @returns {mat3} out
   */

  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function fromRotation$1(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat3} out
   */

  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Calculates a 3x3 matrix from the given quaternion
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat3} out
   */

  function fromQuat$1(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  /**
   * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
   *
   * @returns {mat3} out
   */

  function normalFromMat4(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  /**
   * Returns Frobenius norm of a mat3
   *
   * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  /**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function add$4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function subtract$4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat3} a The first matrix.
   * @param {ReadonlyMat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$4(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7],
        a8 = a[8];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
  }

  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function copy$2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set$3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function invert$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {ReadonlyMat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function multiply$4(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to translate
   * @param {ReadonlyVec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {ReadonlyVec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$3(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Alias for {@link mat4.perspectiveNO}
   * @function
   */

  var perspective = perspectiveNO;
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Alias for {@link mat4.orthoNO}
   * @function
   */

  var ortho = orthoNO;
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function add$3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function subtract$3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$3(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$3() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$3(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$2(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function add$2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function multiply$3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Divides two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function divide$2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */

  function scaleAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$2(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Negates the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to negate
   * @returns {vec3} out
   */

  function negate$2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to invert
   * @returns {vec3} out
   */

  function inverse$2(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize$4(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$3(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function cross$2(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp$2(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4$2(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyQuat} q quaternion to transform with
   * @returns {vec3} out
   */

  function transformQuat$1(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3];
    var x = a[0],
        y = a[1],
        z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);

    var uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

    var uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);

    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @param {ReadonlyVec3} a The first operand
   * @param {ReadonlyVec3} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle$1(a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        bx = b[0],
        by = b[1],
        bz = b[2],
        mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
        mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
        mag = mag1 * mag2,
        cosine = mag && dot$3(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$2(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length$3;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create$3();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  })();

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$2() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the source vector
   * @returns {vec4} out
   */

  function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to the given values
   *
   * @param {vec4} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} out
   */

  function set$1(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Adds two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Multiplies two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function multiply$2(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  /**
   * Divides two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {vec4} out
   */

  function divide$1(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  /**
   * Scales a vec4 by a scalar number
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec4} out
   */

  function scale$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two vec4's after scaling the second operand by a scalar value
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec4} out
   */

  function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Calculates the squared euclidian distance between two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Calculates the length of a vec4
   *
   * @param {ReadonlyVec4} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$2(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Negates the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to negate
   * @returns {vec4} out
   */

  function negate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to invert
   * @returns {vec4} out
   */

  function inverse$1(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$3(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec4's
   *
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$2(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   *
   * @param {ReadonlyVec4} result the receiving vector
   * @param {ReadonlyVec4} U the first vector
   * @param {ReadonlyVec4} V the second vector
   * @param {ReadonlyVec4} W the third vector
   * @returns {vec4} result
   */

  function cross$1(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0],
        B = v[0] * w[2] - v[2] * w[0],
        C = v[0] * w[3] - v[3] * w[0],
        D = v[1] * w[2] - v[2] * w[1],
        E = v[1] * w[3] - v[3] * w[1],
        F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the first operand
   * @param {ReadonlyVec4} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec4} out
   */

  function lerp$1(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Transforms the vec4 with a quat
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyQuat} q quaternion to transform with
   * @returns {vec4} out
   */

  function transformQuat(out, a, q) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3]; // calculate quat * vec

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec4} a The first vector.
   * @param {ReadonlyVec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create$2();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  })();

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$1() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyVec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {ReadonlyQuat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */

  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      // If s is zero, return any axis (no rotation - axis does not matter)
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }

    return rad;
  }
  /**
   * Gets the angular distance between two unit quaternions
   *
   * @param  {ReadonlyQuat} a     Origin unit quaternion
   * @param  {ReadonlyQuat} b     Destination unit quaternion
   * @return {Number}     Angle, in radians, between the two quaternions
   */

  function getAngle(a, b) {
    var dotproduct = dot$1(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {quat} out
   */

  function multiply$1(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate inverse of
   * @returns {quat} out
   */

  function invert(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate conjugate of
   * @returns {quat} out
   */

  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyMat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the source quaternion
   * @returns {quat} out
   * @function
   */

  var copy = copy$1;
  /**
   * Set the components of a quat to the given values
   *
   * @param {quat} out the receiving quaternion
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} out
   * @function
   */

  var set = set$1;
  /**
   * Calculates the dot product of two quat's
   *
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$1 = dot$2;
  /**
   * Calculates the length of a quat
   *
   * @param {ReadonlyQuat} a vector to calculate length of
   * @returns {Number} length of a
   */

  var length$1 = length$2;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$3;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {ReadonlyVec3} a the initial vector
   * @param {ReadonlyVec3} b the destination vector
   * @returns {quat} out
   */

  (function () {
    var tmpvec3 = create$3();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function (out, a, b) {
      var dot = dot$3(a, b);

      if (dot < -0.999999) {
        cross$2(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross$2(tmpvec3, yUnitVec3, a);
        normalize$4(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross$2(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot;
        return normalize$2(out, out);
      }
    };
  })();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {ReadonlyQuat} c the third operand
   * @param {ReadonlyQuat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  (function () {
    var temp1 = create$1();
    var temp2 = create$1();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  })();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {ReadonlyVec3} view  the vector representing the viewing direction
   * @param {ReadonlyVec3} right the vector representing the local "right" direction
   * @param {ReadonlyVec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  (function () {
    var matr = create$4();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  })();

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  /**
   * Multiplies two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  /**
   * Divides two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  /**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */

  function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the squared euclidian distance between two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x * x + y * y;
  }
  /**
   * Calculates the length of a vec2
   *
   * @param {ReadonlyVec2} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0],
        y = a[1];
    return Math.hypot(x, y);
  }
  /**
   * Negates the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to negate
   * @returns {vec2} out
   */

  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to invert
   * @returns {vec2} out
   */

  function inverse(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
  }
  /**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to normalize
   * @returns {vec2} out
   */

  function normalize$1(out, a) {
    var x = a[0],
        y = a[1];
    var len = x * x + y * y;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Computes the cross product of two vec2's
   * Note that the cross product must by definition produce a 3D vector
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec2} out
   */

  function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Transforms the vec2 with a mat4
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {ReadonlyVec2} a The first operand
   * @param {ReadonlyVec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1],
        // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
        // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec2} a The first vector.
   * @param {ReadonlyVec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals(a, b) {
    var a0 = a[0],
        a1 = a[1];
    var b0 = b[0],
        b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
  }
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  })();

  const DEG_TO_RAD = Math.PI / 180;
  const RAD_TO_DEG = 180 / Math.PI;
  function degToRad(deg) {
    return deg * DEG_TO_RAD;
  }
  function radToDeg(a) {
    return a * RAD_TO_DEG;
  }
  function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }
  function isPowerOfTwo(value) {
    return Math.log(value) / Math.LN2 % 1 === 0;
  }
  let FloatArray = Float32Array;
  function highPrecision(b, notifyGlMatrix = true) {
    if (b) {
      FloatArray = Float64Array;
    } else {
      FloatArray = Float32Array;
    }
    if (notifyGlMatrix) {
      setMatrixArrayType(FloatArray);
    }
  }
  function getFloatArrayConstructor() {
    return FloatArray;
  }

  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    if (gl?.gl && (gl.gl instanceof WebGLRenderingContext || gl.gl instanceof WebGL2RenderingContext)) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    if (gl?.gl && gl.gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getContext(canvas, glOptions = {}, requestWebGl2 = false) {
    const names = ["webgl2", "webgl", "experimental-webgl"];
    if (!requestWebGl2) {
      names.shift();
    }
    let context = null;
    function onContextCreationError(error) {
      console.error(error.statusMessage);
    }
    canvas?.addEventListener?.("webglcontextcreationerror", onContextCreationError, false);
    for (let ii = 0; ii < names.length; ++ii) {
      try {
        context = canvas.getContext(names[ii], glOptions);
      } catch (e) {
      }
      if (context) {
        break;
      }
    }
    canvas?.removeEventListener?.("webglcontextcreationerror", onContextCreationError, false);
    return context;
  }

  const now = () => ("undefined" == typeof performance ? Date : performance).now();
  function typeOf(value) {
    return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
  }
  function isString(s) {
    return typeOf(s) === "string";
  }
  function isUndef(s) {
    return typeOf(s) === "undefined";
  }
  function isHex(string) {
    return isString(string) && string.includes("%");
  }
  function isNumber(s) {
    return typeOf(s) === "number";
  }
  function isRegexp(obj) {
    return typeOf(obj) === "regexp";
  }
  function isNull(value) {
    return value == null;
  }
  function isObject(value) {
    const type = typeof value;
    return value !== null && (type === "object" || type === "function");
  }
  function hasValue(v, state) {
    if (isObject(v)) {
      return !isNull(v.value) && (isNull(state) || v.value === state);
    } else {
      return !isNull(v) && (isNull(state) || v === state);
    }
  }
  const uidCounters = {};
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
  }
  function omit(obj, keys = []) {
    return Object.keys(obj).filter((key) => keys.indexOf(key) < 0).reduce(
      (newObj, key) => Object.assign(newObj, {
        [key]: obj[key]
      }),
      {}
    );
  }
  function pick(obj, keys = []) {
    return Object.keys(obj).filter((key) => keys.indexOf(key) > -1).reduce(
      (newObj, key) => Object.assign(newObj, {
        [key]: obj[key]
      }),
      {}
    );
  }
  const callbacks = [];
  const fpsInterval = 1e3 / 60;
  let time = performance.now();
  function requestAnimationFrameLoop() {
    const current = now();
    const delta = current - time;
    if (delta >= fpsInterval) {
      time = current - delta % fpsInterval;
      const funcs = callbacks.slice();
      callbacks.length = 0;
      for (let i = 0; i < funcs.length; i++) {
        funcs[i] && funcs[i](current, delta);
      }
    } else {
      setImmediate(requestAnimationFrameLoop);
    }
  }
  function raf(func) {
    callbacks.push(func);
    if (callbacks.length === 1) {
      setImmediate(requestAnimationFrameLoop);
    }
    return callbacks.length - 1;
  }
  function caf(id) {
    callbacks[id] = void 0;
  }
  function requestAnimationFrame(cb) {
    if (typeof window !== "undefined" && window.requestAnimationFrame) {
      return window.requestAnimationFrame(cb);
    }
    return raf(cb);
  }
  function cancelAnimationFrame(cb) {
    if (typeof window !== "undefined" && window.cancelAnimationFrame) {
      return window.cancelAnimationFrame(cb);
    }
    return caf(cb);
  }

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEG_TO_RAD: DEG_TO_RAD,
    RAD_TO_DEG: RAD_TO_DEG,
    cancelAnimationFrame: cancelAnimationFrame,
    clamp: clamp,
    defineShader: defineShader,
    degToRad: degToRad,
    getContext: getContext,
    getFloatArrayConstructor: getFloatArrayConstructor,
    getShaderName: getShaderName,
    getWireframeIndex: getWireframeIndex,
    hasValue: hasValue,
    highPrecision: highPrecision,
    isHex: isHex,
    isNull: isNull,
    isNumber: isNumber,
    isObject: isObject,
    isPowerOfTwo: isPowerOfTwo,
    isRegexp: isRegexp,
    isString: isString,
    isUndef: isUndef,
    isUniqueEdge: isUniqueEdge,
    isWebGL: isWebGL,
    isWebGL2: isWebGL2,
    now: now,
    omit: omit,
    parseShader: parseShader,
    pick: pick,
    radToDeg: radToDeg,
    requestAnimationFrame: requestAnimationFrame,
    typeOf: typeOf,
    uid: uid
  });

  class Clock {
    #lastTime = 0;
    #elapsedTime = 0;
    #start = false;
    running;
    constructor(running = true) {
      this.running = running;
    }
    start() {
      if (!this.#start) {
        this.reset();
        this.#start = true;
      }
    }
    stop() {
      this.getElapsedTime();
      this.#start = false;
      this.running = false;
    }
    reset() {
      this.#lastTime = now();
      this.#elapsedTime = 0;
    }
    getElapsedTime() {
      this.getDelta();
      return this.#elapsedTime;
    }
    getDelta() {
      let deltaTime = 0;
      if (this.running && !this.#start) {
        this.start();
        return 0;
      }
      if (this.#start) {
        const time = now();
        deltaTime = (time - this.#lastTime) / 1e3;
        this.#lastTime = time;
        this.#elapsedTime = this.#elapsedTime + deltaTime;
      }
      return deltaTime;
    }
  }

  const defaultOptions = {
    autoStart: true
  };
  class Raf {
    options;
    #raf;
    #animating;
    #isVisible;
    #clock;
    #callback;
    constructor(cb, options = {}) {
      this.options = {
        ...options,
        ...defaultOptions
      };
      this.#clock = new Clock();
      this.reset();
      this.onVisibilityChange = this.onVisibilityChange.bind(this);
      this.#callback = () => {
        const time = this.#clock.getElapsedTime();
        cb && cb(time);
      };
      if (this.options.autoStart) {
        this.start();
      }
    }
    get visible() {
      return this.#isVisible;
    }
    get animating() {
      return this.#animating;
    }
    reset() {
      this.#animating = false;
      this.#isVisible = true;
      if (this.#raf !== void 0) {
        cancelAnimationFrame(this.#raf);
      }
    }
    get elapsedTime() {
      return this.#clock.getElapsedTime();
    }
    start() {
      if (this.#animating)
        return;
      this.#animating = true;
      this.#clock.start();
      this.tick();
      if (typeof window !== "undefined" && window.document) {
        window.document.addEventListener("visibilitychange", this.onVisibilityChange, false);
      }
    }
    stop() {
      this.#clock.stop();
      this.reset();
      if (typeof window !== "undefined" && window.document) {
        window.document.removeEventListener("visibilitychange", this.onVisibilityChange, false);
      }
    }
    tick() {
      if (!this.#animating || !this.#isVisible)
        return;
      this.#raf = requestAnimationFrame(() => {
        this.tick();
      });
      this.#callback();
    }
    onVisibilityChange() {
      if (typeof window !== "undefined" && window.document) {
        this.#isVisible = !window.document.hidden;
      }
      if (this.#isVisible) {
        this.reset();
        this.start();
      }
    }
  }

  class Event {
    type;
    constructor(type, params = {}) {
      this.type = type;
      (Object.getOwnPropertyNames(params) || []).forEach((key) => {
        this[key] = params[key];
      });
    }
  }
  class EventEmitter {
    fns;
    validateEventTypes;
    constructor({ validEventTypes = [/.*/] } = {}) {
      this.fns = /* @__PURE__ */ new Map();
      this.validateEventTypes = validEventTypes;
    }
    validateEventType(type) {
      let vs = this.validateEventTypes;
      if (!Array.isArray(this.validateEventTypes)) {
        vs = [this.validateEventTypes];
      }
      let isValid = true;
      vs.forEach((r) => {
        if (isRegexp(r) && !r.test(type)) {
          isValid = false;
        }
      });
      if (!isValid) {
        throw new Error(`Invalid Event Type: '${type}'.
Event type should be any of: ${vs}.`);
      }
    }
    on(type, handler, context) {
      this.validateEventType(type);
      if (isString(type)) {
        const names = type.split(" ");
        if (names.length > 1) {
          names.forEach((t) => {
            this.on(t, handler, context);
          });
          return this;
        }
      }
      if (!this.has(type)) {
        this.fns.set(type, []);
      }
      this.fns.get(type).push(handler);
      return this;
    }
    once(type, handler, context) {
      this.validateEventType(type);
      if (isString(type)) {
        const names = type.split(" ");
        if (names.length > 1) {
          names.forEach((t) => {
            this.once(t, handler, context);
          });
          return this;
        }
      }
      const onceHandler = (...args) => {
        this.off(type, onceHandler);
        handler.call(context || this, ...args);
      };
      return this.on(type, onceHandler, context);
    }
    off(type, handler, context) {
      this.validateEventType(type);
      if (isString(type)) {
        const names = type.split(" ");
        if (names.length > 1) {
          names.forEach((t) => {
            this.off(t, handler, context);
          });
          return this;
        }
      }
      const handlers = this.has(type);
      if (handlers) {
        if (handler) {
          const fns = handlers.filter((h) => h !== handler);
          this.fns.set(type, fns);
        } else {
          this.fns.delete(type);
        }
      }
      return this;
    }
    emit(type, args) {
      const eventObject = type instanceof Event ? type : new Event(type, args);
      this.validateEventType(eventObject.type);
      const fns = this.has(eventObject.type);
      if (fns) {
        return fns.map((fn) => fn.call(this, eventObject));
      }
    }
    has(type) {
      return this.fns.get(type);
    }
    clear() {
      this.fns.clear();
      return this;
    }
  }

  class Vector {
    elements = new (getFloatArrayConstructor())(2);
    fromArray(array, offset = 0) {
      let i = 0;
      for (; i < this.elements.length; i++) {
        this.elements[i] = array[offset + i];
      }
      return this;
    }
    toArray(out = [], offset = 0) {
      let i = 0;
      for (; i < this.elements.length; i++) {
        out[offset + i] = this.elements[i];
      }
      return out;
    }
  }

  class Vector2 extends Vector {
    elements = new (getFloatArrayConstructor())(2);
    constructor(x = 0, y = 0) {
      super();
      const v = this.elements;
      v[0] = x;
      v[1] = y;
    }
    get x() {
      return this.elements[0];
    }
    set x(x) {
      this.elements[0] = x;
    }
    get y() {
      return this.elements[1];
    }
    set y(y) {
      this.elements[1] = y;
    }
    fromObject(object) {
      const { x, y } = object;
      if (x !== void 0)
        this.x = x;
      if (y !== void 0)
        this.y = y;
      return this;
    }
    toObject() {
      return {
        x: this.x,
        y: this.y
      };
    }
    set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    setScalar(s) {
      return this.set(s, s);
    }
    add(vec) {
      add(this.elements, this.elements, vec.elements);
      return this;
    }
    addScalar(v) {
      add(this.elements, this.elements, [v, v]);
      return this;
    }
    subtract(vec) {
      subtract(this.elements, this.elements, vec.elements);
      return this;
    }
    subtractScalar(v) {
      subtract(this.elements, this.elements, [v, v]);
      return this;
    }
    multiply(vec) {
      multiply(this.elements, this.elements, vec.elements);
      return this;
    }
    multiplyScalar(v) {
      multiply(this.elements, this.elements, [v, v]);
      return this;
    }
    divide(vec) {
      divide(this.elements, this.elements, vec.elements);
      return this;
    }
    divideScalar(v) {
      divide(this.elements, this.elements, [v, v]);
      return this;
    }
    scale(s) {
      scale(this.elements, this.elements, s);
      return this;
    }
    distanceTo(vec) {
      return distance(this.elements, vec.elements);
    }
    length() {
      return length(this.elements);
    }
    distanceToSquared(v) {
      return squaredDistance(v.elements, this.elements);
    }
    angle() {
      return angle(this.elements, [1, 0]);
    }
    angleTo(v) {
      return angle(this.elements, v.elements);
    }
    dot(vec) {
      return dot(this.elements, vec.elements);
    }
    equals(vec) {
      return equals(this.elements, vec.elements);
    }
    cross(vec) {
      cross(this.elements, this.elements, vec.elements);
      return this;
    }
    negate() {
      negate(this.elements, this.elements);
      return this;
    }
    inverse() {
      inverse(this.elements, this.elements);
      return this;
    }
    lerp(vec, t) {
      lerp(this.elements, this.elements, vec.elements, t);
      return this;
    }
    normalize() {
      normalize$1(this.elements, this.elements);
      return this;
    }
    applyMatrix3(matrix) {
      transformMat3(this.elements, this.elements, matrix.elements);
      return this;
    }
    applyMatrix4(matrix) {
      transformMat4(this.elements, this.elements, matrix.elements);
      return this;
    }
    copy(vec2) {
      this.x = vec2.x;
      this.y = vec2.y;
      return this;
    }
    clone() {
      return new Vector2(this.x, this.y);
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  const tempArray$1 = [];
  class Quaternion extends Vector {
    elements = new (getFloatArrayConstructor())(4);
    #changeCallbacks = [];
    constructor(x = 0, y = 0, z = 0, w = 0) {
      super();
      const v = this.elements;
      v[0] = x;
      v[1] = y;
      v[2] = z;
      v[3] = w;
    }
    get x() {
      return this.elements[0];
    }
    set x(x) {
      this.elements[0] = x;
      this.triggerChange();
    }
    get y() {
      return this.elements[1];
    }
    set y(y) {
      this.elements[1] = y;
      this.triggerChange();
    }
    get z() {
      return this.elements[2];
    }
    set z(z) {
      this.elements[2] = z;
      this.triggerChange();
    }
    get w() {
      return this.elements[3];
    }
    set w(w) {
      this.elements[3] = w;
      this.triggerChange();
    }
    fromObject({ x, y, z, w }) {
      if (x !== void 0)
        this.x = x;
      if (y !== void 0)
        this.y = y;
      if (z !== void 0)
        this.z = z;
      if (w !== void 0)
        this.w = w;
      this.triggerChange();
      return this;
    }
    toObject() {
      return {
        x: this.x,
        y: this.y,
        z: this.z,
        w: this.w
      };
    }
    fromAxisAngle(axis, rad) {
      setAxisAngle(this.elements, axis.elements, rad);
      this.triggerChange();
      return this;
    }
    getAxisAngle(axis = new Vector3()) {
      const rad = getAxisAngle(tempArray$1, this.elements);
      axis.set(tempArray$1[0], tempArray$1[1], tempArray$1[2]);
      return rad;
    }
    fromEuler(e) {
      fromEuler(this.elements, radToDeg(e.x), radToDeg(e.y), radToDeg(e.z));
      this.triggerChange();
      return this;
    }
    fromMat3(m) {
      fromMat3(this.elements, m);
      return this;
    }
    set(x, y, z, w) {
      set(this.elements, x, y, z, w);
      this.triggerChange();
      return this;
    }
    length() {
      return length$1(this.elements);
    }
    multiply(a, b) {
      if (b) {
        multiply$1(this.elements, a.elements, b.elements);
      } else {
        multiply$1(this.elements, this.elements, a.elements);
      }
      this.triggerChange();
      return this;
    }
    slerp(q, t) {
      slerp(this.elements, this.elements, q.elements, t);
      this.triggerChange();
      return this;
    }
    invert() {
      invert(this.elements, this.elements);
      this.triggerChange();
      return this;
    }
    conjugate() {
      conjugate(this.elements, this.elements);
      this.triggerChange();
      return this;
    }
    normalize() {
      normalize$2(this.elements, this.elements);
      this.triggerChange();
      return this;
    }
    dot(q) {
      return dot$1(this.elements, q.elements);
    }
    angleTo(q) {
      return getAngle(this.elements, q.elements);
    }
    clone() {
      return new Quaternion().copy(this);
    }
    copy(q) {
      copy(this.elements, q.elements);
      this.triggerChange();
      return this;
    }
    equals(q) {
      return equals$1(this.elements, q.elements);
    }
    onChange(fn) {
      if (!this.#changeCallbacks.includes(fn)) {
        this.#changeCallbacks.push(fn);
      }
    }
    triggerChange() {
      this.#changeCallbacks.forEach((cb) => cb());
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  class Vector3 extends Vector {
    elements = new (getFloatArrayConstructor())(3);
    constructor(x = 0, y = 0, z = 0) {
      super();
      const v = this.elements;
      v[0] = x;
      v[1] = y;
      v[2] = z;
    }
    get x() {
      return this.elements[0];
    }
    set x(x) {
      this.elements[0] = x;
    }
    get y() {
      return this.elements[1];
    }
    set y(y) {
      this.elements[1] = y;
    }
    get z() {
      return this.elements[2];
    }
    set z(z) {
      this.elements[2] = z;
    }
    fromObject(object) {
      const { x, y, z } = object;
      if (x !== void 0)
        this.x = x;
      if (y !== void 0)
        this.y = y;
      if (z !== void 0)
        this.z = z;
      return this;
    }
    toObject() {
      return {
        x: this.x,
        y: this.y,
        z: this.z
      };
    }
    set(x, y, z) {
      set$2(this.elements, x, y, z);
      return this;
    }
    setScalar(s) {
      return this.set(s, s, s);
    }
    length() {
      return length$3(this.elements);
    }
    add(vec) {
      add$2(this.elements, this.elements, vec.elements);
      return this;
    }
    addScalar(v) {
      add$2(this.elements, this.elements, [v, v, v]);
      return this;
    }
    subtract(vec) {
      subtract$2(this.elements, this.elements, vec.elements);
      return this;
    }
    subtractScalar(v) {
      subtract$2(this.elements, this.elements, [v, v, v]);
      return this;
    }
    subVectors(a, b) {
      subtract$2(this.elements, a.elements, b.elements);
      return this;
    }
    multiply(vec) {
      multiply$3(this.elements, this.elements, vec.elements);
      return this;
    }
    multiplyScalar(v) {
      multiply$3(this.elements, this.elements, [v, v, v]);
      return this;
    }
    divide(vec) {
      divide$2(this.elements, this.elements, vec.elements);
      return this;
    }
    divideScalar(v) {
      divide$2(this.elements, this.elements, [v, v, v]);
      return this;
    }
    scale(s) {
      scale$2(this.elements, this.elements, s);
      return this;
    }
    scaleAndAdd(v, s) {
      scaleAndAdd$1(this.elements, this.elements, v.elements, s);
      return this;
    }
    distanceTo(vec) {
      return distance$2(this.elements, vec.elements);
    }
    distanceToSquared(vec) {
      return squaredDistance$2(this.elements, vec.elements);
    }
    angle(vector) {
      return angle$1(this.elements, [1, 0, 0]);
    }
    angleTo(vector) {
      return angle$1(this.elements, vector.elements);
    }
    dot(vec) {
      return dot$3(this.elements, vec.elements);
    }
    equals(vec) {
      return equals$2(this.elements, vec.elements);
    }
    cross(vec) {
      cross$2(this.elements, this.elements, vec.elements);
      return this;
    }
    negate() {
      negate$2(this.elements, this.elements);
      return this;
    }
    inverse() {
      inverse$2(this.elements, this.elements);
      return this;
    }
    lerp(vec, t) {
      lerp$2(this.elements, this.elements, vec.elements, t);
      return this;
    }
    normalize() {
      normalize$4(this.elements, this.elements);
      return this;
    }
    applyEuler(euler) {
      const e = new Quaternion().fromEuler(euler);
      return this.applyQuaternion(e);
    }
    applyMatrix3(matrix) {
      transformMat3$1(this.elements, this.elements, matrix.elements);
      return this;
    }
    applyMatrix4(matrix) {
      transformMat4$2(this.elements, this.elements, matrix.elements);
      return this;
    }
    applyQuaternion(quaternion) {
      transformQuat$1(this.elements, this.elements, quaternion.elements);
      return this;
    }
    copy(vec3) {
      this.x = vec3.x;
      this.y = vec3.y;
      this.z = vec3.z;
      return this;
    }
    clone() {
      return new Vector3(this.x, this.y, this.z);
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  class Vector4 extends Vector {
    elements = new (getFloatArrayConstructor())(4);
    constructor(x = 0, y = 0, z = 0, w = 0) {
      super();
      const v = this.elements;
      v[0] = x;
      v[1] = y;
      v[2] = z;
      v[3] = w;
    }
    get x() {
      return this.elements[0];
    }
    set x(x) {
      this.elements[0] = x;
    }
    get y() {
      return this.elements[1];
    }
    set y(y) {
      this.elements[1] = y;
    }
    get z() {
      return this.elements[2];
    }
    set z(z) {
      this.elements[2] = z;
    }
    get w() {
      return this.elements[3];
    }
    set w(w) {
      this.elements[3] = w;
    }
    fromObject(object) {
      const { x, y, z, w } = object;
      if (x !== void 0)
        this.x = x;
      if (y !== void 0)
        this.y = y;
      if (z !== void 0)
        this.z = z;
      if (w !== void 0)
        this.w = w;
      return this;
    }
    toObject() {
      return {
        x: this.x,
        y: this.y,
        z: this.z,
        w: this.w
      };
    }
    set(x, y, z, w) {
      set$1(this.elements, x, y, z, w);
      return this;
    }
    setScalar(s) {
      return this.set(s, s, s, s);
    }
    add(vec) {
      add$1(this.elements, this.elements, vec.elements);
      return this;
    }
    addScalar(v) {
      add$1(this.elements, this.elements, [v, v, v, v]);
      return this;
    }
    subtract(vec) {
      subtract$1(this.elements, this.elements, vec.elements);
      return this;
    }
    subtractScalar(v) {
      subtract$1(this.elements, this.elements, [v, v, v, v]);
      return this;
    }
    subVectors(a, b) {
      subtract$1(this.elements, a.elements, b.elements);
      return this;
    }
    multiply(vec) {
      multiply$2(this.elements, this.elements, vec.elements);
      return this;
    }
    multiplyScalar(v) {
      multiply$2(this.elements, this.elements, [v, v, v, v]);
      return this;
    }
    divide(vec) {
      divide$1(this.elements, this.elements, vec.elements);
      return this;
    }
    divideScalar(v) {
      divide$1(this.elements, this.elements, [v, v, v, v]);
      return this;
    }
    scale(s) {
      scale$1(this.elements, this.elements, s);
      return this;
    }
    scaleAndAdd(v, s) {
      scaleAndAdd(this.elements, this.elements, v.elements, s);
      return this;
    }
    distanceTo(vec) {
      return distance$1(this.elements, vec.elements);
    }
    distanceToSquared(vec) {
      return squaredDistance$1(this.elements, vec.elements);
    }
    length() {
      return length$2(this.elements);
    }
    dot(vec) {
      return dot$2(this.elements, vec.elements);
    }
    equals(vec) {
      return equals$1(this.elements, vec.elements);
    }
    cross(vec) {
      cross$1(this.elements, this.elements, vec.elements);
      return this;
    }
    negate() {
      negate$1(this.elements, this.elements);
      return this;
    }
    inverse() {
      inverse$1(this.elements, this.elements);
      return this;
    }
    lerp(vec, t) {
      lerp$1(this.elements, this.elements, vec.elements, t);
      return this;
    }
    normalize() {
      normalize$3(this.elements, this.elements);
      return this;
    }
    applyMatrix4(matrix) {
      transformMat4$1(this.elements, this.elements, matrix.elements);
      return this;
    }
    applyQuaternion(quaternion) {
      transformQuat(this.elements, this.elements, quaternion.elements);
      return this;
    }
    copy(vec4) {
      this.x = vec4.x;
      this.y = vec4.y;
      this.z = vec4.z;
      this.w = vec4.w;
      return this;
    }
    clone() {
      return new Vector4(this.x, this.y, this.z, this.w);
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  class Matrix {
    elements = new (getFloatArrayConstructor())(16);
    fromArray(array, offset = 0) {
      let i = 0;
      for (; i < this.elements.length; i++) {
        this.elements[i] = array[offset + i];
      }
      return this;
    }
    toArray(out = [], offset = 0) {
      let i = 0;
      for (; i < this.elements.length; i++) {
        out[offset + i] = this.elements[i];
      }
      return out;
    }
  }

  class Matrix3 extends Matrix {
    elements = new (getFloatArrayConstructor())(9);
    constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {
      super();
      const e = this.elements;
      e[0] = m00;
      e[1] = m01;
      e[2] = m02;
      e[3] = m10;
      e[4] = m11;
      e[5] = m12;
      e[6] = m20;
      e[7] = m21;
      e[8] = m22;
    }
    get x() {
      return this.elements[2];
    }
    get y() {
      return this.elements[5];
    }
    get z() {
      return this.elements[8];
    }
    static get identity() {
      return new Matrix3().fromArray(identity$1([]));
    }
    set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      set$4(this.elements, m00, m01, m02, m10, m11, m12, m20, m21, m22);
      return this;
    }
    transpose() {
      transpose$1(this.elements, this.elements);
      return this;
    }
    invert(m = this) {
      invert$2(this.elements, m.elements);
      return this;
    }
    adjoint(m = this) {
      adjoint$1(this.elements, m.elements);
      return this;
    }
    determinant() {
      return determinant$1(this.elements);
    }
    multiply(a, b) {
      if (b) {
        multiply$5(this.elements, a.elements, b.elements);
      } else {
        multiply$5(this.elements, this.elements, a.elements);
      }
      return this;
    }
    premultiply(a, b) {
      if (b) {
        multiply$5(this.elements, b.elements, a.elements);
      } else {
        multiply$5(this.elements, a.elements, this.elements);
      }
      return this;
    }
    translate(v) {
      translate$1(this.elements, this.elements, v.elements);
      return this;
    }
    rotate(rad) {
      rotate$1(this.elements, this.elements, rad);
      return this;
    }
    scale(v) {
      scale$4(this.elements, this.elements, v.elements);
      return this;
    }
    fromTranslation(v) {
      fromTranslation$1(this.elements, v.elements);
      return this;
    }
    fromRotation(rad) {
      fromRotation$1(this.elements, rad);
      return this;
    }
    fromScaling(v) {
      fromScaling$1(this.elements, v.elements);
      return this;
    }
    fromQuat(q) {
      fromQuat$1(this.elements, q.elements);
      return this;
    }
    normalFromMat4(m) {
      normalFromMat4(this.elements, m.elements);
      return this;
    }
    fromMat4(m) {
      fromMat4(this.elements, m.elements);
      return this;
    }
    frob() {
      return frob(this.elements);
    }
    add(a, b) {
      if (b) {
        add$4(this.elements, a.elements, b.elements);
      } else {
        add$4(this.elements, this.elements, a.elements);
      }
      return this;
    }
    subtract(a, b) {
      if (b) {
        subtract$4(this.elements, a.elements, b.elements);
      } else {
        subtract$4(this.elements, this.elements, a.elements);
      }
      return this;
    }
    equals(a, b) {
      if (b) {
        return equals$4(a.elements, b.elements);
      } else {
        return equals$4(this.elements, a.elements);
      }
    }
    fromRotationTranslationScale(rotation, x, y, scaleX, scaleY) {
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      this.set(scaleX * cos, -scaleY * sin, 0, scaleX * sin, scaleY * cos, 0, x, y, 1);
      return this;
    }
    getNormalMatrix(m) {
      normalFromMat4(this.elements, m.elements);
      return this;
    }
    copy(m) {
      copy$3(this.elements, m.elements);
      return this;
    }
    clone() {
      return new Matrix3().copy(this);
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  const tempArray = [];
  class Matrix4 extends Matrix {
    elements = new (getFloatArrayConstructor())(16);
    constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1) {
      super();
      const e = this.elements;
      e[0] = m00;
      e[1] = m01;
      e[2] = m02;
      e[3] = m03;
      e[4] = m10;
      e[5] = m11;
      e[6] = m12;
      e[7] = m13;
      e[8] = m20;
      e[9] = m21;
      e[10] = m22;
      e[11] = m23;
      e[12] = m30;
      e[13] = m31;
      e[14] = m32;
      e[15] = m33;
    }
    get x() {
      return this.elements[12];
    }
    get y() {
      return this.elements[13];
    }
    get z() {
      return this.elements[14];
    }
    get w() {
      return this.elements[15];
    }
    static get identity() {
      return new Matrix4().fromArray(identity([]));
    }
    set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      set$3(this.elements, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      return this;
    }
    transpose() {
      transpose(this.elements, this.elements);
      return this;
    }
    invert(m = this) {
      invert$1(this.elements, m.elements);
      return this;
    }
    adjoint(m = this) {
      adjoint(this.elements, m.elements);
      return this;
    }
    determinant() {
      return determinant(this.elements);
    }
    add(a, b) {
      if (b) {
        add$3(this.elements, a.elements, b.elements);
      } else {
        add$3(this.elements, this.elements, a.elements);
      }
      return this;
    }
    subtract(a, b) {
      if (b) {
        subtract$3(this.elements, a.elements, b.elements);
      } else {
        subtract$3(this.elements, this.elements, a.elements);
      }
      return this;
    }
    multiply(a, b) {
      if (b) {
        multiply$4(this.elements, a.elements, b.elements);
      } else {
        multiply$4(this.elements, this.elements, a.elements);
      }
      return this;
    }
    multiplyScalar(a = this, b) {
      multiplyScalar(this.elements, a.elements, b);
      return this;
    }
    premultiply(a, b) {
      if (b) {
        multiply$4(this.elements, b.elements, a.elements);
      } else {
        multiply$4(this.elements, a.elements, this.elements);
      }
      return this;
    }
    translate(v) {
      translate(this.elements, this.elements, v.elements);
      return this;
    }
    rotate(rad) {
      rotate(this.elements, this.elements, rad);
      return this;
    }
    scale(vec3) {
      scale$3(this.elements, this.elements, vec3.elements);
      return this;
    }
    scaleScalar(s) {
      scale$3(this.elements, this.elements, [s, s, s]);
      return this;
    }
    fromTranslation(vec) {
      fromTranslation(this.elements, vec.elements);
      return this;
    }
    fromRotation(rad, axis) {
      fromRotation(this.elements, rad, axis);
      return this;
    }
    fromRotationX(rad) {
      fromXRotation(this.elements, rad);
      return this;
    }
    fromRotationY(rad) {
      fromYRotation(this.elements, rad);
      return this;
    }
    fromRotationZ(rad) {
      fromZRotation(this.elements, rad);
      return this;
    }
    fromScale(vec) {
      fromScaling(this.elements, vec.elements);
      return this;
    }
    fromRotationTranslation(quat, v) {
      fromRotationTranslation(this.elements, quat.elements, v.elements);
      return this;
    }
    fromPerspective(fov, aspect, near, far) {
      perspective(this.elements, degToRad(fov), aspect, near, far);
      return this;
    }
    fromOrthogonal(left, right, bottom, top, near, far) {
      ortho(this.elements, left, right, bottom, top, near, far);
      return this;
    }
    fromQuat(q) {
      fromQuat(this.elements, q.elements);
      return this;
    }
    equals(mat4) {
      return equals$3(this.elements, mat4.value);
    }
    getRotation(q = new Quaternion()) {
      getRotation(tempArray, this.elements);
      q.set(tempArray[0], tempArray[1], tempArray[2], tempArray[3]);
      return q;
    }
    getScale(v = new Vector3()) {
      getScaling(tempArray, this.elements);
      v.set(tempArray[0], tempArray[1], tempArray[2]);
      return v;
    }
    getTranslation(v = new Vector3()) {
      getTranslation(tempArray, this.elements);
      v.set(tempArray[0], tempArray[1], tempArray[2]);
      return v;
    }
    rotateX(rad) {
      rotateX(this.elements, this.elements, rad);
      return this;
    }
    rotateY(rad) {
      rotateY(this.elements, this.elements, rad);
      return this;
    }
    rotateZ(rad) {
      rotateZ(this.elements, this.elements, rad);
      return this;
    }
    compose(v, q, s) {
      fromRotationTranslationScale(this.elements, q.elements, v.elements, s.elements);
      return this;
    }
    decompose() {
      return {
        rotation: this.getRotation(),
        scale: this.getScale(),
        translation: this.getTranslation()
      };
    }
    copy(m) {
      copy$2(this.elements, m.elements);
      return this;
    }
    clone() {
      return new Matrix4().copy(this);
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  class Euler extends Vector {
    elements = new (getFloatArrayConstructor())(3);
    #changeCallbacks = [];
    #order = "xyz";
    constructor(x = 0, y = 0, z = 0, order = "xyz") {
      super();
      const v = this.elements;
      v[0] = x;
      v[1] = y;
      v[2] = z;
      this.#order = order;
    }
    get x() {
      return this.elements[0];
    }
    set x(x) {
      this.elements[0] = x;
      this.triggerChange();
    }
    get y() {
      return this.elements[1];
    }
    set y(y) {
      this.elements[1] = y;
      this.triggerChange();
    }
    get z() {
      return this.elements[2];
    }
    set z(z) {
      this.elements[2] = z;
      this.triggerChange();
    }
    get order() {
      return this.#order;
    }
    set order(order) {
      this.#order = order;
      this.triggerChange();
    }
    get roll() {
      return this.x;
    }
    set roll(roll) {
      this.x = roll;
    }
    get pitch() {
      return this.y;
    }
    set pitch(pitch) {
      this.y = pitch;
    }
    get yaw() {
      return this.z;
    }
    set yaw(yaw) {
      this.z = yaw;
    }
    fromObject({ x, y, z, order }) {
      if (x !== void 0) {
        this.x = x;
      }
      if (y !== void 0) {
        this.y = y;
      }
      if (z !== void 0) {
        this.z = z;
      }
      if (order !== void 0) {
        this.order = order;
      }
      this.triggerChange();
      return this;
    }
    toObject() {
      return {
        x: this.x,
        y: this.y,
        z: this.z,
        order: this.order
      };
    }
    fromRotationMatrix(m, order = this.#order, update = true) {
      const te = m.toArray();
      const m11 = te[0];
      const m12 = te[4];
      const m13 = te[8];
      const m21 = te[1];
      const m22 = te[5];
      const m23 = te[9];
      const m31 = te[2];
      const m32 = te[6];
      const m33 = te[10];
      switch (order) {
        case "xyz":
          this.y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this.x = Math.atan2(-m23, m33);
            this.z = Math.atan2(-m12, m11);
          } else {
            this.x = Math.atan2(m32, m22);
            this.z = 0;
          }
          break;
        case "yxz":
          this.x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this.y = Math.atan2(m13, m33);
            this.z = Math.atan2(m21, m22);
          } else {
            this.y = Math.atan2(-m31, m11);
            this.z = 0;
          }
          break;
        case "zxy":
          this.x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this.y = Math.atan2(-m31, m33);
            this.z = Math.atan2(-m12, m22);
          } else {
            this.y = 0;
            this.z = Math.atan2(m21, m11);
          }
          break;
        case "zyx":
          this.y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this.x = Math.atan2(m32, m33);
            this.z = Math.atan2(m21, m11);
          } else {
            this.x = 0;
            this.z = Math.atan2(-m12, m22);
          }
          break;
        case "yzx":
          this.z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this.x = Math.atan2(-m23, m22);
            this.y = Math.atan2(-m31, m11);
          } else {
            this.x = 0;
            this.y = Math.atan2(m13, m33);
          }
          break;
        case "xzy":
          this.z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this.x = Math.atan2(m32, m22);
            this.y = Math.atan2(m13, m11);
          } else {
            this.x = Math.atan2(-m23, m33);
            this.y = 0;
          }
          break;
        default:
          throw new Error("Unknown Euler angle order");
      }
      this.#order = order;
      if (update) {
        this.triggerChange();
      }
      return this;
    }
    fromQuaternion(q) {
      const [x, y, z, w] = q.elements;
      const a = y * y;
      const s = -2 * (a + z * z) + 1;
      const o = 2 * (x * y + w * z);
      let l = -2 * (x * z - w * y);
      const c = 2 * (y * z + w * x);
      const h = -2 * (x * x + a) + 1;
      l = l > 1 ? 1 : l;
      l = l < -1 ? -1 : l;
      const d = Math.atan2(c, h);
      const u = Math.asin(l);
      const f = Math.atan2(o, s);
      return new Euler(d, u, f, "zyx");
    }
    fromVector3(vec3, order = this.#order) {
      return this.set(vec3.x, vec3.y, vec3.z, order);
    }
    toQuaternion() {
      const t = Math.cos(0.5 * this.yaw);
      const e = Math.sin(0.5 * this.yaw);
      const n = Math.cos(0.5 * this.roll);
      const r = Math.sin(0.5 * this.roll);
      const i = Math.cos(0.5 * this.pitch);
      const a = Math.sin(0.5 * this.pitch);
      return new Quaternion(
        t * r * i - e * n * a,
        t * n * a + e * r * i,
        e * n * i - t * r * a,
        t * n * i + e * r * a
      );
    }
    toVector3() {
      return new Vector3(this.x, this.y, this.z);
    }
    set(x, y, z, order = this.#order) {
      this.elements[0] = x;
      this.elements[1] = y;
      this.elements[2] = z;
      this.#order = order;
      this.triggerChange();
      return this;
    }
    clone() {
      return new Euler().copy(this);
    }
    copy(euler) {
      let i = 0;
      for (; i < this.elements.length; i++) {
        this.elements[i] = euler.elements[i];
      }
      this.#order = euler.order;
      this.triggerChange();
      return this;
    }
    equals(e) {
      return this.x === e.x && this.y === e.y && this.z === e.z && this.order === e.order;
    }
    onChange(cb) {
      if (!this.#changeCallbacks.includes(cb)) {
        this.#changeCallbacks.push(cb);
      }
    }
    triggerChange() {
      this.#changeCallbacks.forEach((f) => f());
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return "string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return (r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return {r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return {r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return {h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return {r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return {h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return {h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e;},c=function(r){return {h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u;},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return {h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return [e,t[n][1]]}return [null,void 0]},x=function(r){return "string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=c(r);return {h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return (299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return {h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1};}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i;},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u;},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u;},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r;},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r;},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return "number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t;},r.prototype.hue=function(r){var t=c(this.rgba);return "number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r));});};

  function namesPlugin(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return "transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g);}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"]);}

  k([namesPlugin]);
  const normalize = (a, min, max) => {
    const hex = isHex(a);
    const diff = max - min;
    let v = clamp(Number.parseFloat(`${a}`), min, max);
    if (hex) {
      v = Number.parseInt("" + a * max, 10) / 100;
    }
    return Math.abs(v - max) < 1e-6 ? 1 : a % diff / diff;
  };
  class Color {
    r;
    g;
    b;
    a;
    constructor(v = 255, g, b, a = 1, isNormalized = false) {
      this.r = 1;
      this.g = 1;
      this.b = 1;
      this.a = 1;
      if (isUndef(g) && isUndef(b)) {
        if (isNumber(v) && v <= 255) {
          this.setRGBA(v, v, v, this.a, isNormalized);
        } else {
          const rgb = w(v).toRgb();
          if (rgb) {
            this.setRGBA(rgb.r, rgb.g, rgb.b, rgb.a);
          } else {
            console.error("Unsupported color value {".concat(String(v), "} provided"));
          }
        }
      } else {
        this.setRGBA(v, g, b, a);
      }
    }
    fromColor(c) {
      const color = w(c).toRgb();
      return this.setRGBA(color.r, color.g, color.b, color.a);
    }
    fromHSL(h, s, l, a = 1) {
      const color = w({
        h,
        s,
        l,
        a
      }).toRgb();
      return this.setRGBA(color.r, color.g, color.b, color.a);
    }
    fromHSV(h, s, v, a = 1) {
      const color = w({
        h,
        s,
        v,
        a
      }).toRgb();
      return this.setRGBA(color.r, color.g, color.b, color.a);
    }
    setRGB(r, g, b) {
      this.setRGBA(r, g, b, this.a);
      return this;
    }
    setRGBA(r, g, b, a, isNormalized) {
      this.r = isNormalized ? r : normalize(r, 0, 255);
      this.g = isNormalized ? g : normalize(g, 0, 255);
      this.b = isNormalized ? b : normalize(b, 0, 255);
      this.setAlpha(a);
      return this;
    }
    setAlpha(alpha) {
      if (alpha > 1) {
        this.a = normalize(alpha, 0, 255);
      } else {
        this.a = alpha;
      }
      return this;
    }
    toHex() {
      return w(this.toObject()).toHex();
    }
    toHSL() {
      return w(this.toObject()).toHsl();
    }
    toHSV() {
      return w(this.toObject()).toHsv();
    }
    toObject(isNormalized = false) {
      const m = isNormalized ? 1 : 255;
      return {
        r: this.r * m,
        g: this.g * m,
        b: this.b * m,
        a: this.a
      };
    }
    toArray() {
      return [this.r, this.g, this.b, this.a];
    }
    toVector() {
      return new Vector4().fromArray(this.toArray());
    }
    toVector3() {
      return new Vector3().fromArray(this.toArray());
    }
    toString() {
      return `${this.constructor.name}(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
    }
  }

  class ProjectionMatrix extends Matrix4 {
    frustum(mat4, left, right, top, bottom, near, far) {
      frustum(mat4.elements, left, right, bottom, top, near, far);
      return this;
    }
    orthographic(left, right, top, bottom, near, far) {
      ortho(this.elements, left, right, bottom, top, near, far);
      return this;
    }
    perspective(fovy, aspect, near, far) {
      perspective(this.elements, fovy, aspect, near, far);
      return this;
    }
    lookAt(eye, target = new Vector3(0, 0, 0), up = new Vector3(0, 1, 0)) {
      lookAt(this.elements, eye.elements, target.elements, up.elements);
      return this;
    }
    toString() {
      return `${this.constructor.name}(${this.elements.join(", ")})`;
    }
  }

  class Object3D {
    visible;
    localMatrix;
    worldMatrix;
    matrixAutoUpdate;
    position;
    scale;
    rotation;
    quaternion;
    up;
    children;
    parent;
    worldMatrixNeedsUpdate;
    constructor() {
      this.visible = true;
      this.localMatrix = new ProjectionMatrix();
      this.worldMatrix = new ProjectionMatrix();
      this.matrixAutoUpdate = true;
      this.position = new Vector3();
      this.scale = new Vector3(1, 1, 1);
      this.rotation = new Euler();
      this.quaternion = new Quaternion();
      this.up = new Vector3(0, 1, 0);
      this.parent = null;
      this.children = [];
      this.worldMatrixNeedsUpdate = false;
      this.rotation.onChange(() => {
        this.quaternion.fromEuler(this.rotation);
      });
      this.quaternion.onChange(() => {
        this.rotation.fromQuaternion(this.quaternion);
      });
    }
    add(object, notifyChild = true) {
      if (!this.contains(object)) {
        this.children.push(object);
      }
      if (notifyChild) {
        object.setParent(this, false);
      }
    }
    remove(object, notifyChild = true) {
      if (this.contains(object)) {
        this.children.splice(this.children.indexOf(object), 1);
      }
      if (notifyChild) {
        object.setParent(null, false);
      }
    }
    contains(object) {
      return this.children.includes(object);
    }
    setParent(object, notifyParent = true) {
      if (this.parent && object !== this.parent) {
        this.parent.remove(this, false);
      }
      this.parent = object;
      if (notifyParent && object) {
        object.add(this, false);
      }
    }
    traverse(callback) {
      if (!callback(this)) {
        for (let i = 0, l = this.children.length; i < l; i++) {
          this.children[i].traverse(callback);
        }
      }
    }
    lookAt(eye, invert) {
      if (invert) {
        this.localMatrix.lookAt(this.position, eye, this.up);
      } else {
        this.localMatrix.lookAt(eye, this.position, this.up);
      }
      this.localMatrix.getRotation(this.quaternion);
      this.rotation.fromQuaternion(this.quaternion);
    }
    updateMatrixWorld(force) {
      let f = force;
      if (this.matrixAutoUpdate) {
        this.updateMatrix();
      }
      if (this.worldMatrixNeedsUpdate || f) {
        if (this.parent === null) {
          this.worldMatrix.copy(this.localMatrix);
        } else {
          this.worldMatrix.multiply(this.parent.worldMatrix, this.localMatrix);
        }
        this.worldMatrixNeedsUpdate = false;
        f = true;
      }
      for (let i = 0, l = this.children.length; i < l; i++) {
        const child = this.children[i];
        child.updateMatrixWorld(f);
      }
    }
    updateMatrix() {
      this.localMatrix.compose(this.position, this.quaternion, this.scale);
      this.worldMatrixNeedsUpdate = true;
    }
    decompose() {
      this.localMatrix.getTranslation(this.position);
      this.localMatrix.getRotation(this.quaternion);
      this.localMatrix.getScale(this.scale);
      this.rotation.fromQuaternion(this.quaternion);
    }
    clone() {
      return new Object3D().copy(this, false);
    }
    copy(object, recursive) {
      this.visible = object.visible;
      this.position.copy(object.position);
      this.scale.copy(object.scale);
      this.rotation.copy(object.rotation);
      this.quaternion.copy(object.quaternion);
      this.up.copy(object.up);
      this.localMatrix.copy(object.localMatrix);
      this.worldMatrix.copy(object.worldMatrix);
      this.matrixAutoUpdate = object.matrixAutoUpdate;
      if (recursive) {
        for (let i = 0, n = object.children.length; i < n; i++) {
          const children = object.children[i];
          this.add(children.clone());
        }
      }
      return this;
    }
  }

  class Base {
    renderer;
    constructor(renderer) {
      this.renderer = renderer;
    }
    get gl() {
      return this.renderer.gl;
    }
    get rendererState() {
      return this.renderer.state;
    }
  }

  const getBufferType = (gl, data) => {
    if (data instanceof Float32Array || data instanceof Float64Array) {
      return gl.FLOAT;
    }
    if (data instanceof Uint16Array) {
      return gl.UNSIGNED_SHORT;
    }
    if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
      return gl.UNSIGNED_BYTE;
    }
    if (data instanceof Uint32Array) {
      return gl.UNSIGNED_INT;
    }
    if (data instanceof Int8Array) {
      return gl.BYTE;
    }
    if (data instanceof Int16Array) {
      return gl.SHORT;
    }
    if (data instanceof Int32Array) {
      return gl.INT;
    }
  };
  class BufferAttribute {
    id;
    data;
    type;
    size;
    instanced;
    stride;
    offset;
    divisor;
    normalized;
    needsUpdate;
    count;
    usage;
    target;
    buffer;
    constructor(renderer, attribute) {
      const attr = Object.assign(
        {},
        {
          size: 1,
          normalized: true,
          stride: 0,
          offset: 0,
          divisor: 0,
          usage: renderer.gl.STATIC_DRAW
        },
        attribute
      );
      this.id = uid("attribute");
      this.needsUpdate = false;
      if (!attribute.data || Array.isArray(attribute.data)) {
        throw new TypeError("BufferAttribute: data should be a typed array");
      }
      this.data = attr.data;
      this.size = attr.size || 1;
      this.type = attr.type || getBufferType(renderer.gl, attr.data);
      this.normalized = attr.normalized || false;
      this.stride = attr.stride || 0;
      this.offset = attr.offset || 0;
      this.divisor = attr.divisor || 0;
      this.instanced = attr.divisor > 0;
      this.usage = attr.usage || renderer.gl.STATIC_DRAW;
      if (attr.target) {
        this.target = attr.target;
      }
      let count = attr.count;
      if (attr.count === void 0 || attr.count === null) {
        count = attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size;
      }
      this.count = count;
    }
  }

  const tempVec3 = new Vector3();
  class Geometry extends Base {
    #id;
    #attributes;
    #VAOs;
    #bounds;
    drawRange;
    instancedCount;
    isInstanced;
    drawMode;
    constructor(renderer, attributes = {}) {
      super(renderer);
      this.drawRange = {
        start: 0,
        count: 0
      };
      this.instancedCount = 0;
      this.isInstanced = false;
      this.#attributes = /* @__PURE__ */ new Map();
      this.#VAOs = /* @__PURE__ */ new Map();
      this.#id = uid("geometry");
      this.drawMode = this.gl.TRIANGLES;
      renderer.bindVertexArray(null);
      renderer.state.setActiveGeometry(null);
      for (const name in attributes) {
        const attribute = attributes[name];
        if (attribute instanceof BufferAttribute) {
          if (name === "index") {
            this.setIndex(attribute);
          } else {
            this.addAttribute(name, attribute);
          }
        } else {
          if (attribute.data) {
            const n = new BufferAttribute(this.renderer, attribute);
            if (name === "index") {
              this.setIndex(n);
            } else {
              this.addAttribute(name, n);
            }
          }
        }
      }
    }
    get id() {
      return this.#id;
    }
    get attributes() {
      return this.#attributes;
    }
    get attributesData() {
      const attributes = {};
      const iterator = this.#attributes.entries();
      for (let i = 0; i < this.#attributes.size; i++) {
        const entry = iterator.next().value;
        attributes[entry[0]] = omit(entry[1], [
          "id",
          "buffer"
        ]);
      }
      return attributes;
    }
    get index() {
      return this.attributes.get("index");
    }
    get bounds() {
      return this.#bounds;
    }
    set bounds(bounds) {
      this.#bounds = bounds;
    }
    addAttribute(name, attribute) {
      if (!attribute.target) {
        attribute.target = name === "index" ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;
      }
      attribute.needsUpdate = false;
      this.attributes.set(name, attribute);
      if (!attribute.buffer) {
        attribute.buffer = this.gl.createBuffer();
        this.updateAttribute(attribute);
      }
      if (attribute.divisor) {
        this.isInstanced = true;
        if (this.instancedCount && this.instancedCount !== attribute.count * attribute.divisor) {
          this.instancedCount = Math.min(this.instancedCount, attribute.count * attribute.divisor);
          return console.warn(
            `Geometry has multiple instanced buffers of different length - instancedCount: ${this.instancedCount}, count: ${attribute.count}, divisor: ${attribute.divisor}, attribute: ${name}`
          );
        }
        this.instancedCount = attribute.count * attribute.divisor;
      } else if (name === "index") {
        this.drawRange.count = attribute.count;
      } else if (!this.index) {
        this.drawRange.count = Math.max(this.drawRange.count, attribute.count);
      }
    }
    getAttribute(name) {
      return this.attributes.get(name);
    }
    setAttributeData(name, data) {
      const attribute = this.getAttribute(name);
      if (attribute) {
        attribute.data = data;
        attribute.needsUpdate = true;
      }
    }
    updateAttribute(attribute) {
      const createBuffer = !attribute.buffer;
      if (createBuffer) {
        attribute.buffer = this.gl.createBuffer();
      }
      if (this.rendererState.boundBuffer !== attribute.buffer) {
        this.gl.bindBuffer(attribute.target, attribute.buffer);
        this.rendererState.boundBuffer = attribute.buffer;
      }
      this.gl.bufferData(attribute.target, attribute.data, attribute.usage);
      attribute.needsUpdate = false;
    }
    removeAttribute(attribute) {
      this.attributes.delete(attribute);
    }
    setIndex(index) {
      if (index instanceof BufferAttribute) {
        index.size = 1;
        this.addAttribute("index", index);
      } else {
        const buffer = new BufferAttribute(this.renderer, {
          data: index.length > 65535 ? new Uint32Array(index) : new Uint16Array(index),
          size: 1
        });
        this.addAttribute("index", buffer);
      }
      this.drawRange.count = this.index?.count;
    }
    setVertices(data) {
      const array = [];
      const len = data.length;
      for (let i = 0; i < len; i++) {
        const item = data[i];
        array.push(item[0], item[1], item[2]);
      }
      this.addAttribute(
        "position",
        new BufferAttribute(this.renderer, {
          data: new Float32Array(array),
          size: 3
        })
      );
    }
    setNormals(data) {
      this.addAttribute(
        "normal",
        new BufferAttribute(this.renderer, {
          data: new Float32Array(data),
          size: 2
        })
      );
    }
    setUVs(data) {
      this.addAttribute(
        "uv",
        new BufferAttribute(this.renderer, {
          data: new Float32Array(data),
          size: 2
        })
      );
    }
    setColors(colors) {
      const data = [];
      for (let i = 0; i < colors.length; i++) {
        let color = colors[i];
        if (color && (color instanceof Vector3 || color instanceof Vector4)) {
          color = color.toArray();
        }
        data.push(color[0], color[1], color[2], color[3] || 1);
      }
      this.addAttribute(
        "color",
        new BufferAttribute(this.renderer, {
          data: new Float32Array(data),
          size: 4
        })
      );
    }
    setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
    setInstancedCount(count) {
      this.instancedCount = count;
    }
    createVAO(program) {
      const { attributeOrder } = program;
      const vao = this.renderer.createVertexArray();
      this.renderer.bindVertexArray(vao);
      this.#VAOs.set(attributeOrder, vao);
      this.bindAttributes(program);
    }
    bindAttributes(program) {
      program.attributeLocations.forEach((location, { name, type }) => {
        const attributes = this.attributes.get(name);
        if (!attributes)
          return;
        this.gl.bindBuffer(attributes.target, attributes.buffer);
        this.rendererState.boundBuffer = attributes.buffer;
        let numLoc = 1;
        if (type === this.gl.FLOAT_MAT2)
          numLoc = 2;
        if (type === this.gl.FLOAT_MAT3)
          numLoc = 3;
        if (type === this.gl.FLOAT_MAT4)
          numLoc = 4;
        const size = attributes.size / numLoc;
        const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;
        const offset = numLoc === 1 ? 0 : numLoc * numLoc;
        for (let i = 0; i < numLoc; i++) {
          const attribIndex = location + i;
          this.gl.vertexAttribPointer(
            attribIndex,
            size,
            attributes.type,
            attributes.normalized,
            attributes.stride + stride,
            attributes.offset + offset
          );
          this.gl.enableVertexAttribArray(attribIndex);
          this.renderer.vertexAttribDivisor(attribIndex, attributes.divisor);
        }
      });
      const index = this.attributes.get("index");
      if (index) {
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, index.buffer);
      }
    }
    computeBoundingBox(vertices) {
      const { data, offset = 0, stride, size } = this.attributes.get("position");
      if (!this.#bounds) {
        this.#bounds = {
          min: new Vector3(),
          max: new Vector3(),
          center: new Vector3(),
          scale: new Vector3(),
          radius: Number.POSITIVE_INFINITY
        };
      }
      this.#bounds.min.setScalar(+Number.POSITIVE_INFINITY);
      this.#bounds.max.setScalar(Number.NEGATIVE_INFINITY);
      const array = vertices || data;
      const dl = stride || size;
      for (let i = offset; i < array.length; i += dl) {
        const x = array[i + 0];
        const y = array[i + 1];
        const z = array[i + 2];
        this.#bounds.min.x = Math.min(x, this.#bounds.min.x);
        this.#bounds.min.y = Math.min(y, this.#bounds.min.y);
        this.#bounds.min.z = Math.min(z, this.#bounds.min.z);
        this.#bounds.max.x = Math.max(x, this.#bounds.max.x);
        this.#bounds.max.y = Math.max(y, this.#bounds.max.y);
        this.#bounds.max.z = Math.max(z, this.#bounds.max.z);
      }
      this.#bounds.scale.subVectors(this.#bounds.max, this.#bounds.min);
      this.#bounds.center.add(this.#bounds.min).add(this.#bounds.max).divideScalar(2);
      return this.#bounds;
    }
    computeBoundingSphere(vertices) {
      const { data, offset = 0, stride, size } = this.attributes.get("position");
      if (!this.#bounds) {
        this.computeBoundingBox(vertices);
      }
      const array = vertices || data;
      let len = 0;
      const dl = stride || size;
      const length = array.length;
      for (let j = offset; j < length; j += dl) {
        tempVec3.fromArray(array, j);
        len = Math.max(len, this.#bounds.center.distanceToSquared(tempVec3));
      }
      this.#bounds.radius = Math.sqrt(len);
    }
    draw(program, drawMode = this.drawMode) {
      const { start, count } = this.drawRange;
      const activeGeometryId = `${this.id}_${program.attributeOrder}`;
      if (this.rendererState.activeGeometryId !== activeGeometryId) {
        const vao = this.#VAOs.get(program.attributeOrder);
        if (!vao) {
          this.createVAO(program);
        }
        this.renderer.bindVertexArray(this.#VAOs.get(program.attributeOrder));
        this.rendererState.activeGeometryId = activeGeometryId;
      }
      program.attributeLocations.forEach((location, { name }) => {
        const attribute = this.getAttribute(name);
        if (attribute && attribute.needsUpdate) {
          this.updateAttribute(attribute);
        }
      });
      if (this.isInstanced) {
        if (this.index) {
          const offset = this.index.offset + 2 * start;
          this.renderer.drawElementsInstanced(
            drawMode,
            count,
            this.index.type,
            offset,
            this.instancedCount
          );
        } else {
          this.renderer.drawArraysInstanced(drawMode, start, count, this.instancedCount);
        }
      } else if (this.index) {
        const offset = this.index.offset + 2 * start;
        this.gl.drawElements(drawMode, count, this.index.type, offset);
      } else {
        this.gl.drawArrays(drawMode, start, count);
      }
    }
    copy(source) {
      const attributes = source.attributesData;
      for (const name in attributes) {
        const attribute = attributes[name];
        if (attribute instanceof BufferAttribute) {
          if (name === "index") {
            this.setIndex(attribute);
          } else {
            this.addAttribute(name, attribute);
          }
        } else {
          if (attribute.data) {
            const n = new BufferAttribute(this.renderer, attribute);
            if (name === "index") {
              this.setIndex(n);
            } else {
              this.addAttribute(name, n);
            }
          }
        }
      }
      if (source.bounds) {
        this.bounds = {
          min: new Vector3().copy(source.bounds.min),
          max: new Vector3().copy(source.bounds.max),
          center: new Vector3().copy(source.bounds.center),
          scale: new Vector3().copy(source.bounds.scale),
          radius: source.bounds.radius
        };
      }
      return this;
    }
    clone() {
      const geometry = new Geometry(this.renderer, {}).copy(this);
      geometry.drawMode = this.drawMode;
      return geometry;
    }
    destroy() {
      this.#VAOs.forEach((t) => {
        this.renderer.deleteVertexArray(t);
      });
      this.#VAOs.clear();
      this.#attributes.forEach((t) => {
        this.gl.deleteBuffer(t.buffer);
      });
      this.#attributes.clear();
    }
  }

  class Mesh extends Object3D {
    gl;
    modelViewMatrix;
    normalMatrix;
    renderOrder;
    zDepth;
    frustumCulled;
    mode;
    renderer;
    #id;
    #lastMode;
    #geometry;
    #program;
    #wireframe;
    #wireframeGeometry;
    constructor(renderer, options = {}) {
      super();
      const opts = Object.assign({}, {
        mode: renderer.gl.TRIANGLES,
        frustumCulled: true,
        renderOrder: 0
      }, options);
      this.renderer = renderer;
      this.gl = this.renderer.gl;
      this.modelViewMatrix = new Matrix4();
      this.normalMatrix = new Matrix3();
      this.renderOrder = opts.renderOrder;
      this.frustumCulled = opts.frustumCulled;
      this.zDepth = 0;
      this.#id = opts.id || uid("mesh");
      this.#geometry = opts.geometry;
      this.#program = opts.program;
      this.#wireframe = Boolean(opts.wireframe);
      this.mode = opts.mode;
      this.#lastMode = opts.mode;
      if (this.#wireframe) {
        this.mode = this.gl.LINES;
        this.updateWireframeGeometry(this.#wireframe);
      }
    }
    get id() {
      return this.#id;
    }
    get geometry() {
      return this.#wireframe ? this.#wireframeGeometry : this.#geometry;
    }
    get program() {
      return this.#program;
    }
    set wireframe(wireframe) {
      this.mode = wireframe ? this.gl.LINES : this.#lastMode;
      this.#wireframe = wireframe;
      this.updateWireframeGeometry(this.#wireframe);
    }
    get wireframe() {
      return this.#wireframe;
    }
    draw(options = {}) {
      const { camera, target } = options;
      const uniforms = {};
      if (camera) {
        Object.assign(uniforms, {
          projectionMatrix: camera.projectionMatrix,
          cameraPosition: camera.worldPosition,
          viewMatrix: camera.viewMatrix
        });
        this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);
        this.normalMatrix.getNormalMatrix(this.modelViewMatrix);
      } else {
        this.modelViewMatrix.copy(this.worldMatrix);
      }
      Object.assign(uniforms, {
        resolution: new Vector2(
          this.renderer.state?.viewport?.width || 1,
          this.renderer.state?.viewport?.height || 1
        ),
        modelMatrix: this.worldMatrix,
        modelViewMatrix: this.modelViewMatrix,
        normalMatrix: this.normalMatrix
      });
      Object.keys(uniforms).forEach((key) => {
        if (!Object.hasOwn(this.program.uniforms, key)) {
          this.program.uniforms[key] = { value: null };
        }
        this.program.uniforms[key].value = uniforms[key];
      });
      if (target)
        target.bind();
      this.program.use();
      this.geometry.draw(this.program, this.mode);
      if (target)
        target.unbind();
    }
    updateWireframeGeometry(wireframe, force = false) {
      if (this.#geometry && (force || !this.#wireframeGeometry)) {
        if (this.#wireframeGeometry) {
          this.#wireframeGeometry.destroy();
        }
        const attributes = this.#geometry.attributes;
        const positionArray = attributes.get("position")?.data;
        const indexAttribute = this.#geometry.index?.data;
        const numIndices = indexAttribute ? indexAttribute.length : Math.floor(positionArray.length / 3);
        const index = [];
        if (this.#geometry.index) {
          if (indexAttribute) {
            getWireframeIndex(positionArray, index, numIndices, indexAttribute);
          }
        } else {
          getWireframeIndex(positionArray, index, numIndices);
        }
        const indices = index.length > 65536 ? new Uint32Array(index) : new Uint16Array(index);
        this.#wireframeGeometry = new Geometry(this.renderer, {
          ...this.#geometry.attributesData,
          index: {
            data: indices
          }
        });
      }
    }
    updateGeometry(geometry, destroy = true) {
      if (destroy && this.#geometry) {
        this.#geometry.destroy();
      }
      this.#geometry = geometry;
      this.updateWireframeGeometry(this.#wireframe, true);
    }
    updateProgram(program, destroy = true) {
      if (destroy && this.#program) {
        this.#program.destroy();
      }
      this.#program = program;
    }
    destroy() {
      this.program.destroy();
      this.geometry.destroy();
    }
    clone() {
      return new Mesh(this.gl, {
        geometry: this.geometry,
        program: this.program,
        frustumCulled: this.frustumCulled,
        mode: this.mode,
        renderOrder: this.renderOrder
      }).copy(this);
    }
    copy(mesh, recursive = true) {
      super.copy(mesh, recursive);
      this.modelViewMatrix.copy(mesh.modelViewMatrix);
      this.normalMatrix.copy(mesh.normalMatrix);
      this.mode = mesh.mode;
      this.renderOrder = mesh.renderOrder;
      this.zDepth = mesh.zDepth;
      return this;
    }
  }

  class Scene extends Object3D {
    clone() {
      return new Scene().copy(this, false);
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
  }

  var BlendType = /* @__PURE__ */ ((BlendType2) => {
    BlendType2[BlendType2["NoBlending"] = 0] = "NoBlending";
    BlendType2[BlendType2["NormalBlending"] = 1] = "NormalBlending";
    BlendType2[BlendType2["AdditiveBlending"] = 2] = "AdditiveBlending";
    BlendType2[BlendType2["SubtractiveBlending"] = 3] = "SubtractiveBlending";
    BlendType2[BlendType2["MultiplyBlending"] = 4] = "MultiplyBlending";
    BlendType2[BlendType2["CustomBlending"] = 5] = "CustomBlending";
    return BlendType2;
  })(BlendType || {});
  class State extends Base {
    #state;
    constructor(renderer, options) {
      super(renderer);
      const { gl } = renderer;
      this.#state = {
        viewport: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      };
      this.apply(
        options || {
          frontFace: gl.CCW,
          depthTest: false,
          depthWrite: true,
          depthMask: true,
          depthFunc: gl.LESS,
          blending: 1 /* NormalBlending */,
          blendFunc: {
            src: gl.ONE,
            dst: gl.ZERO
          },
          blendEquation: {
            modeRGB: gl.FUNC_ADD
          },
          premultiplyAlpha: false,
          unpackAlignment: 4,
          flipY: false,
          framebuffer: null,
          textureUnits: [],
          activeTextureUnit: -1,
          activeGeometryId: -1,
          currentProgramId: -1,
          clearAlpha: 1,
          clearColor: new Color(0),
          stencil: {
            func: {},
            opFront: {},
            opBack: {}
          }
        }
      );
    }
    get state() {
      return this.#state;
    }
    get viewport() {
      return this.#state.viewport;
    }
    get textureUnits() {
      return this.#state.textureUnits;
    }
    get activeTextureUnit() {
      return this.#state.activeTextureUnit;
    }
    set activeTextureUnit(activeTextureUnit) {
      this.#state.activeTextureUnit = activeTextureUnit;
    }
    get currentProgramId() {
      return this.#state.currentProgramId;
    }
    set currentProgramId(id) {
      this.#state.currentProgramId = id;
    }
    get activeGeometryId() {
      return this.#state.activeGeometryId;
    }
    set activeGeometryId(id) {
      this.#state.activeGeometryId = id;
    }
    set flipY(flipY) {
      this.#state.flipY = flipY;
    }
    get flipY() {
      return this.#state.flipY;
    }
    set unpackAlignment(unpackAlignment) {
      this.#state.unpackAlignment = unpackAlignment;
    }
    get unpackAlignment() {
      return this.#state.unpackAlignment;
    }
    set premultiplyAlpha(premultiplyAlpha) {
      this.#state.premultiplyAlpha = premultiplyAlpha;
    }
    get premultiplyAlpha() {
      return this.#state.premultiplyAlpha;
    }
    set boundBuffer(boundBuffer) {
      this.#state.boundBuffer = boundBuffer;
    }
    get boundBuffer() {
      return this.#state.boundBuffer;
    }
    set anisotropy(anisotropy) {
      this.#state.anisotropy = anisotropy;
    }
    get anisotropy() {
      return this.#state.anisotropy;
    }
    apply(options) {
      if (options.blending !== void 0 && options.blending !== null) {
        this.setBlending(options.blending, options);
      } else {
        if (options.blendFunc) {
          const { src, dst, srcAlpha, dstAlpha } = options.blendFunc;
          this.setBlendFunc(src, dst, srcAlpha, dstAlpha);
          this.enable(this.gl.BLEND);
        } else {
          this.disable(this.gl.BLEND);
        }
        if (options.blendEquation) {
          const { modeRGB, modeAlpha } = options.blendEquation;
          this.setBlendEquation(modeRGB, modeAlpha);
        }
      }
      if (!isUndef(options.cullFace) && !isNull(options.cullFace)) {
        this.setCullFace(options.cullFace);
      }
      if (!isUndef(options.frontFace) && !isNull(options.frontFace)) {
        this.setFrontFace(options.frontFace);
      }
      if (options.depthTest) {
        this.enable(this.gl.DEPTH_TEST);
      } else {
        this.disable(this.gl.DEPTH_TEST);
      }
      if (!isUndef(options.depthMask) && !isNull(options.depthMask)) {
        this.setDepthMask(options.depthMask);
      }
      if (!isUndef(options.depthWrite) && !isNull(options.depthWrite)) {
        this.setDepthMask(options.depthWrite);
      }
      if (!isUndef(options.depthFunc) && !isNull(options.depthFunc)) {
        this.setDepthFunc(options.depthFunc);
      }
      if (!isUndef(options.lineWidth) && !isNull(options.lineWidth)) {
        this.setLineWidth(options.lineWidth);
      }
      this.#state = Object.assign(this.#state, options);
    }
    enable(id) {
      if (this.#state[id] !== true) {
        this.gl.enable(id);
        this.#state[id] = true;
      }
    }
    disable(id) {
      if (this.#state[id] !== false) {
        this.gl.disable(id);
        this.#state[id] = false;
      }
    }
    setViewport(width, height, x = 0, y = 0) {
      if (this.#state.viewport.width === width && this.#state.viewport.height === height)
        return;
      this.gl.viewport(x, y, width, height);
      this.#state.viewport = {
        width,
        height,
        x,
        y
      };
    }
    setMask(colorMask) {
      if (this.#state.colorMask !== colorMask) {
        this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
        this.#state.colorMask = colorMask;
      }
    }
    setBlending(blending, options) {
      this.#state.blending = blending;
      if (blending === 0 /* NoBlending */) {
        this.disable(this.gl.BLEND);
        return;
      } else {
        this.enable(this.gl.BLEND);
      }
      if (blending === 2 /* AdditiveBlending */) {
        if (this.#state.premultiplyAlpha) {
          this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
          this.setBlendFunc(this.gl.ONE, this.gl.ONE, this.gl.ONE, this.gl.ONE);
        } else {
          this.setBlendEquation(this.gl.FUNC_ADD);
          this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
        }
      } else if (blending === 3 /* SubtractiveBlending */) {
        if (this.#state.premultiplyAlpha) {
          this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
          this.setBlendFunc(
            this.gl.ZERO,
            this.gl.ZERO,
            this.gl.ONE_MINUS_SRC_COLOR,
            this.gl.ONE_MINUS_SRC_ALPHA
          );
        } else {
          this.setBlendEquation(this.gl.FUNC_ADD);
          this.setBlendFunc(this.gl.ZERO, this.gl.ONE_MINUS_SRC_COLOR);
        }
      } else if (blending === 4 /* MultiplyBlending */) {
        if (this.#state.premultiplyAlpha) {
          this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
          this.setBlendFunc(this.gl.ZERO, this.gl.SRC_COLOR, this.gl.ZERO, this.gl.SRC_ALPHA);
        } else {
          this.setBlendEquation(this.gl.FUNC_ADD);
          this.setBlendFunc(this.gl.ZERO, this.gl.SRC_COLOR);
        }
      } else if (blending === 1 /* NormalBlending */) {
        if (this.#state.premultiplyAlpha) {
          this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
          this.setBlendFunc(
            this.gl.ONE,
            this.gl.ONE_MINUS_SRC_ALPHA,
            this.gl.ONE,
            this.gl.ONE_MINUS_SRC_ALPHA
          );
        } else {
          this.setBlendEquation(this.gl.FUNC_ADD, this.gl.FUNC_ADD);
          this.setBlendFunc(
            this.gl.SRC_ALPHA,
            this.gl.ONE_MINUS_SRC_ALPHA,
            this.gl.ONE,
            this.gl.ONE_MINUS_SRC_ALPHA
          );
        }
      } else if (blending === 5 /* CustomBlending */) {
        if (options?.blendFunc) {
          const { src, dst, srcAlpha, dstAlpha } = options.blendFunc;
          this.setBlendFunc(src, dst, srcAlpha, dstAlpha);
          this.enable(this.gl.BLEND);
        }
        if (options?.blendEquation) {
          const { modeRGB, modeAlpha } = options.blendEquation;
          this.setBlendEquation(modeRGB, modeAlpha);
        }
      } else {
        console.error("State: Invalid blending: ", blending);
      }
    }
    setBlendFunc(src, dst, srcAlpha, dstAlpha) {
      if (src !== this.#state.blendFunc?.src || dst !== this.#state.blendFunc?.dst || srcAlpha !== this.#state.blendFunc?.srcAlpha || dstAlpha !== this.#state.blendFunc?.dstAlpha) {
        this.#state.blendFunc = {
          src,
          dst,
          srcAlpha,
          dstAlpha
        };
        if (!isUndef(srcAlpha) && !isNull(srcAlpha) && !isUndef(dstAlpha) && !isNull(dstAlpha)) {
          this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);
        } else {
          this.gl.blendFunc(src, dst);
        }
      }
    }
    setBlendEquation(modeRGB, modeAlpha) {
      if (modeRGB !== this.#state.blendEquation?.modeRGB || modeAlpha !== this.#state.blendEquation?.modeAlpha) {
        this.#state.blendEquation = {
          modeRGB,
          modeAlpha
        };
        if (!isUndef(modeAlpha) && !isNull(modeAlpha)) {
          this.gl.blendEquationSeparate(modeRGB, modeAlpha);
        } else {
          this.gl.blendEquation(modeRGB);
        }
      }
    }
    setClearAlpha(alpha) {
      if (this.#state.clearAlpha !== alpha) {
        this.#state.clearAlpha = alpha;
      }
    }
    setClearColor(color, alpha) {
      if (this.#state.clearAlpha !== alpha || this.#state.clearColor !== color) {
        this.#state.clearColor = color;
        if (!isUndef(alpha) && !isNull(alpha)) {
          this.#state.clearAlpha = alpha;
        } else {
          this.#state.clearAlpha = color.a;
        }
        this.gl.clearColor(color.r, color.g, color.b, this.#state.clearAlpha);
      }
    }
    setCullFace(cullFace) {
      if (this.#state.cullFace !== cullFace) {
        if (cullFace) {
          this.gl.enable(this.gl.CULL_FACE);
        } else {
          this.gl.disable(this.gl.CULL_FACE);
        }
        this.#state.cullFace = cullFace;
        this.gl.cullFace(cullFace);
      }
    }
    setFrontFace(frontFace) {
      if (this.#state.frontFace !== frontFace) {
        this.#state.frontFace = frontFace;
        this.gl.frontFace(frontFace);
      }
    }
    setDepthMask(mask) {
      if (this.#state.depthMask !== mask) {
        this.#state.depthMask = mask;
        this.gl.depthMask(mask);
      }
    }
    setDepthFunc(func) {
      if (this.#state.depthFunc !== func) {
        this.#state.depthFunc = func;
        this.gl.depthFunc(func);
      }
    }
    setDepthTest(state) {
      if (this.#state.depthTest !== state) {
        this.#state.depthTest = state;
        if (state) {
          this.enable(this.gl.DEPTH_TEST);
        } else {
          this.disable(this.gl.DEPTH_TEST);
        }
      }
    }
    setStencilFunc(cmp, ref, mask, face) {
      if (this.#state?.stencil?.func?.cmp !== cmp || this.#state?.stencil?.func?.ref !== ref || this.#state?.stencil?.func?.mask !== mask) {
        if (!this.#state?.stencil) {
          this.#state.stencil = {};
        }
        if (!this.#state?.stencil?.func) {
          this.#state.stencil.func = {};
        }
        this.#state.stencil.func = {
          ref,
          mask,
          cmp
        };
        if (face) {
          this.gl.stencilFuncSeparate(face, cmp, ref, mask);
        } else {
          this.gl.stencilFunc(cmp, ref, mask);
        }
      }
    }
    setStencilOp(fail, zFail, zPass, face) {
      if (!this.#state?.stencil) {
        this.#state.stencil = {};
      }
      if (!face || face === this.gl.FRONT_AND_BACK) {
        return this.#state.stencil?.opFront?.fail !== fail || this.#state.stencil?.opFront?.zFail !== zFail || this.#state.stencil?.opFront?.zPass !== zPass || this.#state.stencil?.opBack?.fail !== fail || this.#state.stencil?.opBack?.zFail !== zFail || this.#state.stencil?.opBack?.zPass !== zPass;
      } else if (face === this.gl.FRONT) {
        return this.#state.stencil?.opFront?.fail !== fail || this.#state.stencil?.opFront?.zFail !== zFail || this.#state.stencil?.opFront?.zPass !== zPass;
      } else if (face === this.gl.BACK) {
        return this.#state.stencil?.opBack?.fail !== fail || this.#state.stencil?.opBack?.zFail !== zFail || this.#state.stencil?.opBack?.zPass !== zPass;
      }
    }
    setStencilMask(mask, face) {
      if (this.#state.stencil?.mask !== mask) {
        this.#state.stencil = {
          ...this.#state.stencil,
          mask
        };
        if (face) {
          this.gl.stencilMaskSeparate(face, mask);
        } else {
          this.gl.stencilMask(mask);
        }
      }
    }
    setActiveTexture(unit) {
      if (this.#state.activeTextureUnit !== unit) {
        this.#state.activeTextureUnit = unit;
        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
      }
    }
    setLineWidth(width) {
      if (this.#state.lineWidth !== width) {
        this.#state.lineWidth = width;
        this.gl.lineWidth(width);
      }
    }
    setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        this.enable(this.gl.POLYGON_OFFSET_FILL);
        if (this.#state.polygonOffsetFactor !== factor || this.#state.polygonOffsetUnits !== units) {
          this.gl.polygonOffset(factor, units);
          this.#state.polygonOffsetFactor = factor;
          this.#state.polygonOffsetUnits = units;
        }
      } else {
        this.disable(this.gl.POLYGON_OFFSET_FILL);
      }
    }
    bindFramebuffer(v = {}) {
      const { target = this.gl.FRAMEBUFFER, buffer = null } = v;
      if (this.#state.framebuffer !== buffer) {
        this.#state.framebuffer = buffer;
        this.gl.bindFramebuffer(target, buffer);
      }
    }
    setActiveGeometry(id) {
      this.#state.activeGeometryId = id;
    }
    reset(force = true) {
      const keys = Object.keys(this.#state);
      if (force) {
        keys.filter((key) => ["viewport", "premultiplyAlpha"].indexOf(key) < 0).forEach((key) => {
          delete this.#state[key];
        });
        this.bindFramebuffer({
          buffer: null
        });
        this.apply({
          frontFace: this.gl.CCW,
          depthTest: false,
          depthWrite: true,
          depthMask: true,
          depthFunc: this.gl.LESS,
          blending: 1 /* NormalBlending */,
          blendFunc: {
            src: this.gl.ONE,
            dst: this.gl.ZERO
          },
          blendEquation: {
            modeRGB: this.gl.FUNC_ADD
          },
          premultiplyAlpha: false,
          unpackAlignment: 4,
          flipY: false,
          framebuffer: null,
          textureUnits: [],
          activeTextureUnit: -1,
          activeGeometryId: -1,
          currentProgramId: -1,
          clearAlpha: 1,
          clearColor: new Color(0),
          stencil: {
            func: {},
            opFront: {},
            opBack: {}
          }
        });
      } else {
        keys.filter(
          (key) => [
            "flipY",
            "framebuffer",
            "textureUnits",
            "activeTextureUnit",
            "activeGeometryId",
            "currentProgramId"
          ].indexOf(key) > -1
        ).forEach((key) => {
          delete this.#state[key];
        });
        this.bindFramebuffer({
          buffer: null
        });
        this.#state.flipY = false;
        this.#state.activeGeometryId = -1;
        this.#state.activeTextureUnit = -1;
        this.#state.currentProgramId = -1;
        this.#state.textureUnits = [];
        this.#state.boundBuffer = null;
      }
    }
  }

  const external1ExtensionKeys = [
    "WEBGL_depth_texture",
    "OES_texture_half_float",
    "OES_texture_float",
    "OES_standard_derivatives",
    "OES_element_index_uint",
    "EXT_frag_depth",
    "EXT_blend_minmax",
    "EXT_shader_texture_lod",
    "WEBGL_draw_buffers",
    "WEBGL_color_buffer_float"
  ];
  const external2ExtensionKeys = [
    "EXT_color_buffer_float"
  ];
  const external12ExtensionKeys = [
    "WEBGL_lose_context",
    "OES_texture_half_float_linear",
    "OES_texture_float_linear",
    "EXT_color_buffer_half_float",
    "WEBGL_debug_renderer_info",
    "EXT_texture_filter_anisotropic"
  ];
  class Renderer {
    #gl;
    #state;
    #extensions;
    #autoClear;
    #depth;
    #alpha;
    #stencil;
    #antialias;
    #premultipliedAlpha;
    #preserveDrawingBuffer;
    #color;
    #dpr;
    #frustumCull;
    vertexAttribDivisor;
    drawArraysInstanced;
    drawElementsInstanced;
    createVertexArray;
    bindVertexArray;
    deleteVertexArray;
    width;
    height;
    constructor(gl, opts = {}) {
      const options = Object.assign(
        {},
        {
          autoClear: true,
          depth: true,
          alpha: false,
          stencil: false,
          antialias: false,
          premultipliedAlpha: false,
          preserveDrawingBuffer: false,
          requestWebGl2: true,
          extensions: []
        },
        opts
      );
      this.#autoClear = Boolean(options.autoClear);
      this.#depth = options.depth;
      this.#alpha = options.alpha;
      this.#stencil = options.stencil;
      this.#antialias = options.antialias;
      this.#premultipliedAlpha = options.premultipliedAlpha;
      this.#preserveDrawingBuffer = options.preserveDrawingBuffer;
      this.#gl = isWebGL(gl) || isWebGL2(gl) ? gl : getContext(
        gl,
        {
          alpha: this.#alpha,
          depth: this.#depth,
          stencil: this.#stencil,
          antialias: this.#antialias,
          powerPreference: options.powerPreference,
          premultipliedAlpha: this.#premultipliedAlpha,
          preserveDrawingBuffer: this.#preserveDrawingBuffer
        },
        options.requestWebGl2
      );
      const attrs = this.#gl?.getContextAttributes();
      const viewport = this.#gl?.getParameter(this.#gl.VIEWPORT);
      const flipY = this.#gl?.getParameter(this.#gl.UNPACK_FLIP_Y_WEBGL);
      this.#state = new State(this);
      if (attrs) {
        this.#depth = Boolean(attrs.depth);
        this.#antialias = Boolean(attrs.antialias);
        this.#alpha = Boolean(attrs.alpha);
        this.#stencil = Boolean(attrs.stencil);
        this.#premultipliedAlpha = Boolean(attrs.premultipliedAlpha);
        this.#preserveDrawingBuffer = Boolean(attrs.preserveDrawingBuffer);
      }
      this.#state.flipY = Boolean(flipY);
      this.#state.setViewport(viewport[2], viewport[3], viewport[0], viewport[1]);
      this.#state.premultiplyAlpha = this.#premultipliedAlpha;
      this.#color = true;
      this.#dpr = options.dpr || 1;
      this.width = this.gl.canvas.width / this.#dpr;
      this.height = this.gl.canvas.height / this.#dpr;
      this.#frustumCull = !!options.frustumCull;
      this.#extensions = {};
      this.vertexAttribDivisor = this.getExtension(
        "ANGLE_instanced_arrays",
        "vertexAttribDivisor",
        "vertexAttribDivisorANGLE"
      );
      this.drawArraysInstanced = this.getExtension(
        "ANGLE_instanced_arrays",
        "drawArraysInstanced",
        "drawArraysInstancedANGLE"
      );
      this.drawElementsInstanced = this.getExtension(
        "ANGLE_instanced_arrays",
        "drawElementsInstanced",
        "drawElementsInstancedANGLE"
      );
      this.createVertexArray = this.getExtension(
        "OES_vertex_array_object",
        "createVertexArray",
        "createVertexArrayOES"
      );
      this.bindVertexArray = this.getExtension(
        "OES_vertex_array_object",
        "bindVertexArray",
        "bindVertexArrayOES"
      );
      this.deleteVertexArray = this.getExtension(
        "OES_vertex_array_object",
        "deleteVertexArray",
        "deleteVertexArrayOES"
      );
      if (options.extensions) {
        options.extensions.filter(
          (extension) => external1ExtensionKeys.findIndex((ext) => ext === extension) > -1
        ).forEach((extension) => {
          if (!this.#extensions[extension] && !this.isWebGL2) {
            this.#extensions[extension] = this.gl.getExtension(extension);
          }
        });
        options.extensions.filter(
          (extension) => external2ExtensionKeys.findIndex((ext) => ext === extension) > -1
        ).forEach((extension) => {
          if (!this.#extensions[extension] && this.isWebGL2) {
            this.#extensions[extension] = this.gl.getExtension(extension);
          }
        });
        options.extensions.filter(
          (extension) => external12ExtensionKeys.findIndex((ext) => ext === extension) > -1
        ).forEach((extension) => {
          if (!this.#extensions[extension]) {
            this.#extensions[extension] = this.gl.getExtension(extension);
          }
        });
      }
    }
    get gl() {
      return this.#gl;
    }
    get attributes() {
      return {
        dpr: this.#dpr,
        flipY: this.#state.flipY,
        depth: this.#depth,
        color: this.#color,
        antialias: this.#antialias,
        alpha: this.#alpha,
        stencil: this.#stencil,
        autoClear: this.#autoClear,
        frustumCull: this.#frustumCull,
        premultipliedAlpha: this.#premultipliedAlpha,
        preserveDrawingBuffer: this.#preserveDrawingBuffer
      };
    }
    get canvas() {
      return this.#gl.canvas;
    }
    get isWebGL() {
      return isWebGL(this.gl);
    }
    get isWebGL2() {
      return isWebGL2(this.gl);
    }
    get extensions() {
      return this.#extensions;
    }
    extension(key) {
      return this.#extensions[key];
    }
    get size() {
      return {
        width: "clientWidth" in this.canvas ? this.canvas.clientWidth : this.canvas.width,
        height: "clientHeight" in this.canvas ? this.canvas.clientHeight : this.canvas.height
      };
    }
    get state() {
      return this.#state;
    }
    get premultipliedAlpha() {
      return this.#premultipliedAlpha;
    }
    setSize(width, height) {
      this.width = width;
      this.height = height;
      this.gl.canvas.width = width * this.#dpr;
      this.gl.canvas.height = height * this.#dpr;
    }
    setViewport(width, height, x = 0, y = 0) {
      this.#state.setViewport(width, height, x, y);
    }
    getExtension(extension, method, extFunc) {
      const func = this.gl[method];
      if (method && func)
        return func.bind(this.gl);
      if (!this.#extensions[extension]) {
        this.#extensions[extension] = this.gl.getExtension(extension);
      }
      const ef = this.#extensions[extension];
      return method ? ef ? ef[extFunc].bind(ef) : null : ef;
    }
    getRenderList({ scene, camera }) {
      const renderList = [];
      scene.traverse((node) => {
        if (!node.visible)
          return true;
        if (!node.draw)
          return;
        if (this.#frustumCull && node.frustumCulled && camera) {
          if (!camera.frustumIntersectsMesh(node))
            return;
        }
        renderList.push(node);
      });
      return renderList;
    }
    render(params) {
      const { scene, camera, target = null, update = true, clear } = params;
      if (target === null) {
        this.#state.bindFramebuffer({
          buffer: null
        });
        this.setViewport(this.width * this.#dpr, this.height * this.#dpr);
      } else {
        target.bind();
        this.setViewport(target.width, target.height);
      }
      if (clear || this.#autoClear && clear !== false) {
        if (this.#depth && (!target || target.depth)) {
          this.#state.enable(this.gl.DEPTH_TEST);
          this.#state.setDepthMask(true);
        }
        this.clear(this.#color, this.#depth, this.#stencil);
      }
      if (update)
        scene.updateMatrixWorld();
      if (camera)
        camera.updateMatrixWorld();
      const renderList = this.getRenderList({ scene, camera });
      let i = 0;
      const len = renderList.length;
      for (; i < len; i++) {
        const node = renderList[i];
        node.draw({ camera });
      }
      if (target) {
        target.unbind();
      }
    }
    clear(color = this.#color, depth = this.#depth, stencil = this.#stencil) {
      let bits = 0;
      if (color)
        bits |= this.gl.COLOR_BUFFER_BIT;
      if (depth)
        bits |= this.gl.DEPTH_BUFFER_BIT;
      if (stencil)
        bits |= this.gl.STENCIL_BUFFER_BIT;
      this.gl.clear(bits);
    }
    resetState(force = true, vao = null) {
      this.#state.reset(force);
      this.bindVertexArray(vao);
    }
  }

  const ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  class Resource extends Base {
    #handle;
    #lastHandle;
    id;
    name;
    userData;
    byteLength;
    options;
    constructor(renderer, options = {}) {
      super(renderer);
      this.id = options?.id || uid(this.constructor.name);
      this.name = options?.name;
      this.userData = options?.userData;
      this.#handle = options?.handle;
      this.options = options;
      if (this.#handle === void 0) {
        this.#handle = this.createHandle();
      }
      this.byteLength = 0;
    }
    get handle() {
      return this.#handle;
    }
    swapHandle(handle) {
      this.#lastHandle = this.#handle;
      this.#handle = handle;
    }
    restoreHandle() {
      this.#handle = this.#lastHandle;
    }
    destroy() {
      this.delete();
    }
    delete({ deleteChildren = false } = {}) {
      const children = this.handle && this.deleteHandle(this.handle);
      if (this.handle) {
        this.removeStats();
      }
      this.#handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.delete());
      }
      return this;
    }
    bind(funcOrHandle = this.handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    unbind() {
      this.bind(null);
    }
    removeStats() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    toString() {
      return `${this.constructor.name}(${this.id})`;
    }
  }

  class RenderBuffer extends Resource {
    width;
    height;
    #internalFormat;
    constructor(renderer, options = {}) {
      super(renderer, {
        ...options,
        format: options.format || renderer.gl.DEPTH_COMPONENT16
      });
      this.#internalFormat = this.options.format;
      this.width = this.options.width;
      this.height = this.options.height;
      console.assert(
        this.width > 0 && this.height > 0,
        "Renderbuffer object requires valid width and height greater than zero"
      );
      this.bind();
      renderer.gl.renderbufferStorage(
        renderer.gl.RENDERBUFFER,
        this.#internalFormat,
        this.width,
        this.height
      );
    }
    resize(width, height) {
      if (width === this.width && height === this.height)
        return;
      this.width = width;
      this.height = height;
      this.bind();
      this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.#internalFormat, width, height);
      this.unbind();
    }
    bind() {
      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.handle);
    }
    unbind() {
      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
    }
    removeStats() {
    }
    destroy() {
      this.unbind();
      this.deleteHandle();
    }
    createHandle() {
      return this.gl.createRenderbuffer();
    }
    deleteHandle() {
      this.handle && this.gl.deleteRenderbuffer(this.handle);
    }
  }

  const emptyPixel = new Uint8Array(4);
  class Texture extends Resource {
    needsUpdate = false;
    textureUnit = 0;
    image;
    width;
    height;
    target;
    #state = {};
    constructor(renderer, options = {}, needsUpdate = true) {
      const { gl } = renderer;
      const defaultOptions = {
        target: gl.TEXTURE_2D,
        type: gl.UNSIGNED_BYTE,
        format: gl.RGBA,
        internalFormat: options.format || gl.RGBA,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE,
        generateMipmaps: true,
        minFilter: gl.LINEAR,
        magFilter: gl.LINEAR,
        premultiplyAlpha: false,
        unpackAlignment: 4,
        anisotropy: 0,
        flipY: false,
        level: 0
      };
      const opt = Object.assign({}, defaultOptions, options);
      super(renderer, opt);
      this.textureUnit = 0;
      this.image = this.options.image;
      this.width = this.options.width;
      this.height = this.options.height;
      this.target = this.options.target;
      this.#state.version = -1;
      this.needsUpdate = Boolean(needsUpdate);
      if (this.needsUpdate) {
        this.update();
      }
    }
    setData(image, width = this.width, height = this.height) {
      this.image = image;
      this.width = width;
      this.height = height;
      this.needsUpdate = true;
    }
    setOptions(options) {
      this.options = Object.assign(this.options, options);
      this.width = this.options.width;
      this.height = this.options.height;
      this.needsUpdate = true;
    }
    fromSrc(url) {
      return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
          this.setData(image, image.width, image.height);
          resolve(this);
        };
        image.onerror = (e) => {
          reject(e);
        };
        image.crossOrigin = "*";
        image.src = url;
      });
    }
    update(units = 0) {
      const needUpdate = !(this.image === this.#state.image && !this.needsUpdate);
      const checked = needUpdate || this.rendererState.textureUnits[units] !== this.id || this.rendererState.activeTextureUnit !== units;
      if (checked) {
        this.rendererState.setActiveTexture(units);
        this.bind(units);
      }
      if (!needUpdate)
        return;
      this.needsUpdate = false;
      if (this.options.wrapS !== this.#state.wrapS) {
        this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.options.wrapS);
        this.#state.wrapS = this.options.wrapS;
      }
      if (this.options.wrapT !== this.#state.wrapT) {
        this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.options.wrapT);
        this.#state.wrapT = this.options.wrapT;
      }
      if (this.options.minFilter !== this.#state.minFilter) {
        this.gl.texParameteri(
          this.target,
          this.gl.TEXTURE_MIN_FILTER,
          this.options.minFilter
        );
        this.#state.minFilter = this.options.minFilter;
      }
      if (this.options.magFilter !== this.#state.magFilter) {
        this.gl.texParameteri(
          this.target,
          this.gl.TEXTURE_MAG_FILTER,
          this.options.magFilter
        );
        this.#state.magFilter = this.options.magFilter;
      }
      if (this.options.flipY !== this.rendererState.flipY) {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.options.flipY);
        this.rendererState.flipY = this.options.flipY;
      }
      if (this.options.premultiplyAlpha !== this.rendererState.premultiplyAlpha) {
        this.gl.pixelStorei(
          this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
          this.options.premultiplyAlpha
        );
        this.rendererState.premultiplyAlpha = this.options.premultiplyAlpha;
      }
      if (this.options.unpackAlignment !== this.rendererState.unpackAlignment) {
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.options.unpackAlignment);
        this.rendererState.unpackAlignment = this.options.unpackAlignment;
      }
      if (this.options.anisotropy && this.options.anisotropy !== this.rendererState.anisotropy) {
        const extTextureFilterAnisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        if (extTextureFilterAnisotropic) {
          const max = this.gl.getParameter(
            extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
          );
          let v = this.options.anisotropy;
          if (this.options.anisotropy > max) {
            v = max;
            console.warn(
              `[Texture]: Texture.anisotropy option exceeded the maximum allowed value ${max} of the device`
            );
          }
          this.gl.texParameterf(
            this.target,
            extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
            v
          );
        }
        this.rendererState.anisotropy = this.options.anisotropy;
      }
      if (this.image) {
        if (this.image.width) {
          this.width = this.image.width;
          this.height = this.image.height;
        }
        if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
          this.gl.texImage2D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            0,
            this.options.format,
            this.options.type,
            this.image,
            this.options.offset
          );
        } else {
          if (ArrayBuffer.isView(this.image)) {
            this.gl.texImage2D(
              this.target,
              this.options.level,
              this.options.internalFormat,
              this.width,
              this.height,
              0,
              this.options.format,
              this.options.type,
              this.image
            );
          } else {
            this.gl.texImage2D(
              this.target,
              this.options.level,
              this.options.internalFormat,
              this.options.format,
              this.options.type,
              this.image
            );
          }
        }
        if (this.options.generateMipmaps) {
          if (this.renderer.isWebGL2 || isPowerOfTwo(this.image.width) && isPowerOfTwo(this.image.height)) {
            this.gl.generateMipmap(this.target);
          } else {
            this.options.generateMipmaps = false;
            this.options.wrapS = this.gl.CLAMP_TO_EDGE;
            this.options.wrapT = this.options.wrapS;
            this.options.minFilter = this.gl.LINEAR;
          }
        }
      } else {
        if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
          if (this.width > 0) {
            this.gl.texImage2D(
              this.target,
              this.options.level,
              this.options.internalFormat,
              this.width,
              this.height,
              0,
              this.options.format,
              this.options.type,
              this.options.offset
            );
          } else {
            this.gl.texImage2D(
              this.target,
              0,
              this.gl.RGBA,
              1,
              1,
              0,
              this.gl.RGBA,
              this.gl.UNSIGNED_BYTE,
              emptyPixel,
              this.options.offset
            );
          }
        } else {
          if (this.width > 0) {
            this.gl.texImage2D(
              this.target,
              this.options.level,
              this.options.internalFormat,
              this.width,
              this.height,
              0,
              this.options.format,
              this.options.type,
              null
            );
          } else {
            this.gl.texImage2D(
              this.target,
              0,
              this.gl.RGBA,
              1,
              1,
              0,
              this.gl.RGBA,
              this.gl.UNSIGNED_BYTE,
              emptyPixel
            );
          }
        }
      }
      this.#state.image = this.image;
      this.#state.version += 1;
    }
    bind(unit = this.textureUnit) {
      if (this.rendererState.textureUnits[this.rendererState.activeTextureUnit] === this.id)
        return;
      this.textureUnit = unit;
      this.rendererState.textureUnits[this.textureUnit] = this.id;
      this.gl.bindTexture(this.target, this.handle);
    }
    unbind() {
      this.gl.activeTexture(this.gl.TEXTURE0 + this.textureUnit);
      this.gl.bindTexture(this.target, null);
      delete this.rendererState.textureUnits[this.textureUnit];
    }
    destroy() {
      this.unbind();
      super.destroy();
    }
    removeStats() {
      this.#state = {
        version: -1
      };
    }
    createHandle() {
      return this.gl.createTexture();
    }
    deleteHandle() {
      if (this.handle) {
        this.gl.deleteTexture(this.handle);
      }
    }
    toString() {
      return `Texture(${this.id},${this.width}x${this.height})`;
    }
  }

  class DataTexture extends Texture {
    needsUpdate = true;
    constructor(renderer, options = {}) {
      super(renderer, {
        ...options,
        image: options.data,
        premultiplyAlpha: true,
        flipY: false,
        unpackAlignment: 1
      });
    }
  }

  class RenderTarget extends Resource {
    #textures;
    #renderBuffers;
    depth;
    width;
    height;
    viewport;
    drawBuffersChanged;
    drawBuffers;
    #clearColors;
    #clearDepth;
    #clearStencil;
    constructor(renderer, options = {}) {
      super(renderer, {
        color: 1,
        depth: true,
        depthTexture: false,
        stencil: false,
        ...options
      });
      this.#renderBuffers = /* @__PURE__ */ new Map();
      this.#textures = /* @__PURE__ */ new Map();
      this.depth = Boolean(options.depth);
      this.drawBuffers = [];
      this.drawBuffersChanged = false;
      this.width = this.options.width;
      this.height = this.options.height;
      this.viewport = new Vector4(0, 0, this.width, this.height);
      this.name = this.options.name;
      const attachments = this.options.attachments || [];
      if (attachments.length === 0) {
        for (let i = 0; i < this.options.color; i++) {
          const opt = {
            wrapS: this.gl.CLAMP_TO_EDGE,
            wrapT: this.gl.CLAMP_TO_EDGE,
            minFilter: this.gl.LINEAR,
            magFilter: this.gl.LINEAR,
            type: this.gl.UNSIGNED_BYTE,
            format: this.gl.RGBA,
            flipY: false,
            generateMipmaps: false,
            ...options
          };
          let texture;
          if (opt.data) {
            texture = new DataTexture(renderer, opt);
          } else {
            texture = new Texture(
              renderer,
              omit(opt, [
                "data",
                "name",
                "attachments",
                "depthTexture"
              ])
            );
          }
          attachments.push([this.gl.COLOR_ATTACHMENT0 + i, texture]);
        }
        if (options.depthTexture && (renderer.isWebGL2 || !renderer.isWebGL2 && renderer.gl.getExtension("WEBGL_depth_texture"))) {
          const texture = new Texture(renderer, {
            width: this.width,
            height: this.height,
            minFilter: this.gl.NEAREST,
            magFilter: this.gl.NEAREST,
            format: this.gl.DEPTH_COMPONENT,
            internalFormat: renderer.isWebGL2 ? this.gl.DEPTH_COMPONENT16 : this.gl.DEPTH_COMPONENT,
            type: this.gl.UNSIGNED_INT
          });
          attachments.push([this.gl.DEPTH_ATTACHMENT, texture]);
        } else {
          const { depth, stencil } = options;
          if (depth && !stencil) {
            const renderBuffer = new RenderBuffer(renderer, {
              format: this.gl.DEPTH_COMPONENT16,
              width: this.width,
              height: this.height
            });
            attachments.push([this.gl.DEPTH_ATTACHMENT, renderBuffer]);
          } else if (stencil && !depth) {
            const renderBuffer = new RenderBuffer(renderer, {
              format: this.gl.STENCIL_INDEX8,
              width: this.width,
              height: this.height
            });
            attachments.push([this.gl.STENCIL_ATTACHMENT, renderBuffer]);
          } else if (depth && stencil) {
            const renderBuffer = new RenderBuffer(renderer, {
              format: this.gl.DEPTH_STENCIL,
              width: this.width,
              height: this.height
            });
            attachments.push([this.gl.DEPTH_STENCIL_ATTACHMENT, renderBuffer]);
          }
        }
      }
      this.create(attachments);
    }
    get texture() {
      return this.#textures.values().next().value;
    }
    set clearColors(colors) {
      this.#clearColors = colors;
    }
    get clearColors() {
      return this.#clearColors;
    }
    set clearDepth(depth) {
      this.#clearDepth = depth;
    }
    get clearDepth() {
      return this.#clearDepth;
    }
    set clearStencil(stencil) {
      this.#clearStencil = stencil;
    }
    get clearStencil() {
      return this.#clearStencil;
    }
    create(attachments) {
      this.#clearColors = [];
      this.#clearDepth = 1;
      this.#clearStencil = 0;
      for (const attachment of attachments) {
        const attach = attachment[0];
        const target = attachment[1];
        if (target instanceof RenderBuffer) {
          this.#renderBuffers.set(attach, target);
        } else if (target instanceof Texture) {
          this.#textures.set(attach, target);
          this.drawBuffers.push(attach);
        }
        const i = attach - this.gl.COLOR_ATTACHMENT0;
        this.#clearColors[i] = [0, 0, 0, 0];
      }
      if (this.options.color > 1) {
        if (this.renderer.isWebGL2) {
          this.gl.drawBuffers(this.drawBuffers);
        } else {
          const ext = this.renderer.extension("WEBGL_draw_buffers");
          if (ext && ext.drawBuffersWEBGL) {
            ext.drawBuffersWEBGL(this.drawBuffers);
          } else {
            throw new Error(
              "Please open the corresponding extension [WEBGL_draw_buffers](https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_draw_buffers#browser_compatibility) and check whether the browser supports it"
            );
          }
        }
      }
      this.drawBuffersChanged = true;
      this.bind();
      this.#renderBuffers.forEach((rbo, attachment) => {
        this.gl.framebufferRenderbuffer(
          this.gl.FRAMEBUFFER,
          attachment,
          this.gl.RENDERBUFFER,
          rbo.handle
        );
      });
      this.#textures.forEach((texture, attachment) => {
        this.gl.framebufferTexture2D(
          this.gl.FRAMEBUFFER,
          attachment,
          this.gl.TEXTURE_2D,
          texture.handle,
          0
        );
      });
      this.unbind();
      const status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
      if (status !== this.gl.FRAMEBUFFER_COMPLETE) {
        switch (status) {
          case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw new Error(
              "The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete"
            );
          case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw new Error("There is no attachment");
          case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw new Error(" Height and width of the attachment are not the same.");
          case this.gl.FRAMEBUFFER_UNSUPPORTED:
            throw new Error(
              "The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer"
            );
        }
      }
      return this.handle;
    }
    clear() {
      this.bind();
      let flags = 0;
      if (this.clearColors[0]) {
        const color = this.clearColors[0];
        this.gl.clearColor(color[0], color[1], color[2], color[3]);
        flags |= this.gl.COLOR_BUFFER_BIT;
      }
      if (isNumber(this.#clearDepth)) {
        this.gl.clearDepth(this.#clearDepth);
        flags |= this.gl.DEPTH_BUFFER_BIT;
      }
      if (isNumber(this.#clearStencil)) {
        this.gl.clearStencil(this.#clearStencil);
        flags |= this.gl.STENCIL_BUFFER_BIT;
      }
      this.gl.clear(flags);
      this.unbind();
    }
    getTexture(key) {
      return this.#textures.get(key);
    }
    resize(width, height) {
      if (this.width !== width || this.height !== height) {
        this.width = width;
        this.height = height;
        this.#textures.forEach((texture) => {
          if (texture.width !== width || texture.height !== height) {
            texture.width = width;
            texture.height = height;
            texture.needsUpdate = true;
            texture.update();
          }
        });
        this.#renderBuffers.forEach((rbo) => {
          rbo.resize(width, height);
        });
        this.viewport.set(0, 0, width, height);
      }
    }
    bind(fbo = this.gl.FRAMEBUFFER) {
      this.gl.bindFramebuffer(fbo, this.handle);
    }
    unbind(fbo = this.gl.FRAMEBUFFER) {
      this.gl.bindFramebuffer(fbo, null);
    }
    removeStats() {
    }
    destroy() {
      this.#textures.forEach((texture) => {
        texture.destroy();
      });
      this.#renderBuffers.forEach((buffer) => {
        buffer.destroy();
      });
      this.deleteHandle();
    }
    createHandle() {
      return this.gl.createFramebuffer();
    }
    deleteHandle() {
      this.handle && this.gl.deleteFramebuffer(this.handle);
    }
    toString() {
      return `RenderTarget(${this.id},${this.width}x${this.height})`;
    }
  }

  function getPlaneBuffer(position, normal, uv, index, width = 1, height = 1, depth = 0, widthSegments = 1, heightSegments = 1, u = 0, v = 1, w = 2, uDir = 1, vDir = -1, i = 0, ii = 0) {
    const consti = i;
    const widthHalf = width / 2;
    const heightHalf = height / 2;
    const depthHalf = depth / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segmentWidth = width / gridX;
    const segmentHeight = height / gridY;
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segmentHeight - heightHalf;
      for (let ix = 0; ix < gridX1; ix++) {
        position[i * 3 + u] = (ix * segmentWidth - widthHalf) * uDir;
        position[i * 3 + v] = y * vDir;
        position[i * 3 + w] = depthHalf;
        normal[i * 3 + u] = 0;
        normal[i * 3 + v] = 0;
        normal[i * 3 + w] = depth >= 0 ? 1 : -1;
        uv[i * 2] = ix / gridX;
        uv[i * 2 + 1] = 1 - iy / gridY;
        i++;
        if (iy === gridY || ix === gridX)
          continue;
        const a = consti + ix + gridX1 * iy;
        const b = consti + ix + gridX1 * (iy + 1);
        const c = consti + ix + 1 + gridX1 * (iy + 1);
        const d = consti + ix + 1 + gridX1 * iy;
        index[ii * 6] = a;
        index[ii * 6 + 1] = b;
        index[ii * 6 + 2] = d;
        index[ii * 6 + 3] = b;
        index[ii * 6 + 4] = c;
        index[ii * 6 + 5] = d;
        ii++;
      }
    }
  }
  class Plane extends Geometry {
    constructor(renderer, {
      width = 1,
      height = 1,
      widthSegments = 1,
      heightSegments = 1,
      attributes = {}
    } = {}) {
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const num = gridX1 * gridY1;
      const numIndices = gridX * gridY * 6;
      const position = new Float32Array(num * 3);
      const normal = new Float32Array(num * 3);
      const uv = new Float32Array(num * 2);
      const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);
      getPlaneBuffer(position, normal, uv, index, width, height, 0, widthSegments, heightSegments);
      super(renderer, {
        ...attributes,
        position: {
          size: 3,
          data: position
        },
        normal: {
          size: 3,
          data: normal
        },
        uv: {
          size: 2,
          data: uv
        },
        index: {
          data: index
        }
      });
    }
  }

  class Box extends Geometry {
    constructor(renderer, {
      width = 1,
      height = 1,
      depth = 1,
      widthSegments = 1,
      heightSegments = 1,
      depthSegments = 1,
      attributes = {}
    } = {}) {
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridZ = Math.floor(depthSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const gridZ1 = gridZ + 1;
      const num = gridX1 * gridY1 * 2 + gridX1 * gridZ1 * 2 + gridY1 * gridZ1 * 2;
      const numIndices = (gridX * gridY * 2 + gridX * gridZ * 2 + gridY * gridZ * 2) * 6;
      const position = new Float32Array(num * 3);
      const normal = new Float32Array(num * 3);
      const uv = new Float32Array(num * 2);
      const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);
      let i = 0;
      let ii = 0;
      const d = gridZ1 * gridY1;
      const w = gridX1 * gridZ1;
      const h = gridX1 * gridY1;
      const dt = gridZ * gridY;
      const wt = gridX * gridZ;
      const ht = gridX * gridY;
      getPlaneBuffer(
        position,
        normal,
        uv,
        index,
        depth,
        height,
        width,
        depthSegments,
        heightSegments,
        2,
        1,
        0,
        -1,
        -1,
        i,
        ii
      );
      i += d;
      ii += dt;
      getPlaneBuffer(
        position,
        normal,
        uv,
        index,
        depth,
        height,
        -width,
        depthSegments,
        heightSegments,
        2,
        1,
        0,
        1,
        -1,
        i,
        ii
      );
      i += d;
      ii += dt;
      getPlaneBuffer(
        position,
        normal,
        uv,
        index,
        width,
        depth,
        height,
        depthSegments,
        widthSegments,
        0,
        2,
        1,
        1,
        1,
        i,
        ii
      );
      i += w;
      ii += wt;
      getPlaneBuffer(
        position,
        normal,
        uv,
        index,
        width,
        depth,
        -height,
        depthSegments,
        widthSegments,
        0,
        2,
        1,
        1,
        -1,
        i,
        ii
      );
      i += w;
      ii += wt;
      getPlaneBuffer(
        position,
        normal,
        uv,
        index,
        width,
        height,
        -depth,
        widthSegments,
        heightSegments,
        0,
        1,
        2,
        -1,
        -1,
        i,
        ii
      );
      i += h;
      ii += ht;
      getPlaneBuffer(
        position,
        normal,
        uv,
        index,
        width,
        height,
        depth,
        widthSegments,
        heightSegments,
        0,
        1,
        2,
        1,
        -1,
        i,
        ii
      );
      super(renderer, {
        ...attributes,
        position: {
          size: 3,
          data: position
        },
        normal: {
          size: 3,
          data: normal
        },
        uv: {
          size: 2,
          data: uv
        },
        index: {
          data: index
        }
      });
    }
  }

  const ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
  const cachedIds = {};
  function genShaderName(key = "id") {
    cachedIds[key] = cachedIds[key] || 1;
    const idx = cachedIds[key];
    cachedIds[key] += 1;
    return "".concat(key, "-").concat(idx);
  }
  const getTypeName = (ctx, shaderType) => {
    switch (shaderType) {
      case ctx.VERTEX_SHADER:
        return "vertex-shader";
      case ctx.FRAGMENT_SHADER:
        return "fragment-shader";
      default:
        return "unknown";
    }
  };
  const getShaderType = (ctx, type) => {
    switch (type) {
      case "fragment":
        return ctx.FRAGMENT_SHADER;
      case "vertex":
        return ctx.VERTEX_SHADER;
      default:
        return;
    }
  };
  function addLineNumbers(string) {
    const lines = string.split("\n");
    for (let i = 0; i < lines.length; i++) {
      lines[i] = i + 1 + ": " + lines[i];
    }
    return lines.join("\n");
  }
  class Shader extends Resource {
    #shaderType;
    #includes;
    sourceCode;
    constructor(renderer, sourceCode, type, includes = {}) {
      const shaderType = getShaderType(renderer.gl, type);
      super(renderer, {
        name: getShaderName(sourceCode) || genShaderName(getTypeName(renderer, shaderType))
      });
      console.assert(typeof sourceCode === "string", ERR_SOURCE);
      this.#includes = includes;
      this.#shaderType = shaderType;
      this.sourceCode = this.injectShaderModule(sourceCode, includes || {}).replace(
        /\n\n+/gm,
        "\n\n"
      );
      this.createShader(this.sourceCode);
    }
    injectShaderModule(shader, modules = {}) {
      const regExp = /^[\t ]*#glsl_include +<([\w.]+)>/gm;
      const replacement = (substring, r) => {
        let module = modules[r];
        if (module === void 0)
          throw new Error("Cannot resolve #include <".concat(r, ">"));
        module = module.replace(/#include </g, "#glsl_include <");
        return this.injectShaderModule(module, modules);
      };
      return shader.replace(regExp, replacement);
    }
    createShader(source = this.source) {
      let s = source.replace(/#include </g, "#glsl_include <");
      s = this.injectShaderModule(s, this.#includes || {}).replace(/\n\n+/gm, "\n\n");
      this.gl.shaderSource(this.handle, s);
      this.gl.compileShader(this.handle);
      if (!this.gl.getShaderParameter(this.handle, this.gl.COMPILE_STATUS)) {
        const log = this.gl.getShaderInfoLog(this.handle) || "";
        this.gl.deleteShader(this.handle);
        throw new Error(`${this.toString()}
${log}
${addLineNumbers(s)}`);
      }
    }
    get source() {
      return this.sourceCode;
    }
    get shaderType() {
      return this.#shaderType;
    }
    getSource() {
      return this.gl.getShaderSource(this.handle);
    }
    setSource(source) {
      const name = getShaderName(source);
      if (name) {
        this.name = genShaderName(name);
      }
      this.createShader(source);
    }
    removeStats() {
    }
    deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
    toString() {
      return `${getTypeName(this.gl, this.shaderType)}:${this.id}`;
    }
  }
  class VertexShader extends Shader {
    constructor(renderer, sourceCode, includes) {
      super(renderer, sourceCode, "vertex", includes);
    }
    createHandle() {
      return this.gl.createShader(this.gl.VERTEX_SHADER);
    }
  }
  class FragmentShader extends Shader {
    constructor(renderer, sourceCode, includes) {
      super(renderer, sourceCode, "fragment", includes);
    }
    createHandle() {
      return this.gl.createShader(this.gl.FRAGMENT_SHADER);
    }
  }

  const getDefines = (t) => {
    const defines = [];
    return defines.map((d) => "#define ".concat(d));
  };
  const arrayCacheF32 = {};
  function flatten(a) {
    const arrayLen = a.length;
    const valueLen = a[0].length;
    if (valueLen === void 0)
      return a;
    const length = arrayLen * valueLen;
    let value = arrayCacheF32[length];
    if (!value)
      arrayCacheF32[length] = value = new Float32Array(length);
    for (let i = 0; i < arrayLen; i++)
      value.set(a[i], i * valueLen);
    return value;
  }
  function setUniform(gl, type, location, value) {
    value = value.length ? flatten(value) : value;
    const isArray = value.length;
    switch (type) {
      case WebGLRenderingContext.FLOAT:
        return isArray ? gl.uniform1fv(location, value) : gl.uniform1f(location, value);
      case WebGLRenderingContext.FLOAT_VEC2:
        return gl.uniform2fv(location, value);
      case WebGLRenderingContext.FLOAT_VEC3:
        return gl.uniform3fv(location, value);
      case WebGLRenderingContext.FLOAT_VEC4:
        return gl.uniform4fv(location, value);
      case WebGLRenderingContext.BOOL:
      case WebGLRenderingContext.INT:
      case WebGLRenderingContext.SAMPLER_2D:
      case WebGLRenderingContext.SAMPLER_CUBE:
        return isArray ? gl.uniform1iv(location, value) : gl.uniform1i(location, value);
      case WebGLRenderingContext.BOOL_VEC2:
      case WebGLRenderingContext.INT_VEC2:
        return gl.uniform2iv(location, value);
      case WebGLRenderingContext.BOOL_VEC3:
      case WebGLRenderingContext.INT_VEC3:
        return gl.uniform3iv(location, value);
      case WebGLRenderingContext.BOOL_VEC4:
      case WebGLRenderingContext.INT_VEC4:
        return gl.uniform4iv(location, value);
      case WebGLRenderingContext.FLOAT_MAT2:
        return gl.uniformMatrix2fv(location, false, value);
      case WebGLRenderingContext.FLOAT_MAT3:
        return gl.uniformMatrix3fv(location, false, value);
      case WebGLRenderingContext.FLOAT_MAT4:
        return gl.uniformMatrix4fv(location, false, value);
    }
  }
  class Program extends Resource {
    attributeOrder;
    uniforms;
    #uniformLocations;
    #attributeLocations;
    #vs;
    #fs;
    #renderState;
    constructor(renderer, options = {}) {
      super(renderer, options);
      const {
        id,
        vertexShader,
        fragmentShader,
        uniforms = {},
        transparent = false,
        defines = [],
        includes = {},
        cullFace,
        frontFace = renderer.gl.CCW,
        depthTest = true,
        depthWrite = true,
        depthFunc = renderer.gl.LESS,
        blending = 1,
        blendFunc,
        blendEquation
      } = options;
      this.id = id || uid("program");
      const defs = [
        ...getDefines({
          ...options,
          ...uniforms
        }),
        ...defines
      ].map((str) => !str.startsWith("#define ") ? "#define ".concat(str) : str);
      if (!vertexShader || !fragmentShader) {
        throw new Error(`Program: ${this.id}\uFF1Amust provide vertexShader and fragmentShader`);
      }
      this.#vs = typeof vertexShader === "string" ? new VertexShader(renderer, parseShader(vertexShader, defs), includes) : vertexShader;
      this.#fs = typeof fragmentShader === "string" ? new FragmentShader(renderer, parseShader(fragmentShader, defs), includes) : fragmentShader;
      this.gl.attachShader(this.handle, this.#vs.handle);
      this.gl.attachShader(this.handle, this.#fs.handle);
      this.gl.linkProgram(this.handle);
      this.gl.validateProgram(this.handle);
      if (!this.gl.getProgramParameter(this.handle, this.gl.LINK_STATUS)) {
        throw new Error(
          "Program:".concat(this.id, ": Error linking ").concat(this.gl.getProgramInfoLog(this.handle))
        );
      }
      this.uniforms = uniforms;
      this.#renderState = {
        blending,
        cullFace,
        frontFace,
        depthTest,
        depthWrite,
        depthFunc,
        blendFunc,
        blendEquation
      };
      this.#uniformLocations = /* @__PURE__ */ new Map();
      this.#attributeLocations = /* @__PURE__ */ new Map();
      this.#assignUniforms(uniforms);
      this.#assignAttributes();
      if (transparent && !blendFunc?.src) {
        if (this.renderer.premultipliedAlpha) {
          this.#renderState.blendFunc = {
            ...blendFunc,
            src: this.gl.ONE,
            dst: this.gl.ONE_MINUS_SRC_ALPHA
          };
        } else {
          this.#renderState.blendFunc = {
            ...blendFunc,
            src: this.gl.SRC_ALPHA,
            dst: this.gl.ONE_MINUS_SRC_ALPHA
          };
        }
      }
    }
    get uniformLocations() {
      return this.#uniformLocations;
    }
    get attributeLocations() {
      return this.#attributeLocations;
    }
    get vertexShader() {
      return this.#vs;
    }
    get fragmentShader() {
      return this.#fs;
    }
    use() {
      const programActive = this.rendererState.currentProgramId === this.id;
      let textureUnit = -1;
      if (!programActive) {
        this.gl.useProgram(this.handle);
        this.rendererState.currentProgramId = this.id;
      }
      this.#uniformLocations.forEach((location, activeUniform) => {
        const name = activeUniform.name;
        const uniform = this.uniforms[name];
        if (!uniform) {
          console.warn("Program:".concat(this.id, ": Active uniform ").concat(name, " has not been supplied"));
          return;
        }
        if (uniform && (isUndef(uniform.value) || isNull(uniform.value))) {
          console.warn("Program:".concat(this.id, ": Uniform ").concat(name, " is missing a value parameter"));
          return;
        }
        let value = uniform?.value;
        if (value instanceof Texture) {
          textureUnit += 1;
          uniform.value.update(textureUnit);
          return setUniform(this.gl, activeUniform.type, location.location, textureUnit);
        }
        if (value instanceof Matrix || value instanceof Vector) {
          value = uniform.value.toArray();
        } else if (value instanceof Color) {
          value = uniform.value.toArray();
        }
        if (value && value.length > 0 && value[0] instanceof Texture) {
          const units = [];
          for (let i = 0; i < uniform.value.length; i++) {
            const v = value[i];
            textureUnit += 1;
            v.update(textureUnit);
            units.push(textureUnit);
          }
          return setUniform(this.gl, activeUniform.type, location.location, units);
        }
        setUniform(this.gl, activeUniform.type, location.location, value);
      });
      this.applyState();
    }
    setStates(states, merge = true) {
      if (!merge) {
        this.#renderState = states;
      } else {
        this.#renderState = {
          ...this.#renderState,
          ...omit(states, ["blendFunc", "blendEquation"])
        };
        if (states.blendFunc) {
          this.#renderState.blendFunc = {
            ...this.#renderState.blendFunc,
            ...states.blendFunc
          };
        }
        if (states.blendEquation) {
          this.#renderState.blendEquation = {
            ...this.#renderState.blendEquation,
            ...states.blendEquation
          };
        }
      }
    }
    applyState() {
      this.rendererState.apply(this.#renderState);
    }
    setUniform(key, value) {
      if (this.uniforms[key]) {
        this.uniforms[key].value = value;
      }
    }
    bind() {
      this.gl.useProgram(this.handle);
    }
    unbind() {
      this.gl.useProgram(null);
    }
    createHandle() {
      return this.gl.createProgram();
    }
    deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
    #assignUniforms(uniforms = {}) {
      const numUniforms = this.gl.getProgramParameter(this.handle, this.gl.ACTIVE_UNIFORMS);
      for (let i = 0; i < numUniforms; i++) {
        const uniformInfo = this.gl.getActiveUniform(this.handle, i);
        if (!uniformInfo)
          break;
        const name = uniformInfo.name;
        const split = name.match(/(\w+)/g);
        const uniformData = {
          location: this.gl.getUniformLocation(this.handle, name),
          type: uniformInfo.type,
          name: split[0],
          isStruct: false
        };
        if (split.length === 3) {
          uniformData.isStructArray = true;
          uniformData.structIndex = Number(split[1]);
          uniformData.structProperty = split[2];
        } else if (split.length === 2 && isNaN(Number(split[1]))) {
          uniformData.isStruct = true;
          uniformData.structProperty = split[1];
        }
        const v = uniforms[name]?.value;
        if (!isUndef(v) && !isNull(v)) {
          uniformData.value = uniforms[name].value;
        }
        this.uniforms[name] = uniformData;
        this.#uniformLocations.set(uniformInfo, uniformData);
      }
    }
    #assignAttributes() {
      const numAttribs = this.gl.getProgramParameter(this.handle, this.gl.ACTIVE_ATTRIBUTES);
      const locations = [];
      for (let i = 0; i < numAttribs; i++) {
        const attribInfo = this.gl.getActiveAttrib(this.handle, i);
        if (!attribInfo)
          break;
        const location = this.gl.getAttribLocation(this.handle, attribInfo.name);
        locations[location] = attribInfo.name;
        this.#attributeLocations.set(attribInfo, location);
      }
      this.attributeOrder = locations.join("");
    }
    destroy() {
      this.unbind();
      this.deleteHandle();
    }
  }

  class Texture3D extends Texture {
    needsUpdate = false;
    textureUnit = 0;
    depth;
    #state = {};
    constructor(renderer, options = {}) {
      const gl = renderer.gl;
      const defaultOptions = {
        target: gl.TEXTURE_3D,
        type: gl.UNSIGNED_BYTE,
        format: gl.RGBA,
        internalFormat: options.format || gl.RGBA,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE,
        wrapR: gl.CLAMP_TO_EDGE,
        generateMipmaps: true,
        minFilter: gl.LINEAR,
        magFilter: gl.LINEAR,
        premultiplyAlpha: false,
        unpackAlignment: 4,
        flipY: false,
        level: 0,
        depth: 0
      };
      const opt = Object.assign({}, defaultOptions, options);
      super(renderer, opt, false);
      this.needsUpdate = true;
      this.depth = this.options.depth;
      this.#state.version = -1;
      this.update();
    }
    get gl() {
      return this.renderer.gl;
    }
    setData(image, width = this.width, height = this.height, depth = this.depth) {
      this.image = image;
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.needsUpdate = true;
    }
    setOptions(options) {
      this.options = Object.assign(this.options, options);
      this.width = this.options.width;
      this.height = this.options.height;
      this.depth = this.options.depth;
      this.needsUpdate = true;
    }
    update(units = 0) {
      const needUpdate = !(this.image === this.#state.image && !this.needsUpdate);
      const checked = needUpdate || this.rendererState.textureUnits[units] !== this.id || this.rendererState.activeTextureUnit !== units;
      if (checked) {
        this.rendererState.setActiveTexture(units);
        this.bind(units);
      }
      if (!needUpdate)
        return;
      this.needsUpdate = false;
      if (this.options.wrapS !== this.#state.wrapS) {
        this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.options.wrapS);
        this.#state.wrapS = this.options.wrapS;
      }
      if (this.options.wrapT !== this.#state.wrapT) {
        this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.options.wrapT);
        this.#state.wrapT = this.options.wrapT;
      }
      if (this.options.wrapR !== this.#state.wrapR) {
        this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.options.wrapR);
        this.#state.wrapR = this.options.wrapR;
      }
      if (this.options.minFilter !== this.#state.minFilter) {
        this.gl.texParameteri(
          this.target,
          this.gl.TEXTURE_MIN_FILTER,
          this.options.minFilter
        );
        this.#state.minFilter = this.options.minFilter;
      }
      if (this.options.magFilter !== this.#state.magFilter) {
        this.gl.texParameteri(
          this.target,
          this.gl.TEXTURE_MAG_FILTER,
          this.options.magFilter
        );
        this.#state.magFilter = this.options.magFilter;
      }
      if (this.options.flipY !== this.rendererState.flipY) {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.options.flipY);
        this.rendererState.flipY = this.options.flipY;
      }
      if (this.options.premultiplyAlpha !== this.rendererState.premultiplyAlpha) {
        this.gl.pixelStorei(
          this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
          this.options.premultiplyAlpha
        );
        this.rendererState.premultiplyAlpha = this.options.premultiplyAlpha;
      }
      if (this.options.unpackAlignment !== this.rendererState.unpackAlignment) {
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.options.unpackAlignment);
        this.rendererState.unpackAlignment = this.options.unpackAlignment;
      }
      if (this.options.anisotropy && this.options.anisotropy !== this.rendererState.anisotropy) {
        const extTextureFilterAnisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        if (extTextureFilterAnisotropic) {
          const max = this.gl.getParameter(
            extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
          );
          let v = this.options.anisotropy;
          if (this.options.anisotropy > max) {
            v = max;
            console.warn(
              `[Texture]: Texture.anisotropy option exceeded the maximum allowed value ${max} of the device`
            );
          }
          this.gl.texParameterf(
            this.target,
            extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
            v
          );
        }
        this.rendererState.anisotropy = this.options.anisotropy;
      }
      if (this.image) {
        if (this.image.width) {
          this.width = this.image.width;
          this.height = this.image.height;
        }
        if (this.renderer.isWebGL2 && isNumber(this.options.offset)) {
          this.gl.texImage3D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            this.depth,
            0,
            this.options.format,
            this.options.type,
            this.image,
            this.options.offset
          );
        } else {
          if (ArrayBuffer.isView(this.image)) {
            this.gl.texImage3D(
              this.target,
              this.options.level,
              this.options.internalFormat,
              this.width,
              this.height,
              this.depth,
              0,
              this.options.format,
              this.options.type,
              this.image
            );
          } else {
            this.gl.texImage3D(
              this.target,
              this.options.level,
              this.options.internalFormat,
              this.width,
              this.height,
              this.depth,
              0,
              this.options.format,
              this.options.type,
              this.image
            );
          }
        }
        if (this.options.generateMipmaps) {
          if (this.renderer.isWebGL2 || isPowerOfTwo(this.image.width) && isPowerOfTwo(this.image.height)) {
            this.gl.generateMipmap(this.target);
          } else {
            this.options.generateMipmaps = false;
            this.options.wrapS = this.gl.CLAMP_TO_EDGE;
            this.options.wrapT = this.options.wrapS;
            this.options.minFilter = this.gl.LINEAR;
          }
        }
      } else {
        if (this.width > 0) {
          this.gl.texImage3D(
            this.target,
            this.options.level,
            this.options.internalFormat,
            this.width,
            this.height,
            this.depth,
            0,
            this.options.format,
            this.options.type,
            null
          );
        } else {
          this.gl.texImage3D(
            this.target,
            0,
            this.gl.RGBA,
            1,
            1,
            this.depth,
            0,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            emptyPixel
          );
        }
      }
      this.#state.image = this.image;
      this.#state.version += 1;
    }
    removeStats() {
      this.#state = {
        version: -1
      };
    }
    toString() {
      return `Texture3D(${this.id},${this.width}x${this.height})`;
    }
  }

  const tempMat4 = new Matrix4();
  const tempVec3a = new Vector3();
  const tempVec3b = new Vector3();
  const ERR_CAMERA_METHOD_UNDEFINED = "Camera subclass must define virtual methods";
  class Camera extends Object3D {
    cameraType;
    projectionMatrix;
    viewMatrix;
    projectionViewMatrix;
    worldPosition;
    #near;
    #far;
    #fov;
    #aspect;
    #zoom;
    #bounds;
    frustum;
    constructor({
      near = 0.1,
      far = 100,
      fov = 45,
      aspect = 1,
      bounds,
      zoom = 1
    } = {}) {
      super();
      this.cameraType = "perspective";
      this.projectionMatrix = new ProjectionMatrix();
      this.viewMatrix = new Matrix4();
      this.projectionViewMatrix = new ProjectionMatrix();
      this.worldPosition = new Vector3();
      this.frustum = new Matrix4();
      this.#near = near;
      this.#far = far;
      this.#fov = fov;
      this.#aspect = aspect;
      this.#bounds = bounds;
      this.#zoom = zoom;
      const {
        left,
        right,
        top,
        bottom
      } = bounds || {};
      this.cameraType = left || right ? "orthographic" : "perspective";
      if (this.cameraType === "orthographic") {
        this.orthographic(left, right, top, bottom, near, far, zoom);
      } else {
        this.perspective(fov, aspect, near, far);
      }
    }
    get near() {
      return this.#near;
    }
    set near(n) {
      this.#near = n;
      this.updateProjectionMatrix();
    }
    get far() {
      return this.#far;
    }
    set far(f) {
      this.#far = f;
      this.updateProjectionMatrix();
    }
    get fov() {
      return this.#fov;
    }
    set fov(f) {
      this.#fov = f;
      this.updateProjectionMatrix();
    }
    get aspect() {
      return this.#aspect;
    }
    set aspect(aspect) {
      this.#aspect = aspect;
      this.updateProjectionMatrix();
    }
    get zoom() {
      return this.#zoom;
    }
    set zoom(zoom) {
      this.#zoom = zoom;
      this.updateProjectionMatrix();
    }
    get bounds() {
      return this.#bounds;
    }
    set bounds(bounds) {
      this.#bounds = bounds;
      this.updateProjectionMatrix();
    }
    perspective(fov = this.fov, aspect = this.aspect, near = this.near, far = this.far) {
      this.#fov = fov;
      this.#aspect = aspect;
      this.#near = near;
      this.#far = far;
      this.projectionMatrix.fromPerspective(fov, aspect, near, far);
      this.cameraType = "perspective";
    }
    orthographic(left, right, top, bottom, near = this.near, far = this.far, zoom = 1) {
      this.#bounds = {
        left,
        right,
        top,
        bottom
      };
      this.near = near;
      this.far = far;
      this.projectionMatrix.orthographic(
        left / zoom,
        right / zoom,
        top / zoom,
        bottom / zoom,
        near,
        far
      );
      this.cameraType = "orthographic";
      this.projectionMatrix.frustum(this.frustum, this.#bounds.left, this.#bounds.right, this.#bounds.top, this.#bounds.bottom, this.#near, this.#far);
    }
    lookAt(t) {
      super.lookAt(t, true);
      return this;
    }
    updateMatrixWorld() {
      super.updateMatrixWorld();
      this.viewMatrix.invert(this.worldMatrix);
      this.worldMatrix.getTranslation(this.worldPosition);
      this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);
      return this;
    }
    frustumIntersectsMesh(node, worldMatrix = node.worldMatrix) {
      if (!node.geometry.attributes.position)
        return true;
      if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity)
        node.geometry.computeBoundingSphere();
      if (!node.geometry.bounds)
        return true;
      const center = tempVec3a;
      center.copy(node.geometry.bounds.center);
      center.applyMatrix4(worldMatrix);
      const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();
      return this.frustumIntersectsSphere(center, radius);
    }
    frustumIntersectsSphere(center, radius) {
      const normal = tempVec3b;
      for (let i = 0; i < 6; i++) {
        const plane = this.frustum[i];
        const distance = normal.copy(plane).dot(center) + plane.constant;
        if (distance < -radius)
          return false;
      }
      return true;
    }
    project(v) {
      v.applyMatrix4(this.viewMatrix);
      v.applyMatrix4(this.projectionMatrix);
      return this;
    }
    unproject(v) {
      v.applyMatrix4(tempMat4.invert(this.projectionMatrix));
      v.applyMatrix4(this.worldMatrix);
      return this;
    }
    updateProjectionMatrix() {
      throw new Error(ERR_CAMERA_METHOD_UNDEFINED);
    }
  }

  class PerspectiveCamera extends Camera {
    constructor(fov, aspect, near, far) {
      super({
        fov,
        aspect,
        near,
        far
      });
    }
    updateProjectionMatrix() {
      this.projectionMatrix.fromPerspective(this.fov, this.aspect, this.near, this.far);
    }
  }

  class OrthographicCamera extends Camera {
    constructor(left, right, top, bottom, near, far, zoom = 1) {
      super({
        bounds: {
          left,
          right,
          top,
          bottom
        },
        near,
        far,
        zoom
      });
    }
    updateProjectionMatrix() {
      const {
        left,
        right,
        top,
        bottom
      } = this.bounds;
      const { zoom } = this;
      this.projectionMatrix.orthographic(
        left / zoom,
        right / zoom,
        top / zoom,
        bottom / zoom,
        this.near,
        this.far
      );
    }
  }

  exports.BlendType = BlendType;
  exports.Box = Box;
  exports.BufferAttribute = BufferAttribute;
  exports.Camera = Camera;
  exports.Clock = Clock;
  exports.Color = Color;
  exports.DataTexture = DataTexture;
  exports.Euler = Euler;
  exports.EventEmitter = EventEmitter;
  exports.Geometry = Geometry;
  exports.Matrix3 = Matrix3;
  exports.Matrix4 = Matrix4;
  exports.Mesh = Mesh;
  exports.Object3D = Object3D;
  exports.OrthographicCamera = OrthographicCamera;
  exports.PerspectiveCamera = PerspectiveCamera;
  exports.Plane = Plane;
  exports.Program = Program;
  exports.ProjectionMatrix = ProjectionMatrix;
  exports.Quaternion = Quaternion;
  exports.Raf = Raf;
  exports.RenderBuffer = RenderBuffer;
  exports.RenderTarget = RenderTarget;
  exports.Renderer = Renderer;
  exports.Resource = Resource;
  exports.Scene = Scene;
  exports.State = State;
  exports.Texture = Texture;
  exports.Texture3D = Texture3D;
  exports.Vector2 = Vector2;
  exports.Vector3 = Vector3;
  exports.Vector4 = Vector4;
  exports.getPlaneBuffer = getPlaneBuffer;
  exports.highPrecision = highPrecision;
  exports.utils = index;

}));
//# sourceMappingURL=index.js.map
