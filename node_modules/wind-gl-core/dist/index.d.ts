import * as _sakitam_gis_vis_engine from '@sakitam-gis/vis-engine';
import { Program, Mesh, Geometry, Texture, Renderer, EventEmitter, Attributes, Scene } from '@sakitam-gis/vis-engine';

type BandType = 0 | 1 | 2 | 3;
declare enum RenderType {
    /**
     * 栅格类型图层
     */
    image = 0,
    /**
     * 色斑图
     */
    colorize = 1,
    /**
     * 粒子
     */
    particles = 2,
    /**
     * 矢量场箭头图层
     */
    arrow = 3,
    /**
     * 风羽图
     */
    barb = 4,
    /**
     * 海浪和波
     */
    wave = 5
}
declare enum RenderFrom {
    /**
     * 标量值
     * 一般需要配合数据配置中的 dataRange 字段解析原始值；
     * 当然也可以从图像的 `Exif` 信息中提取
     */
    r = "r",
    /**
     * 矢量值，常见于气象要素的风速和风向等描述大小和方向的数据
     * 一般需要配合数据配置中的 dataRange 字段解析原始值；
     * 当然也可以从图像的 `Exif` 信息中提取
     */
    rg = "rg",
    /**
     * 一般用于浮点值（需要在 glsl 中做 rgba2float 转换）
     */
    rgba = "rgba",
    /**
     * 浮点值，一般存储在 r 通道或者使用 `LUMINANCE` 通道（精度最高）
     */
    float = "float"
}
declare function getBandType(renderFrom: RenderFrom): 0 | 1 | 2 | 3;
/**
 * 解析类型
 */
declare enum DecodeType {
    /**
     * 以 `ImageBitmap` 图像解析
     */
    image = 0,
    /**
     * 解析为 `Uint8Array`
     */
    unit8 = 1,
    /**
     * 使用 `GeoTIFF` 作为解析器
     */
    tiff = 2,
    /**
     * 解析带有 `Exif` 的图像，一般我们使用单通道 `RenderFrom.r` 或者 `RenderFrom.rg`
     * 可能从 Exif 信息中提取原始值范围。
     */
    imageWithExif = 3
}
declare enum LayerSourceType {
    image = "image",
    tile = "tile",
    timeline = "timeline"
}
/**
 * 瓦片尺寸
 */
type TileSize = number;
/**
 * 数据范围
 */
type DataRange = [number, number];
type Coordinates = [[number, number], [number, number], [number, number], [number, number]];
interface ImageSourceOptions {
    url: string | [string, string];
    /**
     * top left, top right, bottom right, bottom left
     */
    coordinates: Coordinates;
    type?: LayerSourceType.image;
    dataRange?: DataRange | [DataRange, DataRange];
    /**
     * 指定数据解析类型
     */
    decodeType?: DecodeType;
    /**
     * 是否跨世界渲染
     */
    wrapX?: boolean;
    maxTileCacheSize?: number;
}
type Bounds = [number, number, number, number];
interface TileSourceOptions {
    url: string | [string, string];
    type?: LayerSourceType.tile;
    minZoom?: number;
    maxZoom?: number;
    tileSize?: TileSize;
    dataRange?: DataRange | [DataRange, DataRange];
    scheme?: 'xyz' | 'tms';
    subdomains?: (string | number)[];
    roundZoom?: boolean;
    /**
     * 指定数据解析类型
     */
    decodeType?: DecodeType;
    /**
     * 是否跨世界渲染
     */
    wrapX?: boolean;
    maxTileCacheSize?: number;
    tileBounds?: Bounds;
}
type LayerData = ImageSourceOptions | TileSourceOptions;
/**
 * 瓦片状态
 */
declare enum TileState {
    /**
     * 加载中
     */
    loading = "0",
    /**
     * 加载完成
     */
    loaded = "1",
    /**
     * 加载失败
     */
    errored = "2",
    /**
     * 未加载
     */
    unloaded = "3",
    /**
     * 重新加载
     */
    reloading = "4"
}
/**
 * 瓦片范围 (经纬度) [xmin, ymin, xmax, ymax]
 */
type TileBounds = Bounds;
/**
 * 投影后的瓦片范围
 */
interface ProjTileBounds {
    left: number;
    top: number;
    right: number;
    bottom: number;
}
interface ParseOptionsType {
    renderFrom: RenderFrom;
}
/**
 * 图层掩膜类型
 * 0. 不包含：区域外显示
 * 1. 包含：区域内显示
 */
declare enum MaskType {
    outside = 0,
    inside = 1
}

declare class TileMesh {
    id: string;
    program: Program;
    /**
     * 用于地图投影下的 Mesh
     */
    mesh: Mesh;
    /**
     * 用于平面绘制的 Mesh，常用于瓦片合并 Pass
     */
    planeMesh: Mesh;
    constructor(id: any, renderer: any, program: any, geometry: any);
    setCenter(center: number[]): void;
    getMesh(): Mesh;
    destroy(): void;
}

interface TileIDOptions {
    getTileBounds?: (tileID: TileID) => TileBounds;
    getTileProjBounds: (tileID: TileID) => ProjTileBounds;
}
declare class TileID {
    /**
     * 瓦片列
     */
    x: number;
    /**
     * 跨世界后的瓦片列
     */
    wrapedX: number;
    /**
     * 瓦片行
     */
    y: number;
    /**
     * 跨世界后的瓦片行（目前仅 maptalks 支持）
     */
    wrapedY: number;
    /**
     * 瓦片层级
     */
    z: number;
    /**
     * 所在世界（如果是多世界的话）
     */
    wrap: number;
    /**
     * 放大后的 zoom 值
     */
    overscaledZ: number;
    /**
     * 瓦片唯一标识
     */
    tileKey: string;
    /**
     * 不包含跨世界的瓦片标识（因为多个世界的瓦片如果仅仅是 `wrap` 不同，他们对应的数据资源是完全相同的）
     */
    unWrappedTileKey: string;
    /**
     * 瓦片范围（每次获取时计算）
     */
    tileBounds: TileBounds;
    /**
     * 投影后的瓦片范围
     */
    projTileBounds: ProjTileBounds;
    options: TileIDOptions;
    /**
     * 挂载的其他数据
     */
    dep: any;
    /**
     * @param overscaledZ 扩大的 z 值
     * @param wrap 所处世界
     * @param z 层级
     * @param x 列
     * @param y 行
     * @param options 瓦片其他配置
     */
    constructor(overscaledZ: number, wrap: number | undefined, z: number, x: number, y: number, options?: TileIDOptions);
    /**
     * 获取瓦片范围
     */
    getTileBounds(tileID?: this): Bounds;
    /**
     * 获取瓦片投影后的范围
     */
    getTileProjBounds(tileID?: this, force?: boolean): ProjTileBounds;
    overscaleFactor(): number;
    /**
     * 缩放到目标层级
     * @param targetZ
     */
    scaledTo(targetZ: number): TileID;
    /**
     * 获取父级瓦片
     */
    parent(): TileID;
    /**
     * 查找当前瓦片的子瓦片
     * @param sourceMaxZoom
     */
    children(sourceMaxZoom: number): TileID[];
    /**
     * 查找兄弟瓦片
     */
    siblings(): TileID[];
    /**
     * 查找相临瓦片
     * @param hor 横向偏移
     * @param ver 纵向偏移
     */
    neighbor(hor: number, ver?: number): TileID;
    /**
     * 判断瓦片是否相同
     * 一般我们认为只要 xyz 和所处世界 wrap 相同就确认相同（即 tileKey 相同）
     * @param tile
     */
    isEqual(tile: TileID): boolean;
    /**
     * 判断是否是根节点
     * @returns {boolean}
     */
    isRoot(): boolean;
}

interface TileOptions {
    tileBounds?: TileBounds;
    tileSize: number;
}
/**
 * 这里是一个内部的瓦片实现，他主要是为了统各地图类库的瓦片相关操作
 * 我们常规需要的是在某个地图类库下某个瓦片的 xyz 以及其对应投影下
 * 的瓦片范围（常规情况使用世界坐标，部分类库可能直接使用像素位置并且在每一帧更新），
 * 并且在此我们需要维护瓦片的状态。
 */
declare class Tile {
    #private;
    /**
     * 瓦片 是否取消请求
     */
    aborted: boolean;
    /**
     * 瓦片重加载回调
     */
    reloadCallback: any;
    /**
     * worker 执行器
     */
    actor: any;
    /**
     * 瓦片 ID
     */
    tileID: TileID;
    /**
     * 瓦片数据加载状态
     */
    state: TileState;
    /**
     * 瓦片加载失败的次数
     */
    errorCount: number;
    /**
     * 允许的瓦片最大失败次数
     */
    maxErrorCount: number;
    /**
     * 瓦片的世界范围
     */
    tileBounds: ProjTileBounds;
    /**
     * 瓦片尺寸
     */
    tileSize: number;
    /**
     * 瓦片使用次数（在多个 render 共享 source 时，瓦片只能在为被任何渲染器使用时才能被销毁）
     */
    uses: number;
    tileMeshs: Map<string, TileMesh>;
    geometries: Map<string, Geometry>;
    request: Map<string, any>;
    /**
     * @param tileID
     * @param options
     */
    constructor(tileID: TileID, options?: TileOptions);
    /**
     * 瓦片是否已经加载到数据
     */
    hasData(): boolean;
    /**
     * 瓦片是否已经请求过
     */
    wasRequested(): boolean;
    /**
     * 瓦片是否加载完成
     */
    isLoaded(): boolean;
    getMesh(passId: any): TileMesh | undefined;
    get textures(): Map<number, Texture<_sakitam_gis_vis_engine.TextureOptions>>;
    get tileCenter(): number[];
    /**
     * 更新瓦片顶点信息
     * @param passId
     * @param bbox
     * @param renderer
     * @param force
     */
    updateGeometry(passId: string, bbox: ProjTileBounds, renderer: Renderer, force?: boolean): Geometry | undefined;
    /**
     * 创建 `TileMesh`
     * @param passId 在多个 render pass 共享 tile 时我们可能需要针对多个 pass 创建渲染资源
     * 在 mapbox 这种共享 gl 上下文的一般我们不需要重建，但是对于 maptalks 这种每个图层一个 gl
     * 上下文的我们需要针对每个 gl上下文绑定资源
     * @param bbox
     * @param renderer
     * @param program
     * @param force
     */
    createMesh(passId: string, bbox: ProjTileBounds, renderer: Renderer, program: Program, force?: boolean): TileMesh | undefined;
    /**
     * 创建纹理
     * @param renderer
     * @param index
     * @param image
     * @param parseOptions
     * @param userData
     */
    setTextures(renderer: Renderer, index: number, image: any, parseOptions: ParseOptionsType, userData?: any): void;
    /**
     * 获取瓦片世界坐标系下的范围
     */
    getBounds(): ProjTileBounds;
    copy(tile: Tile): this;
    /**
     * 释放瓦片资源
     */
    destroy(): void;
}

interface ImageSourceInterval {
    url: ImageSourceOptions['url'];
}
declare class ImageSource extends EventEmitter {
    #private;
    /**
     * 数据源 id
     */
    id: string;
    /**
     * 数据源类型
     */
    type: LayerSourceType.image;
    /**
     * 支持的最小层级
     */
    minZoom: number;
    /**
     * 支持的最大层级
     */
    maxZoom: number;
    /**
     * 是否对层级进行四舍五入
     */
    roundZoom: boolean;
    /**
     * 瓦片大小
     */
    tileSize: number;
    /**
     * 配置项
     */
    options: ImageSourceOptions;
    url: ImageSourceOptions['url'];
    renderer: Renderer;
    dispatcher: any;
    layer: WithNull<BaseLayer>;
    parseOptions: ParseOptionsType;
    /**
     * 影像坐标
     */
    coordinates: ImageSourceOptions['coordinates'];
    /**
     * 是否跨世界渲染
     */
    wrapX: boolean;
    constructor(id: any, options: ImageSourceOptions);
    get sourceCache(): SourceCache;
    onAdd(layer: any, cb?: any): void;
    prepare(renderer: Renderer, dispatcher: any, parseOptions: ParseOptionsType): void;
    update(data: ImageSourceInterval, clear?: boolean): void;
    updateImage(options: Pick<ImageSourceOptions, 'url' | 'coordinates'>, clear?: boolean): void;
    setCoordinates(coordinates: ImageSourceOptions['coordinates']): void;
    asyncActor(tile: any, url: any): Promise<unknown>;
    /**
     * 兼容 TileJSON 加载，需要具体实现
     * @param cb
     */
    load(cb?: any): void;
    loaded(): boolean;
    reload(clear: any): void;
    getTileUrl(tileID: any): string[];
    loadTile(tile: Tile, callback: any): any;
    hasTile(coord: any): boolean;
    getFadeTime(): number;
    abortTile(tile: Tile, callback: any): void;
    unloadTile(tile: any, cb: any): void;
    destroy(): void;
}

declare class SourceCache extends EventEmitter {
    #private;
    id: string;
    source: TileSource | ImageSource;
    private readonly cacheTiles;
    private coveredTiles;
    private loadedParentTiles;
    /**
     * 这两个配置是用于控制瓦片数据的最大缩放级别的。
     * 在瓦片地图中，为了避免图像模糊或者失真，通常不会将某个瓦片数据过度缩放，
     * 而是使用它的父级瓦片或者子集瓦片数据进行显示。
     * 这个缩放的范围就是通过 maxOverzooming 和 maxUnderzooming 属性来控制的
     */
    static maxOverzooming: number;
    static maxUnderzooming: number;
    constructor(id: any, source: any);
    /**
     * 判断当前 source 瓦片是否全部加载完毕（成功加载或者加载错误）
     */
    loaded(): boolean;
    /**
     * 调用 `Source` 的瓦片加载方法
     * 具体由各个`Source` 实现
     * @param tile
     * @param callback
     */
    loadTile(tile: any, callback: any): any;
    /**
     * 移除已加载的瓦片
     * @param tile
     */
    unloadTile(tile: any): void;
    /**
     * 取消正在加载中的瓦片
     * @param tile
     */
    abortTile(tile: any): void;
    /**
     * 获取所有的可渲染的瓦片 id 并且排序（从 0 世界向两边排序）
     */
    getRenderableIds(): any[];
    _isIdRenderable(id: any): boolean;
    /**
     * 获取已经加载的瓦片
     */
    getVisibleCoordinates(): TileID[];
    /**
     * 瓦片加载完成回调
     * @param tile
     * @param id
     * @param previousState
     * @param err
     * @param disableUpdate
     */
    tileLoaded(tile: any, id: any, previousState: any, err: any, disableUpdate?: boolean): void;
    _addTile(tileID: any): WithNull<Tile>;
    /**
     * 根据 `tileKey` 移除瓦片
     * @param id
     */
    _removeTile(id: any): void;
    /**
     * 根据 `TileID` 获取瓦片
     * @param tileID
     */
    getTile(tileID: any): Tile;
    /**
     * 该策略会在内存中保留当前层级的瓦片的所有子瓦片（children），直到一直保留到最大覆盖缩放级别（maxCoveringZoom）为止。
     * 简单来说，当当前地图缩放等级超过了当前图层的最大缩放级别时，Mapbox GL JS 会自动加载当前瓦片的所有子瓦片来填充当前视图的空白部分。而 retain any loaded children of ideal tiles up to maxCoveringZoom 这个选项会保留这些子瓦片的缓存，以便在缩放到更高层级时直接使用，而不需要重新加载。
     * 举个例子，假设当前地图缩放等级是 10，最大缩放级别是 14，而 maxCoveringZoom 设置为 12。地图将会加载当前缩放级别为 10 的瓦片，并将其所有子瓦片缓存到内存中，包括缩放级别为 11、12、13 的所有瓦片。但是，因为 maxCoveringZoom 设置为 12，所以缩放到 13 级时，只会使用缓存中缩放级别为 11、12 的子瓦片。当缩放到 14 级时，则不再使用缓存，而是重新加载新的瓦片数据。
     * 需要注意的是，这个选项可能会占用大量内存，因此在使用时需要根据实际情况进行设置。如果需要优化内存使用，可以将 maxCoveringZoom 设置为一个较小的值，以减少缓存的瓦片数量。
     * @param idealTiles
     * @param zoom
     * @param maxCoveringZoom
     * @param retain
     */
    retainLoadedChildren(idealTiles: any, zoom: any, maxCoveringZoom: any, retain: any): void;
    updateLoadedParentTileCache(): void;
    updateRetainedTiles(wrapTiles: any): {};
    /**
     * 获取已经加载的缓存瓦片
     * @param tileID
     * @return {*}
     */
    getLoadedTile(tileID: any): any;
    /**
     * 查找已经加载的父级瓦片
     * @param tileID
     * @param minCoveringZoom
     */
    findLoadedParent(tileID: any, minCoveringZoom: any): any;
    /**
     * 更新当前的缓存大小
     */
    updateCacheSize(): void;
    update(wrapTiles: any): void;
    /**
     * 重载当前视野内的瓦片（需要移除缓存）
     */
    reload(): void;
    _reloadTile(id: string, state: TileState): void;
    clearTiles(): void;
    /**
     * 查找覆盖 queryGeometry 的瓦片
     * @param {QueryGeometry} queryGeometry
     * @param {boolean} [visualizeQueryGeometry=false]
     * @param {boolean} use3DQuery
     * @returns
     * @private
     */
    tilesIn(queryGeometry: any): any[];
    destroy(): void;
}

interface TileSourceInterval {
    url: TileSourceOptions['url'];
}
declare class TileSource extends EventEmitter {
    #private;
    /**
     * 数据源 id
     */
    id: string;
    /**
     * 数据源类型
     */
    type: LayerSourceType.tile;
    /**
     * 支持的最小层级
     */
    minZoom: number;
    /**
     * 支持的最大层级
     */
    maxZoom: number;
    /**
     * 生成瓦片时的配置
     */
    roundZoom: boolean;
    /**
     * 瓦片规范
     */
    scheme: 'xyz' | 'tms';
    url: string | string[];
    /**
     * 瓦片大小
     */
    tileSize: number;
    tileBounds: TileSourceOptions['tileBounds'];
    /**
     * 配置项
     */
    options: TileSourceOptions;
    renderer: Renderer;
    dispatcher: any;
    layer: WithNull<BaseLayer>;
    /**
     * 是否跨世界渲染
     */
    wrapX: boolean;
    parseOptions: ParseOptionsType;
    constructor(id: any, options: TileSourceOptions);
    get sourceCache(): SourceCache;
    onAdd(layer: any, cb?: any): void;
    update(data: TileSourceInterval, clear?: boolean): this;
    prepare(renderer: Renderer, dispatcher: any, parseOptions: any): void;
    /**
     * 兼容 TileJSON 加载，需要具体实现
     * @param cb
     */
    load(cb?: any): void;
    loaded(): boolean;
    reload(clear: boolean): void;
    hasTile(coord: TileID): boolean;
    getFadeTime(): number;
    getUrl(x: number, y: number, z: number): string | string[];
    asyncActor(tile: Tile, url: string): Promise<unknown>;
    getTileUrl(tileID: TileID): string[];
    loadTile(tile: Tile, callback: any): any;
    abortTile(tile: Tile, callback: any): void;
    unloadTile(tile: Tile, callback: any): void;
    destroy(): void;
}

declare enum State {
    /**
     * 播放器初始状态
     */
    initial = 0,
    /**
     * 播放状态
     */
    playing = 1,
    /**
     * 暂停状态
     */
    paused = 2,
    /**
     * 停止状态
     */
    stopped = 3
}
interface TrackOptions {
    /**
     * 过渡时间
     */
    duration?: number;
    /**
     * 延迟时间
     */
    delay?: number;
    /**
     * 播放完成后是否延迟
     */
    endDelay?: number;
    /**
     * 是否轮播
     */
    repeat?: boolean;
    /**
     * 是否默认启动播放
     */
    autoplay?: boolean;
    /**
     * 回调
     * @param position
     */
    track?: (position: number) => void;
}
declare class Track extends EventEmitter {
    #private;
    constructor(options: TrackOptions);
    /**
     * 获取当前 Track 的状态
     */
    get state(): State;
    /**
     * 获取总的过渡时间
     */
    get totalDuration(): number;
    get elapsedTime(): number;
    get totalPosition(): number;
    /**
     * 是否在播放
     */
    get isPlaying(): boolean;
    /**
     * 是否暂停
     */
    get isPaused(): boolean;
    /**
     * 是否处于激活状态
     */
    get isActive(): boolean;
    /**
     * 获取当前 Track 的 cursor 位置
     */
    get position(): number;
    /**
     * 开始播放
     */
    play(): void;
    /**
     * 暂停
     */
    pause(): void;
    /**
     * 继续播放
     */
    resume(): void;
    /**
     * 停止
     */
    stop(): void;
    /**
     * 重新开始
     */
    restart(): void;
    /**
     * 重置
     */
    reset(): void;
    /**
     * 在播放和暂停状态切换
     */
    toggle(): void;
    /**
     * 步进
     * @param position
     * @param e
     */
    advance(position: any, e?: boolean): void;
    tick(time: any): void;
}

interface TimelineSourceOptions extends TrackOptions {
    sourceType: LayerSourceType;
    intervals: (ImageSourceInterval | TileSourceInterval)[];
    type?: LayerSourceType.timeline;
    /**
     * image source 配置
     */
    coordinates?: Coordinates;
    /**
     * tile source 配置
     */
    subdomains?: (string | number)[];
    minZoom?: number;
    maxZoom?: number;
    tileSize?: TileSize;
    dataRange?: DataRange | [DataRange, DataRange];
    scheme?: 'xyz' | 'tms';
    roundZoom?: number;
    /**
     * 指定数据解析类型
     */
    decodeType?: DecodeType;
    /**
     * 是否跨世界渲染
     */
    wrapX?: boolean;
    maxTileCacheSize?: number;
    tileBounds?: Bounds;
}
declare class TimelineSource extends EventEmitter {
    #private;
    /**
     * 数据源 id
     */
    id: string;
    /**
     * 数据源类型
     */
    type: LayerSourceType.timeline;
    /**
     * 支持的最小层级
     */
    minZoom: number;
    /**
     * 支持的最大层级
     */
    maxZoom: number;
    /**
     * 生成瓦片时的配置
     */
    roundZoom: boolean;
    /**
     * 瓦片大小
     */
    tileSize: number;
    /**
     * 影像坐标
     */
    coordinates: WithUndef<Coordinates>;
    /**
     * 配置项
     */
    options: TimelineSourceOptions;
    /**
     * 是否跨世界渲染
     */
    wrapX: boolean;
    renderer: Renderer;
    dispatcher: any;
    layer: WithNull<BaseLayer>;
    parseOptions: ParseOptionsType;
    tileBounds: TileSourceOptions['tileBounds'];
    intervals: TimelineSourceOptions['intervals'];
    constructor(id: string, options: TimelineSourceOptions);
    get track(): Track;
    get privateType(): LayerSourceType;
    get cache(): Map<string, any>;
    get source(): (ImageSource | TileSource)[];
    get sourceCache(): SourceCache[];
    onAdd(layer: any): void;
    prepare(renderer: Renderer, dispatcher: any, parseOptions: ParseOptionsType): void;
    getFadeTime(): number;
    tilesLoadEnd(): void;
    animate({ position }: {
        position: any;
    }): void;
    play(): void;
    pause(): void;
    resume(): void;
    stop(): void;
    restart(): void;
    load(cb?: any): void;
    loaded(): boolean;
    destroy(): void;
}

type SourceType = TileSource | ImageSource | TimelineSource;

interface UserOptions {
    /**
     * 渲染类型
     * 目前支持三种类型：
     * 0：普通 raster 瓦片渲染
     * 1：气象数据的色斑图渲染
     * 2：风等 vector 数据的粒子渲染
     */
    renderType: RenderType;
    /**
     * 指定渲染通道
     */
    renderFrom?: RenderFrom;
    styleSpec?: {
        'fill-color'?: any[];
        opacity?: number | any[];
        numParticles?: number | any[];
        speedFactor?: number | any[];
        fadeOpacity?: number | any[];
        dropRate?: number | any[];
        dropRateBump?: number | any[];
        /**
         * arrow space
         */
        space?: number | any[];
        /**
         * arrow size
         */
        size?: [number, number];
    };
    displayRange?: [number, number];
    widthSegments?: number;
    heightSegments?: number;
    wireframe?: boolean;
    flipY?: boolean;
    /**
     * 是否开启拾取
     */
    picking?: boolean;
    /**
     * 可以为任意 GeoJSON 数据
     */
    mask?: {
        data: Attributes[];
        type: MaskType;
    };
}
interface BaseLayerOptions extends UserOptions {
    /**
     * 获取当前视野内的瓦片
     */
    getViewTiles: (data: any, renderType: RenderType) => TileID[];
    /**
     * 这里我们 Mock 一个瓦片图层，用于获取视野内的所有可渲染瓦片，与getViewTiles不同的是
     * 此方法不会限制层级，方便我们在大层级时也能合理采样
     */
    getGridTiles: (source: SourceType) => TileID[];
    /**
     * 获取某层级下瓦片的投影宽高
     * @param z
     */
    getTileProjSize: (z: number, tiles: TileID[]) => [number, number];
    /**
     * 获取当前视图下像素和投影的转换关系
     */
    getPixelsToUnits: () => [number, number];
    /**
     * 像素到投影坐标的转换关系
     */
    getPixelsToProjUnit: () => [number, number];
    getZoom?: () => number;
    getExtent?: () => number[];
    triggerRepaint?: () => void;
    flipY?: boolean;
    glScale?: () => number;
    zoomScale?: () => number;
    onInit?: (error: any, data: any) => void;
}
declare const defaultOptions: BaseLayerOptions;
declare class BaseLayer {
    #private;
    private options;
    private readonly uid;
    private renderPipeline;
    private readonly scene;
    private readonly renderer;
    private readonly dispatcher;
    private readonly source;
    private raf;
    private sharedState;
    constructor(source: SourceType, rs: {
        renderer: Renderer;
        scene: Scene;
    }, options?: Partial<BaseLayerOptions>);
    initialize(): void;
    updateOptions(options: Partial<UserOptions>): void;
    resize(width: number, height: number): void;
    /**
     * 设置填色色阶
     */
    setFillColor(): void;
    /**
     * 设置图层透明度
     * @param opacity
     */
    setOpacity(opacity: number): void;
    /**
     * 设置粒子图层的粒子数量
     * @param numParticles
     */
    setNumParticles(numParticles: number): void;
    /**
     * 设置粒子图层的粒子数量
     * @param speedFactor
     */
    setSpeedFactor(speedFactor: number): void;
    /**
     * 设置粒子图层的粒子数量
     * @param fadeOpacity
     */
    setFadeOpacity(fadeOpacity: number): void;
    /**
     * 设置粒子图层的粒子数量
     * @param dropRate
     */
    setDropRate(dropRate: number): void;
    /**
     * 设置粒子图层的粒子数量
     * @param dropRateBump
     */
    setDropRateBump(dropRateBump: number): void;
    /**
     * 设置 symbol 的间距
     * @param space
     */
    setSymbolSpace(space: any): void;
    /**
     * 设置 symbol 的大小
     * @param size
     */
    setSymbolSize(size: any): void;
    /**
     * 解析样式配置
     * @param clear
     */
    parseStyleSpec(clear: any): void;
    /**
     * 处理地图缩放事件
     */
    handleZoom(): void;
    /**
     * 构建渲染所需色带
     */
    buildColorRamp(): void;
    clearStencil(): void;
    stencilConfigForOverlap(tiles: any[]): [{
        [_: number]: any;
    }, Tile[]];
    moveStart(): void;
    moveEnd(): void;
    /**
     * 更新视野内的瓦片
     */
    update(): void;
    onTileLoaded(): void;
    setMask(mask: BaseLayerOptions['mask']): void;
    picker(pixel?: number[]): Promise<any>;
    prerender(cameras: any, renderTarget?: any): void;
    render(cameras: any, renderTarget?: any): void;
    /**
     * 销毁此 Renderer
     */
    destroy(): void;
}

declare function calcMinMax(array: number[]): [number, number];
declare function isFunction(val: any): val is Function;
declare function findStopLessThanOrEqualTo(stops: number[], input: number): number;
/**
 * 使用相对地址时使用 `a.href` 和 `image.src` 可以获取完整的 url
 * 但是不同的是 `image.src` 会直接请求资源。
 * @param path
 */
declare function resolveURL(path: string): string;
/**
 * 判断大小端
 */
declare const littleEndian: boolean;
/**
 * 判断数据是否是 `ImageBitmap`
 * @param image
 */
declare function isImageBitmap(image: any): image is ImageBitmap;
/**
 * 从 exif 解析数据范围
 * @param exif
 */
declare function parseRange(exif: any): any;
/**
 * 获取两个对象中不同的 key
 * @param obj
 * @param other
 */
declare function keysDifference(obj: any, other: any): (string | number)[];
/**
 * extent1 是否包含 extent2
 *           extent1[3]
 *           |--------|
 *           |        |
 * extent1[0]|        |extent1[2]
 *           |--------|
 *           extent1[1]
 *
 *            extent2[3]
 *           |--------|
 *           |        |
 * extent2[0]|        |extent2[2]
 *           |--------|
 *           extent2[1]
 * @param extent1
 * @param extent2
 */
declare function intersects(extent1: Bounds, extent2: Bounds): boolean;
/**
 * extent1 是否包含 extent2
 *           extent1[3]
 *           |--------|
 *           |        |
 * extent1[0]|        |extent1[2]
 *           |--------|
 *           extent1[1]
 *
 *            extent2[3]
 *           |--------|
 *           |        |
 * extent2[0]|        |extent2[2]
 *           |--------|
 *           extent2[1]
 * @param extent1
 * @param extent2
 */
declare function containsExtent(extent1: Bounds, extent2: Bounds): boolean;
/**
 * 判断坐标是否在矩形范围内
 * @param {Array<number>} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
declare function containsXY(extent: any, x: any, y: any): boolean;
declare function inRange(value: number, start: number, end: number): boolean;
declare function mod(x: any, y: any): number;
declare function containTile(a: Bounds, b: Bounds): boolean;
/**
 * 将多面转换为单面
 * @returns {*}
 */
declare function flattenForPolygons(features: any): any[];
declare function polygon2buffer(features: any[]): Attributes[];

declare const configDeps: (d: string[]) => void;

export { type BandType, BaseLayer, type BaseLayerOptions, type Bounds, type Coordinates, type DataRange, DecodeType, ImageSource, type ImageSourceOptions, type LayerData, LayerSourceType, MaskType, type ParseOptionsType, type ProjTileBounds, RenderFrom, RenderType, type SourceType, Tile, type TileBounds, TileID, type TileSize, TileSource, type TileSourceOptions, TileState, TimelineSource, type UserOptions, calcMinMax, configDeps, containTile, containsExtent, containsXY, defaultOptions, findStopLessThanOrEqualTo, flattenForPolygons, getBandType, inRange, intersects, isFunction, isImageBitmap, keysDifference, littleEndian, mod, parseRange, polygon2buffer, resolveURL };
