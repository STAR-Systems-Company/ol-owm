type MessageListener = (a: {
    data: any;
    target: any;
}) => unknown;
interface WorkerInterface {
    addEventListener(type: 'message', listener: MessageListener): void;
    removeEventListener(type: 'message', listener: MessageListener): void;
    postMessage(message: any): void;
    terminate(): void;
}

/**
 * 创建`webworker` 线程池
 */
declare class WorkerPool {
    static workerCount: number;
    active: {
        [_ in number | string]: boolean;
    };
    workers: WithNull<WorkerInterface[]>;
    constructor();
    /**
     * 获取 `Worker` 实例
     * @param id
     */
    acquire(id: number | string): WorkerInterface[];
    /**
     * 释放所有 `Worker`
     * @param id
     */
    release(id: number | string): void;
    isPreloaded(): boolean;
    /**
     * 获取激活的`Worker` 数量
     */
    numActive(): number;
}

/**
 * Invokes the wrapped function in a non-blocking way when trigger() is called. Invocation requests
 * are ignored until the function was actually invoked.
 */
declare class ThrottledInvoker {
    channel: WithNull<MessageChannel>;
    triggered: boolean;
    callback: () => void;
    constructor(callback: () => void);
    trigger(): void;
    remove(): void;
}

/**
 * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
 * that maintains the relationship between asynchronous tasks and the objects
 * that spin them off - in this case, tasks like parsing parts of styles,
 * owned by the styles
 */
declare class Actor {
    target: any;
    parent: any;
    id: string;
    dispatcherId: number | undefined;
    callbacks: {
        number: any;
    };
    name: string;
    tasks: {
        [key: number]: any;
    };
    taskQueue: number[];
    cancelCallbacks: {
        number: Cancelable;
    };
    invoker: ThrottledInvoker;
    globalScope: any;
    constructor(target: any, parent: any, dispatcherId?: number);
    /**
     * Sends a message from a main-thread map to a Worker or from a Worker back to
     * a main-thread map instance.
     *
     * @param type The name of the target method to invoke or '[source-type].[source-name].name' for a method on a WorkerSource.
     * @param data
     * @param callback
     * @param targetId A particular mapId to which to send this message.
     * @param mustQueue
     * @private
     */
    send(type: string, data: unknown, callback?: () => void, targetId?: string | null, mustQueue?: boolean): Cancelable;
    receive(message: any): void;
    process(): void;
    processTask(id: number, task: any): void;
    remove(): void;
}

declare class Dispatcher {
    workerPool: WorkerPool;
    actors: Array<Actor>;
    currentActor: number;
    id: string;
    dispatcherId: number;
    constructor(workerPool: WorkerPool, parent: any, dispatcherId: number);
    /**
     * 广播到所有 Actor
     * @param type
     * @param data
     * @param cb
     */
    broadcast(type: string, data: unknown, cb?: (...args: any[]) => any): void;
    send(type: any, data: any, cb?: any, id?: string): void;
    /**
     * 获取要发送消息的 `Actor`
     * TIP: 是否需要实现 `Actor` 是否占用判断
     */
    getActor(id?: string): Actor;
    remove(removed?: boolean): void;
}

type Request = Promise<any> & {
    cancel: () => void;
};
interface IScheduleRequest {
    ref: () => Request;
    cancelled: boolean;
    completed: boolean;
    request: WithNull<Request>;
    cancel: () => void;
}
interface RequestSchedulerOptions {
    maxRequests: number;
}
declare class RequestScheduler {
    options: RequestSchedulerOptions;
    requestQueue: IScheduleRequest[];
    executing: Set<IScheduleRequest>;
    constructor(options: Partial<RequestSchedulerOptions>);
    remove(p: any): void;
    enqueue(): void;
    scheduleRequest(fn: any): IScheduleRequest;
}

interface RequestParameters {
    url: string;
    headers?: any;
    method?: 'GET' | 'POST' | 'PUT';
    body?: string;
    type?: 'string' | 'json' | 'arrayBuffer';
    credentials?: 'same-origin' | 'include';
    collectResourceTiming?: boolean;
}
type ResponseCallback<T> = (error?: Error | null, data?: T | null, cacheControl?: string | null, expires?: string | null) => void;
declare class RequestAdapter {
    requestScheduler: RequestScheduler;
    constructor(options: any);
    getResource(mapId: string, params: RequestParameters, callback: ResponseCallback<any>): Cancelable;
    /**
     * arrayBuffer 转 Unit8
     * @param data
     * @param callback
     */
    arrayBuffer2unit8(data: ArrayBuffer, callback: any): void;
    /**
     * arrayBuffer 转图像
     * 1. 如果支持 ImageBitmap 则生成 `ImageBitmap` 除了极少数浏览器不支持外兼容性尚可
     * 2. 在 safari 和移动浏览器下配合 rgba2float 有精度问题，不建议使用
     * @param data
     * @param callback
     */
    arrayBuffer2Image(data: ArrayBuffer, callback: any): void;
    /**
     * geotiff 解析
     * @param data
     * @param callback
     */
    arrayBuffer2tiff(data: ArrayBuffer, callback: any): void;
    /**
     * 解析 exif 信息
     * @param data
     * @param callback
     */
    parseExif(data: ArrayBuffer, callback: any): void;
    fetch(params: any, callback: any): {
        cancel: () => void;
    };
}
declare function getRequest(options?: {}, force?: boolean): RequestAdapter;

declare function setWorkerUrl(url: string): void;
/**
 * 设置外部依赖的路径
 * 一般我们在使用 importScripts 时需要指定
 * @param d
 */
declare function configDeps(d: string[]): void;
declare function getConfigDeps(): string[];

interface RegisterOptions<T> {
    omit?: ReadonlyArray<keyof T>;
    shallow?: ReadonlyArray<keyof T>;
}
/**
 * Register the given class as serializable.
 *
 * @param name
 * @param klass
 * @param options
 * @param options.omit List of properties to omit from serialization (e.g., cached/computed properties)
 * @param options.shallow List of properties that should be serialized by a simple shallow copy, rather than by a recursive call to serialize().
 *
 * @private
 */
declare function register<T>(name: string, klass: {
    new (...args: any): T;
}, options?: RegisterOptions<T>): void;

declare function asyncAll<Item, Result>(array: Array<Item>, fn: (item: Item, fnCallback: Callback<Result>) => void, callback: Callback<Array<Result>>): void;
/**
 *  Returns true if the when run in the web-worker context.
 *
 * @private
 * @returns {boolean}
 */
declare function isWorker(): boolean;
declare function warnOnce(message: string): void;
declare function isImageBitmap(image: any): image is ImageBitmap;
declare function isArrayBuffer(value: any): value is ArrayBuffer;
/**
 * Returns true when run in WebKit derived browsers.
 * This is used as a workaround for a memory leak in Safari caused by using Transferable objects to
 * transfer data between WebWorkers and the main thread.
 * https://github.com/mapbox/mapbox-gl-js/issues/8771
 *
 * This should be removed once the underlying Safari issue is fixed.
 *
 * @private
 * @param scope {WindowOrWorkerGlobalScope} Since this function is used both on the main thread and WebWorker context,
 *      let the calling scope pass in the global scope object.
 * @returns {boolean}
 */
declare function isSafari(scope: any): boolean;
declare function nullFunction(): void;
/**
 * 获取 uid
 * @param id= - Identifier base name
 * @param id
 * @return uid
 * */
declare function uid(id?: string): string;
declare function typeOf(value: any): string;
declare function isFunction(v: any): v is Function;
declare const getReferrer: () => any;
/**
 * 将 ArrayBuffer 转换为 ImageBitmap
 * @param data
 * @param callback
 */
declare function arrayBufferToImageBitmap(data: ArrayBuffer, callback: (err?: Error | null, image?: ImageBitmap | null) => void): void;
/**
 * 将 ArrayBuffer 转换为 Image
 * @param data
 * @param callback
 */
declare function arrayBufferToImage(data: ArrayBuffer, callback: (err?: Error | null, image?: HTMLImageElement | null) => void): void;
declare function unflatten(valuesInOneDimension: any, size: any): any[];
declare function parseMetedata(str: string): {
    [x: string]: string | number;
};

declare const utils_arrayBufferToImage: typeof arrayBufferToImage;
declare const utils_arrayBufferToImageBitmap: typeof arrayBufferToImageBitmap;
declare const utils_asyncAll: typeof asyncAll;
declare const utils_getReferrer: typeof getReferrer;
declare const utils_isArrayBuffer: typeof isArrayBuffer;
declare const utils_isFunction: typeof isFunction;
declare const utils_isImageBitmap: typeof isImageBitmap;
declare const utils_isSafari: typeof isSafari;
declare const utils_isWorker: typeof isWorker;
declare const utils_nullFunction: typeof nullFunction;
declare const utils_parseMetedata: typeof parseMetedata;
declare const utils_typeOf: typeof typeOf;
declare const utils_uid: typeof uid;
declare const utils_unflatten: typeof unflatten;
declare const utils_warnOnce: typeof warnOnce;
declare namespace utils {
  export { utils_arrayBufferToImage as arrayBufferToImage, utils_arrayBufferToImageBitmap as arrayBufferToImageBitmap, utils_asyncAll as asyncAll, utils_getReferrer as getReferrer, utils_isArrayBuffer as isArrayBuffer, utils_isFunction as isFunction, utils_isImageBitmap as isImageBitmap, utils_isSafari as isSafari, utils_isWorker as isWorker, utils_nullFunction as nullFunction, utils_parseMetedata as parseMetedata, utils_typeOf as typeOf, utils_uid as uid, utils_unflatten as unflatten, utils_warnOnce as warnOnce };
}

declare function getGlobalWorkerPool(): any;
declare function prewarm(): void;
declare const exported: {
    utils: typeof utils;
    request: typeof getRequest;
    register: typeof register;
    configDeps: typeof configDeps;
    getConfigDeps: typeof getConfigDeps;
    prewarm: typeof prewarm;
    getReferrer: () => any;
    setWorkerUrl: typeof setWorkerUrl;
    getGlobalWorkerPool: typeof getGlobalWorkerPool;
    Actor: typeof Actor;
    WorkerPool: typeof WorkerPool;
    Dispatcher: typeof Dispatcher;
    RequestScheduler: typeof RequestScheduler;
    ThrottledInvoker: typeof ThrottledInvoker;
};

export { exported as default };
