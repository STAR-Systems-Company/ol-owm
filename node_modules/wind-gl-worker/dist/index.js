(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.wgw = factory());
})(this, (function () { 'use strict';

/* eslint-disable */

var shared, worker, wgw;
function define(_, chunk) {
  if (!shared) {
    shared = chunk;
  } else if (!worker) {
    worker = chunk;
  } else {
    var workerBundleString = 'var sharedChunk = {}; (' + shared + ')(sharedChunk); (' + worker + ')(sharedChunk);'

    var sharedChunk = {};
    shared(sharedChunk);
    wgw = chunk(sharedChunk);
    if (typeof window !== 'undefined') {
      wgw.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' })));
    }
  }
}


define(['exports'], (function (exports) {
function asyncAll(array, fn, callback) {
  if (!array.length) {
    return callback(null, []);
  }
  let remaining = array.length;
  const results = new Array(array.length);
  let error = null;
  array.forEach((item, i) => {
    fn(item, (err, result) => {
      if (err) {
        error = err;
      }
      results[i] = result;
      if (--remaining === 0)
        callback(error, results);
    });
  });
}
function isWorker() {
  return typeof WorkerGlobalScope !== "undefined" && typeof self !== "undefined" && self instanceof WorkerGlobalScope;
}
const warnOnceHistory = {};
function warnOnce(message) {
  if (!warnOnceHistory[message]) {
    if (typeof console !== "undefined")
      console.warn(message);
    warnOnceHistory[message] = true;
  }
}
function isImageBitmap(image) {
  return typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
}
function isArrayBuffer(value) {
  return value && typeof ArrayBuffer !== "undefined" && (value instanceof ArrayBuffer || value.constructor && value.constructor.name === "ArrayBuffer");
}
let _isSafari = null;
function isSafari(scope) {
  if (_isSafari == null) {
    const userAgent = scope.navigator ? scope.navigator.userAgent : null;
    _isSafari = !!scope.safari || !!(userAgent && (/\b(iPad|iPhone|iPod)\b/.test(userAgent) || !!userAgent.match("Safari") && !userAgent.match("Chrome")));
  }
  return _isSafari;
}
function nullFunction() {
}
const uidCounters = {};
function uid(id = "id") {
  uidCounters[id] = uidCounters[id] ?? 0;
  const count = uidCounters[id]++;
  return `${id}-${count}`;
}
function typeOf(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}
function isFunction(v) {
  return typeOf(v) === "function";
}
const getReferrer = isWorker() ? () => self.worker && self.worker.referrer : () => (window.location.protocol === "blob:" ? window.parent : window).location.href;
function arrayBufferToImageBitmap(data, callback) {
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  createImageBitmap(blob).then((imgBitmap) => {
    callback(null, imgBitmap);
  }).catch((e) => {
    callback(
      new Error(
        `Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
      )
    );
  });
}
const transparentPngUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
function arrayBufferToImage(data, callback) {
  const img = new Image();
  img.onload = () => {
    callback(null, img);
    URL.revokeObjectURL(img.src);
    img.onload = null;
    window.requestAnimationFrame(() => {
      img.src = transparentPngUrl;
    });
  };
  img.onerror = () => callback(
    new Error(
      "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
    )
  );
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  img.src = data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
}
function unflatten(valuesInOneDimension, size) {
  const { height, width } = size;
  const valuesInTwoDimensions = [];
  for (let y = 0; y < height; y++) {
    const start = y * width;
    const end = start + width;
    valuesInTwoDimensions.push(valuesInOneDimension.slice(start, end));
  }
  return valuesInTwoDimensions;
}
function parseMetedata(str) {
  const array = str.split(",");
  const res = array.map((item) => {
    const kv = item.split(":");
    return {
      [kv[0]]: isNaN(parseFloat(kv[1])) ? kv[1] : parseFloat(kv[1])
    };
  });
  return res.reduce((pre, cur) => Object.assign({}, pre, cur), {});
}

var utils = /*#__PURE__*/Object.freeze({
__proto__: null,
arrayBufferToImage: arrayBufferToImage,
arrayBufferToImageBitmap: arrayBufferToImageBitmap,
asyncAll: asyncAll,
getReferrer: getReferrer,
isArrayBuffer: isArrayBuffer,
isFunction: isFunction,
isImageBitmap: isImageBitmap,
isSafari: isSafari,
isWorker: isWorker,
nullFunction: nullFunction,
parseMetedata: parseMetedata,
typeOf: typeOf,
uid: uid,
unflatten: unflatten,
warnOnce: warnOnce
});

function e(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var t="undefined"!=typeof self?self:global;const i="undefined"!=typeof navigator,s=i&&"undefined"==typeof HTMLImageElement,n=!("undefined"==typeof global||"undefined"==typeof process||!process.versions||!process.versions.node),r=t.Buffer,a=t.BigInt,o=!!r,h=e=>f(e)?void 0:e,l=e=>void 0!==e;function f(e){return void 0===e||(e instanceof Map?0===e.size:0===Object.values(e).filter(l).length)}function u(e){let t=new Error(e);throw delete t.stack,t}function d(e){return ""===(e=function(e){for(;e.endsWith("\0");)e=e.slice(0,-1);return e}(e).trim())?void 0:e}function c(e){let t=function(e){let t=0;return e.ifd0.enabled&&(t+=1024),e.exif.enabled&&(t+=2048),e.makerNote&&(t+=2048),e.userComment&&(t+=1024),e.gps.enabled&&(t+=512),e.interop.enabled&&(t+=100),e.ifd1.enabled&&(t+=1024),t+2048}(e);return e.jfif.enabled&&(t+=50),e.xmp.enabled&&(t+=2e4),e.iptc.enabled&&(t+=14e3),e.icc.enabled&&(t+=6e3),t}const g=e=>String.fromCharCode.apply(null,e),p="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):void 0;function m(e){return p?p.decode(e):o?Buffer.from(e).toString("utf8"):decodeURIComponent(escape(g(e)))}class y{static from(e,t){return e instanceof this&&e.le===t?e:new y(e,void 0,void 0,t)}constructor(e,t=0,i,s){if("boolean"==typeof s&&(this.le=s),Array.isArray(e)&&(e=new Uint8Array(e)),0===e)this.byteOffset=0,this.byteLength=0;else if(e instanceof ArrayBuffer){void 0===i&&(i=e.byteLength-t);let s=new DataView(e,t,i);this._swapDataView(s);}else if(e instanceof Uint8Array||e instanceof DataView||e instanceof y){void 0===i&&(i=e.byteLength-t),(t+=e.byteOffset)+i>e.byteOffset+e.byteLength&&u("Creating view outside of available memory in ArrayBuffer");let s=new DataView(e.buffer,t,i);this._swapDataView(s);}else if("number"==typeof e){let t=new DataView(new ArrayBuffer(e));this._swapDataView(t);}else u("Invalid input argument for BufferView: "+e);}_swapArrayBuffer(e){this._swapDataView(new DataView(e));}_swapBuffer(e){this._swapDataView(new DataView(e.buffer,e.byteOffset,e.byteLength));}_swapDataView(e){this.dataView=e,this.buffer=e.buffer,this.byteOffset=e.byteOffset,this.byteLength=e.byteLength;}_lengthToEnd(e){return this.byteLength-e}set(e,t,i=y){return e instanceof DataView||e instanceof y?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer&&(e=new Uint8Array(e)),e instanceof Uint8Array||u("BufferView.set(): Invalid data argument."),this.toUint8().set(e,t),new i(this,t,e.byteLength)}subarray(e,t){return t=t||this._lengthToEnd(e),new y(this,e,t)}toUint8(){return new Uint8Array(this.buffer,this.byteOffset,this.byteLength)}getUint8Array(e,t){return new Uint8Array(this.buffer,this.byteOffset+e,t)}getString(e=0,t=this.byteLength){return m(this.getUint8Array(e,t))}getLatin1String(e=0,t=this.byteLength){let i=this.getUint8Array(e,t);return g(i)}getUnicodeString(e=0,t=this.byteLength){const i=[];for(let s=0;s<t&&e+s<this.byteLength;s+=2)i.push(this.getUint16(e+s));return g(i)}getInt8(e){return this.dataView.getInt8(e)}getUint8(e){return this.dataView.getUint8(e)}getInt16(e,t=this.le){return this.dataView.getInt16(e,t)}getInt32(e,t=this.le){return this.dataView.getInt32(e,t)}getUint16(e,t=this.le){return this.dataView.getUint16(e,t)}getUint32(e,t=this.le){return this.dataView.getUint32(e,t)}getFloat32(e,t=this.le){return this.dataView.getFloat32(e,t)}getFloat64(e,t=this.le){return this.dataView.getFloat64(e,t)}getFloat(e,t=this.le){return this.dataView.getFloat32(e,t)}getDouble(e,t=this.le){return this.dataView.getFloat64(e,t)}getUintBytes(e,t,i){switch(t){case 1:return this.getUint8(e,i);case 2:return this.getUint16(e,i);case 4:return this.getUint32(e,i);case 8:return this.getUint64&&this.getUint64(e,i)}}getUint(e,t,i){switch(t){case 8:return this.getUint8(e,i);case 16:return this.getUint16(e,i);case 32:return this.getUint32(e,i);case 64:return this.getUint64&&this.getUint64(e,i)}}toString(e){return this.dataView.toString(e,this.constructor.name)}ensureChunk(){}}function b(e,t){u(`${e} '${t}' was not loaded, try using full build of exifr.`);}class w extends Map{constructor(e){super(),this.kind=e;}get(e,t){return this.has(e)||b(this.kind,e),t&&(e in t||function(e,t){u(`Unknown ${e} '${t}'.`);}(this.kind,e),t[e].enabled||b(this.kind,e)),super.get(e)}keyList(){return Array.from(this.keys())}}var S=new w("file parser"),k=new w("segment parser"),v=new w("file reader");let O=t.fetch;function x(e,t){return (s=e).startsWith("data:")||s.length>1e4?P(e,t,"base64"):n&&e.includes("://")?C(e,t,"url",A):n?P(e,t,"fs"):i?C(e,t,"url",A):void u("Invalid input argument");var s;}async function C(e,t,i,s){return v.has(i)?P(e,t,i):s?async function(e,t){let i=await t(e);return new y(i)}(e,s):void u(`Parser ${i} is not loaded`)}async function P(e,t,i){let s=new(v.get(i))(e,t);return await s.read(),s}const A=e=>O(e).then((e=>e.arrayBuffer())),U=e=>new Promise(((t,i)=>{let s=new FileReader;s.onloadend=()=>t(s.result||new ArrayBuffer),s.onerror=i,s.readAsArrayBuffer(e);}));class I extends Map{get tagKeys(){return this.allKeys||(this.allKeys=Array.from(this.keys())),this.allKeys}get tagValues(){return this.allValues||(this.allValues=Array.from(this.values())),this.allValues}}function B(e,t,i){let s=new I;for(let[e,t]of i)s.set(e,t);if(Array.isArray(t))for(let i of t)e.set(i,s);else e.set(t,s);return s}const L=new Map,D=new Map,T=new Map,z=["chunked","firstChunkSize","firstChunkSizeNode","firstChunkSizeBrowser","chunkSize","chunkLimit"],N=["jfif","xmp","icc","iptc","ihdr"],V=["tiff",...N],M=["ifd0","ifd1","exif","gps","interop"],E=[...V,...M],R=["makerNote","userComment"],j=["translateKeys","translateValues","reviveValues","multiSegment"],G=[...j,"sanitize","mergeOutput","silentErrors"];class H{get translate(){return this.translateKeys||this.translateValues||this.reviveValues}}class _ extends H{get needed(){return this.enabled||this.deps.size>0}constructor(t,i,s,n){if(super(),e(this,"enabled",!1),e(this,"skip",new Set),e(this,"pick",new Set),e(this,"deps",new Set),e(this,"translateKeys",!1),e(this,"translateValues",!1),e(this,"reviveValues",!1),this.key=t,this.enabled=i,this.parse=this.enabled,this.applyInheritables(n),this.canBeFiltered=M.includes(t),this.canBeFiltered&&(this.dict=L.get(t)),void 0!==s)if(Array.isArray(s))this.parse=this.enabled=!0,this.canBeFiltered&&s.length>0&&this.translateTagSet(s,this.pick);else if("object"==typeof s){if(this.enabled=!0,this.parse=!1!==s.parse,this.canBeFiltered){let{pick:e,skip:t}=s;e&&e.length>0&&this.translateTagSet(e,this.pick),t&&t.length>0&&this.translateTagSet(t,this.skip);}this.applyInheritables(s);}else !0===s||!1===s?this.parse=this.enabled=s:u(`Invalid options argument: ${s}`);}applyInheritables(e){let t,i;for(t of j)i=e[t],void 0!==i&&(this[t]=i);}translateTagSet(e,t){if(this.dict){let i,s,{tagKeys:n,tagValues:r}=this.dict;for(i of e)"string"==typeof i?(s=r.indexOf(i),-1===s&&(s=n.indexOf(Number(i))),-1!==s&&t.add(Number(n[s]))):t.add(i);}else for(let i of e)t.add(i);}finalizeFilters(){!this.enabled&&this.deps.size>0?(this.enabled=!0,q(this.pick,this.deps)):this.enabled&&this.pick.size>0&&q(this.pick,this.deps);}}var W={jfif:!1,tiff:!0,xmp:!1,icc:!1,iptc:!1,ifd0:!0,ifd1:!1,exif:!0,gps:!0,interop:!1,ihdr:void 0,makerNote:!1,userComment:!1,multiSegment:!1,skip:[],pick:[],translateKeys:!0,translateValues:!0,reviveValues:!0,sanitize:!0,mergeOutput:!0,silentErrors:!0,chunked:!0,firstChunkSize:void 0,firstChunkSizeNode:512,firstChunkSizeBrowser:65536,chunkSize:65536,chunkLimit:5},$=new Map;class K extends H{static useCached(e){let t=$.get(e);return void 0!==t||(t=new this(e),$.set(e,t)),t}constructor(e){super(),!0===e?this.setupFromTrue():void 0===e?this.setupFromUndefined():Array.isArray(e)?this.setupFromArray(e):"object"==typeof e?this.setupFromObject(e):u(`Invalid options argument ${e}`),void 0===this.firstChunkSize&&(this.firstChunkSize=i?this.firstChunkSizeBrowser:this.firstChunkSizeNode),this.mergeOutput&&(this.ifd1.enabled=!1),this.filterNestedSegmentTags(),this.traverseTiffDependencyTree(),this.checkLoadedPlugins();}setupFromUndefined(){let e;for(e of z)this[e]=W[e];for(e of G)this[e]=W[e];for(e of R)this[e]=W[e];for(e of E)this[e]=new _(e,W[e],void 0,this);}setupFromTrue(){let e;for(e of z)this[e]=W[e];for(e of G)this[e]=W[e];for(e of R)this[e]=!0;for(e of E)this[e]=new _(e,!0,void 0,this);}setupFromArray(e){let t;for(t of z)this[t]=W[t];for(t of G)this[t]=W[t];for(t of R)this[t]=W[t];for(t of E)this[t]=new _(t,!1,void 0,this);this.setupGlobalFilters(e,void 0,M);}setupFromObject(e){let t;for(t of(M.ifd0=M.ifd0||M.image,M.ifd1=M.ifd1||M.thumbnail,Object.assign(this,e),z))this[t]=Y(e[t],W[t]);for(t of G)this[t]=Y(e[t],W[t]);for(t of R)this[t]=Y(e[t],W[t]);for(t of V)this[t]=new _(t,W[t],e[t],this);for(t of M)this[t]=new _(t,W[t],e[t],this.tiff);this.setupGlobalFilters(e.pick,e.skip,M,E),!0===e.tiff?this.batchEnableWithBool(M,!0):!1===e.tiff?this.batchEnableWithUserValue(M,e):Array.isArray(e.tiff)?this.setupGlobalFilters(e.tiff,void 0,M):"object"==typeof e.tiff&&this.setupGlobalFilters(e.tiff.pick,e.tiff.skip,M);}batchEnableWithBool(e,t){for(let i of e)this[i].enabled=t;}batchEnableWithUserValue(e,t){for(let i of e){let e=t[i];this[i].enabled=!1!==e&&void 0!==e;}}setupGlobalFilters(e,t,i,s=i){if(e&&e.length){for(let e of s)this[e].enabled=!1;let t=X(e,i);for(let[e,i]of t)q(this[e].pick,i),this[e].enabled=!0;}else if(t&&t.length){let e=X(t,i);for(let[t,i]of e)q(this[t].skip,i);}}filterNestedSegmentTags(){let{ifd0:e,exif:t,xmp:i,iptc:s,icc:n}=this;this.makerNote?t.deps.add(37500):t.skip.add(37500),this.userComment?t.deps.add(37510):t.skip.add(37510),i.enabled||e.skip.add(700),s.enabled||e.skip.add(33723),n.enabled||e.skip.add(34675);}traverseTiffDependencyTree(){let{ifd0:e,exif:t,gps:i,interop:s}=this;s.needed&&(t.deps.add(40965),e.deps.add(40965)),t.needed&&e.deps.add(34665),i.needed&&e.deps.add(34853),this.tiff.enabled=M.some((e=>!0===this[e].enabled))||this.makerNote||this.userComment;for(let e of M)this[e].finalizeFilters();}get onlyTiff(){return !N.map((e=>this[e].enabled)).some((e=>!0===e))&&this.tiff.enabled}checkLoadedPlugins(){for(let e of V)this[e].enabled&&!k.has(e)&&b("segment parser",e);}}function X(e,t){let i,s,n,r,a=[];for(n of t){for(r of(i=L.get(n),s=[],i))(e.includes(r[0])||e.includes(r[1]))&&s.push(r[0]);s.length&&a.push([n,s]);}return a}function Y(e,t){return void 0!==e?e:void 0!==t?t:void 0}function q(e,t){for(let i of t)e.add(i);}e(K,"default",W);class J{constructor(t){e(this,"parsers",{}),e(this,"output",{}),e(this,"errors",[]),e(this,"pushToErrors",(e=>this.errors.push(e))),this.options=K.useCached(t);}async read(e){this.file=await function(e,t){return "string"==typeof e?x(e,t):i&&!s&&e instanceof HTMLImageElement?x(e.src,t):e instanceof Uint8Array||e instanceof ArrayBuffer||e instanceof DataView?new y(e):i&&e instanceof Blob?C(e,t,"blob",U):void u("Invalid input argument")}(e,this.options);}setup(){if(this.fileParser)return;let{file:e}=this,t=e.getUint16(0);for(let[i,s]of S)if(s.canHandle(e,t))return this.fileParser=new s(this.options,this.file,this.parsers),e[i]=!0;this.file.close&&this.file.close(),u("Unknown file format");}async parse(){let{output:e,errors:t}=this;return this.setup(),this.options.silentErrors?(await this.executeParsers().catch(this.pushToErrors),t.push(...this.fileParser.errors)):await this.executeParsers(),this.file.close&&this.file.close(),this.options.silentErrors&&t.length>0&&(e.errors=t),h(e)}async executeParsers(){let{output:e}=this;await this.fileParser.parse();let t=Object.values(this.parsers).map((async t=>{let i=await t.parse();t.assignToOutput(e,i);}));this.options.silentErrors&&(t=t.map((e=>e.catch(this.pushToErrors)))),await Promise.all(t);}async extractThumbnail(){this.setup();let{options:e,file:t}=this,i=k.get("tiff",e);var s;if(t.tiff?s={start:0,type:"tiff"}:t.jpeg&&(s=await this.fileParser.getOrFindSegment("tiff")),void 0===s)return;let n=await this.fileParser.ensureSegmentChunk(s),r=this.parsers.tiff=new i(n,e,t),a=await r.extractThumbnail();return t.close&&t.close(),a}}async function Z(e,t){let i=new J(t);return await i.read(e),i.parse()}class ee{constructor(t,i,s){e(this,"errors",[]),e(this,"ensureSegmentChunk",(async e=>{let t=e.start,i=e.size||65536;if(this.file.chunked)if(this.file.available(t,i))e.chunk=this.file.subarray(t,i);else try{e.chunk=await this.file.readChunk(t,i);}catch(t){u(`Couldn't read segment: ${JSON.stringify(e)}. ${t.message}`);}else this.file.byteLength>t+i?e.chunk=this.file.subarray(t,i):void 0===e.size?e.chunk=this.file.subarray(t):u("Segment unreachable: "+JSON.stringify(e));return e.chunk})),this.extendOptions&&this.extendOptions(t),this.options=t,this.file=i,this.parsers=s;}injectSegment(e,t){this.options[e].enabled&&this.createParser(e,t);}createParser(e,t){let i=new(k.get(e))(t,this.options,this.file);return this.parsers[e]=i}createParsers(e){for(let t of e){let{type:e,chunk:i}=t,s=this.options[e];if(s&&s.enabled){let t=this.parsers[e];t&&t.append||t||this.createParser(e,i);}}}async readSegments(e){let t=e.map(this.ensureSegmentChunk);await Promise.all(t);}}class te{static findPosition(e,t){let i=e.getUint16(t+2)+2,s="function"==typeof this.headerLength?this.headerLength(e,t,i):this.headerLength,n=t+s,r=i-s;return {offset:t,length:i,headerLength:s,start:n,size:r,end:n+r}}static parse(e,t={}){return new this(e,new K({[this.type]:t}),e).parse()}normalizeInput(e){return e instanceof y?e:new y(e)}constructor(t,i={},s){e(this,"errors",[]),e(this,"raw",new Map),e(this,"handleError",(e=>{if(!this.options.silentErrors)throw e;this.errors.push(e.message);})),this.chunk=this.normalizeInput(t),this.file=s,this.type=this.constructor.type,this.globalOptions=this.options=i,this.localOptions=i[this.type],this.canTranslate=this.localOptions&&this.localOptions.translate;}translate(){this.canTranslate&&(this.translated=this.translateBlock(this.raw,this.type));}get output(){return this.translated?this.translated:this.raw?Object.fromEntries(this.raw):void 0}translateBlock(e,t){let i=T.get(t),s=D.get(t),n=L.get(t),r=this.options[t],a=r.reviveValues&&!!i,o=r.translateValues&&!!s,h=r.translateKeys&&!!n,l={};for(let[t,r]of e)a&&i.has(t)?r=i.get(t)(r):o&&s.has(t)&&(r=this.translateValue(r,s.get(t))),h&&n.has(t)&&(t=n.get(t)||t),l[t]=r;return l}translateValue(e,t){return t[e]||t.DEFAULT||e}assignToOutput(e,t){this.assignObjectToOutput(e,this.constructor.type,t);}assignObjectToOutput(e,t,i){if(this.globalOptions.mergeOutput)return Object.assign(e,i);e[t]?Object.assign(e[t],i):e[t]=i;}}e(te,"headerLength",4),e(te,"type",void 0),e(te,"multiSegment",!1),e(te,"canHandle",(()=>!1));function ie(e){return 192===e||194===e||196===e||219===e||221===e||218===e||254===e}function se(e){return e>=224&&e<=239}function ne(e,t,i){for(let[s,n]of k)if(n.canHandle(e,t,i))return s}class re extends ee{constructor(...t){super(...t),e(this,"appSegments",[]),e(this,"jpegSegments",[]),e(this,"unknownSegments",[]);}static canHandle(e,t){return 65496===t}async parse(){await this.findAppSegments(),await this.readSegments(this.appSegments),this.mergeMultiSegments(),this.createParsers(this.mergedAppSegments||this.appSegments);}setupSegmentFinderArgs(e){!0===e?(this.findAll=!0,this.wanted=new Set(k.keyList())):(e=void 0===e?k.keyList().filter((e=>this.options[e].enabled)):e.filter((e=>this.options[e].enabled&&k.has(e))),this.findAll=!1,this.remaining=new Set(e),this.wanted=new Set(e)),this.unfinishedMultiSegment=!1;}async findAppSegments(e=0,t){this.setupSegmentFinderArgs(t);let{file:i,findAll:s,wanted:n,remaining:r}=this;if(!s&&this.file.chunked&&(s=Array.from(n).some((e=>{let t=k.get(e),i=this.options[e];return t.multiSegment&&i.multiSegment})),s&&await this.file.readWhole()),e=this.findAppSegmentsInRange(e,i.byteLength),!this.options.onlyTiff&&i.chunked){let t=!1;for(;r.size>0&&!t&&(i.canReadNextChunk||this.unfinishedMultiSegment);){let{nextChunkOffset:s}=i,n=this.appSegments.some((e=>!this.file.available(e.offset||e.start,e.length||e.size)));if(t=e>s&&!n?!await i.readNextChunk(e):!await i.readNextChunk(s),void 0===(e=this.findAppSegmentsInRange(e,i.byteLength)))return}}}findAppSegmentsInRange(e,t){t-=2;let i,s,n,r,a,o,{file:h,findAll:l,wanted:f,remaining:u,options:d}=this;for(;e<t;e++)if(255===h.getUint8(e))if(i=h.getUint8(e+1),se(i)){if(s=h.getUint16(e+2),n=ne(h,e,s),n&&f.has(n)&&(r=k.get(n),a=r.findPosition(h,e),o=d[n],a.type=n,this.appSegments.push(a),!l&&(r.multiSegment&&o.multiSegment?(this.unfinishedMultiSegment=a.chunkNumber<a.chunkCount,this.unfinishedMultiSegment||u.delete(n)):u.delete(n),0===u.size)))break;d.recordUnknownSegments&&(a=te.findPosition(h,e),a.marker=i,this.unknownSegments.push(a)),e+=s+1;}else if(ie(i)){if(s=h.getUint16(e+2),218===i&&!1!==d.stopAfterSos)return;d.recordJpegSegments&&this.jpegSegments.push({offset:e,length:s,marker:i}),e+=s+1;}return e}mergeMultiSegments(){if(!this.appSegments.some((e=>e.multiSegment)))return;let e=function(e,t){let i,s,n,r=new Map;for(let a=0;a<e.length;a++)i=e[a],s=i[t],r.has(s)?n=r.get(s):r.set(s,n=[]),n.push(i);return Array.from(r)}(this.appSegments,"type");this.mergedAppSegments=e.map((([e,t])=>{let i=k.get(e,this.options);if(i.handleMultiSegments){return {type:e,chunk:i.handleMultiSegments(t)}}return t[0]}));}getSegment(e){return this.appSegments.find((t=>t.type===e))}async getOrFindSegment(e){let t=this.getSegment(e);return void 0===t&&(await this.findAppSegments(0,[e]),t=this.getSegment(e)),t}}e(re,"type","jpeg"),S.set("jpeg",re);const ae=[void 0,1,1,2,4,8,1,1,2,4,8,4,8,4];class oe extends te{parseHeader(){var e=this.chunk.getUint16();18761===e?this.le=!0:19789===e&&(this.le=!1),this.chunk.le=this.le,this.headerParsed=!0;}parseTags(e,t,i=new Map){let{pick:s,skip:n}=this.options[t];s=new Set(s);let r=s.size>0,a=0===n.size,o=this.chunk.getUint16(e);e+=2;for(let h=0;h<o;h++){let o=this.chunk.getUint16(e);if(r){if(s.has(o)&&(i.set(o,this.parseTag(e,o,t)),s.delete(o),0===s.size))break}else !a&&n.has(o)||i.set(o,this.parseTag(e,o,t));e+=12;}return i}parseTag(e,t,i){let{chunk:s}=this,n=s.getUint16(e+2),r=s.getUint32(e+4),a=ae[n];if(a*r<=4?e+=8:e=s.getUint32(e+8),(n<1||n>13)&&u(`Invalid TIFF value type. block: ${i.toUpperCase()}, tag: ${t.toString(16)}, type: ${n}, offset ${e}`),e>s.byteLength&&u(`Invalid TIFF value offset. block: ${i.toUpperCase()}, tag: ${t.toString(16)}, type: ${n}, offset ${e} is outside of chunk size ${s.byteLength}`),1===n)return s.getUint8Array(e,r);if(2===n)return d(s.getString(e,r));if(7===n)return s.getUint8Array(e,r);if(1===r)return this.parseTagValue(n,e);{let t=new(function(e){switch(e){case 1:return Uint8Array;case 3:return Uint16Array;case 4:return Uint32Array;case 5:return Array;case 6:return Int8Array;case 8:return Int16Array;case 9:return Int32Array;case 10:return Array;case 11:return Float32Array;case 12:return Float64Array;default:return Array}}(n))(r),i=a;for(let s=0;s<r;s++)t[s]=this.parseTagValue(n,e),e+=i;return t}}parseTagValue(e,t){let{chunk:i}=this;switch(e){case 1:return i.getUint8(t);case 3:return i.getUint16(t);case 4:return i.getUint32(t);case 5:return i.getUint32(t)/i.getUint32(t+4);case 6:return i.getInt8(t);case 8:return i.getInt16(t);case 9:return i.getInt32(t);case 10:return i.getInt32(t)/i.getInt32(t+4);case 11:return i.getFloat(t);case 12:return i.getDouble(t);case 13:return i.getUint32(t);default:u(`Invalid tiff type ${e}`);}}}class he extends oe{static canHandle(e,t){return 225===e.getUint8(t+1)&&1165519206===e.getUint32(t+4)&&0===e.getUint16(t+8)}async parse(){this.parseHeader();let{options:e}=this;return e.ifd0.enabled&&await this.parseIfd0Block(),e.exif.enabled&&await this.safeParse("parseExifBlock"),e.gps.enabled&&await this.safeParse("parseGpsBlock"),e.interop.enabled&&await this.safeParse("parseInteropBlock"),e.ifd1.enabled&&await this.safeParse("parseThumbnailBlock"),this.createOutput()}safeParse(e){let t=this[e]();return void 0!==t.catch&&(t=t.catch(this.handleError)),t}findIfd0Offset(){void 0===this.ifd0Offset&&(this.ifd0Offset=this.chunk.getUint32(4));}findIfd1Offset(){if(void 0===this.ifd1Offset){this.findIfd0Offset();let e=this.chunk.getUint16(this.ifd0Offset),t=this.ifd0Offset+2+12*e;this.ifd1Offset=this.chunk.getUint32(t);}}parseBlock(e,t){let i=new Map;return this[t]=i,this.parseTags(e,t,i),i}async parseIfd0Block(){if(this.ifd0)return;let{file:e}=this;this.findIfd0Offset(),this.ifd0Offset<8&&u("Malformed EXIF data"),!e.chunked&&this.ifd0Offset>e.byteLength&&u(`IFD0 offset points to outside of file.\nthis.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e.byteLength}`),e.tiff&&await e.ensureChunk(this.ifd0Offset,c(this.options));let t=this.parseBlock(this.ifd0Offset,"ifd0");return 0!==t.size?(this.exifOffset=t.get(34665),this.interopOffset=t.get(40965),this.gpsOffset=t.get(34853),this.xmp=t.get(700),this.iptc=t.get(33723),this.icc=t.get(34675),this.options.sanitize&&(t.delete(34665),t.delete(40965),t.delete(34853),t.delete(700),t.delete(33723),t.delete(34675)),t):void 0}async parseExifBlock(){if(this.exif)return;if(this.ifd0||await this.parseIfd0Block(),void 0===this.exifOffset)return;this.file.tiff&&await this.file.ensureChunk(this.exifOffset,c(this.options));let e=this.parseBlock(this.exifOffset,"exif");return this.interopOffset||(this.interopOffset=e.get(40965)),this.makerNote=e.get(37500),this.userComment=e.get(37510),this.options.sanitize&&(e.delete(40965),e.delete(37500),e.delete(37510)),this.unpack(e,41728),this.unpack(e,41729),e}unpack(e,t){let i=e.get(t);i&&1===i.length&&e.set(t,i[0]);}async parseGpsBlock(){if(this.gps)return;if(this.ifd0||await this.parseIfd0Block(),void 0===this.gpsOffset)return;let e=this.parseBlock(this.gpsOffset,"gps");return e&&e.has(2)&&e.has(4)&&(e.set("latitude",le(...e.get(2),e.get(1))),e.set("longitude",le(...e.get(4),e.get(3)))),e}async parseInteropBlock(){if(!this.interop&&(this.ifd0||await this.parseIfd0Block(),void 0!==this.interopOffset||this.exif||await this.parseExifBlock(),void 0!==this.interopOffset))return this.parseBlock(this.interopOffset,"interop")}async parseThumbnailBlock(e=!1){if(!this.ifd1&&!this.ifd1Parsed&&(!this.options.mergeOutput||e))return this.findIfd1Offset(),this.ifd1Offset>0&&(this.parseBlock(this.ifd1Offset,"ifd1"),this.ifd1Parsed=!0),this.ifd1}async extractThumbnail(){if(this.headerParsed||this.parseHeader(),this.ifd1Parsed||await this.parseThumbnailBlock(!0),void 0===this.ifd1)return;let e=this.ifd1.get(513),t=this.ifd1.get(514);return this.chunk.getUint8Array(e,t)}get image(){return this.ifd0}get thumbnail(){return this.ifd1}createOutput(){let e,t,i,s={};for(t of M)if(e=this[t],!f(e))if(i=this.canTranslate?this.translateBlock(e,t):Object.fromEntries(e),this.options.mergeOutput){if("ifd1"===t)continue;Object.assign(s,i);}else s[t]=i;return this.makerNote&&(s.makerNote=this.makerNote),this.userComment&&(s.userComment=this.userComment),s}assignToOutput(e,t){if(this.globalOptions.mergeOutput)Object.assign(e,t);else for(let[i,s]of Object.entries(t))this.assignObjectToOutput(e,i,s);}}function le(e,t,i,s){var n=e+t/60+i/3600;return "S"!==s&&"W"!==s||(n*=-1),n}e(he,"type","tiff"),e(he,"headerLength",10),k.set("tiff",he);const ue={ifd0:!1,ifd1:!1,exif:!1,gps:!1,interop:!1,sanitize:!1,reviveValues:!0,translateKeys:!1,translateValues:!1,mergeOutput:!1};Object.assign({},ue,{firstChunkSize:4e4,gps:[1,2,3,4]});Object.assign({},ue,{tiff:!1,ifd1:!0,mergeOutput:!1});Object.assign({},ue,{firstChunkSize:4e4,ifd0:[274]});if("object"==typeof navigator){let e=navigator.userAgent;if(e.includes("iPad")||e.includes("iPhone")){e.match(/OS (\d+)_(\d+)/);}else if(e.includes("OS X 10")){e.match(/OS X 10[_.](\d+)/);}if(e.includes("Chrome/")){e.match(/Chrome\/(\d+)/);}else if(e.includes("Firefox/")){e.match(/Firefox\/(\d+)/);}}class Oe extends y{constructor(...t){super(...t),e(this,"ranges",new xe),0!==this.byteLength&&this.ranges.add(0,this.byteLength);}_tryExtend(e,t,i){if(0===e&&0===this.byteLength&&i){let e=new DataView(i.buffer||i,i.byteOffset,i.byteLength);this._swapDataView(e);}else {let i=e+t;if(i>this.byteLength){let{dataView:e}=this._extend(i);this._swapDataView(e);}}}_extend(e){let t;t=o?r.allocUnsafe(e):new Uint8Array(e);let i=new DataView(t.buffer,t.byteOffset,t.byteLength);return t.set(new Uint8Array(this.buffer,this.byteOffset,this.byteLength),0),{uintView:t,dataView:i}}subarray(e,t,i=!1){return t=t||this._lengthToEnd(e),i&&this._tryExtend(e,t),this.ranges.add(e,t),super.subarray(e,t)}set(e,t,i=!1){i&&this._tryExtend(t,e.byteLength,e);let s=super.set(e,t);return this.ranges.add(t,s.byteLength),s}async ensureChunk(e,t){this.chunked&&(this.ranges.available(e,t)||await this.readChunk(e,t));}available(e,t){return this.ranges.available(e,t)}}class xe{constructor(){e(this,"list",[]);}get length(){return this.list.length}add(e,t,i=0){let s=e+t,n=this.list.filter((t=>Ce(e,t.offset,s)||Ce(e,t.end,s)));if(n.length>0){e=Math.min(e,...n.map((e=>e.offset))),s=Math.max(s,...n.map((e=>e.end))),t=s-e;let i=n.shift();i.offset=e,i.length=t,i.end=s,this.list=this.list.filter((e=>!n.includes(e)));}else this.list.push({offset:e,length:t,end:s});}available(e,t){let i=e+t;return this.list.some((t=>t.offset<=e&&i<=t.end))}}function Ce(e,t,i){return e<=t&&t<=i}class Pe extends Oe{constructor(t,i){super(0),e(this,"chunksRead",0),this.input=t,this.options=i;}async readWhole(){this.chunked=!1,await this.readChunk(this.nextChunkOffset);}async readChunked(){this.chunked=!0,await this.readChunk(0,this.options.firstChunkSize);}async readNextChunk(e=this.nextChunkOffset){if(this.fullyRead)return this.chunksRead++,!1;let t=this.options.chunkSize,i=await this.readChunk(e,t);return !!i&&i.byteLength===t}async readChunk(e,t){if(this.chunksRead++,0!==(t=this.safeWrapAddress(e,t)))return this._readChunk(e,t)}safeWrapAddress(e,t){return void 0!==this.size&&e+t>this.size?Math.max(0,this.size-e):t}get nextChunkOffset(){if(0!==this.ranges.list.length)return this.ranges.list[0].length}get canReadNextChunk(){return this.chunksRead<this.options.chunkLimit}get fullyRead(){return void 0!==this.size&&this.nextChunkOffset===this.size}read(){return this.options.chunked?this.readChunked():this.readWhole()}close(){}}v.set("blob",class extends Pe{async readWhole(){this.chunked=!1;let e=await U(this.input);this._swapArrayBuffer(e);}readChunked(){return this.chunked=!0,this.size=this.input.size,super.readChunked()}async _readChunk(e,t){let i=t?e+t:void 0,s=this.input.slice(e,i),n=await U(s);return this.set(n,e,!0)}});v.set("url",class extends Pe{async readWhole(){this.chunked=!1;let e=await A(this.input);e instanceof ArrayBuffer?this._swapArrayBuffer(e):e instanceof Uint8Array&&this._swapBuffer(e);}async _readChunk(e,t){let i=t?e+t-1:void 0,s=this.options.httpHeaders||{};(e||i)&&(s.range=`bytes=${[e,i].join("-")}`);let n=await O(this.input,{headers:s}),r=await n.arrayBuffer(),a=r.byteLength;if(416!==n.status)return a!==t&&(this.size=e+a),this.set(r,e,!0)}});y.prototype.getUint64=function(e){let t=this.getUint32(e),i=this.getUint32(e+4);return t<1048575?t<<32|i:void 0!==typeof a?(console.warn("Using BigInt because of type 64uint but JS can only handle 53b numbers."),a(t)<<a(32)|a(i)):void u("Trying to read 64b value but JS can only handle 53b numbers.")};class Ue extends ee{parseBoxes(e=0){let t=[];for(;e<this.file.byteLength-4;){let i=this.parseBoxHead(e);if(t.push(i),0===i.length)break;e+=i.length;}return t}parseSubBoxes(e){e.boxes=this.parseBoxes(e.start);}findBox(e,t){return void 0===e.boxes&&this.parseSubBoxes(e),e.boxes.find((e=>e.kind===t))}parseBoxHead(e){let t=this.file.getUint32(e),i=this.file.getString(e+4,4),s=e+8;return 1===t&&(t=this.file.getUint64(e+8),s+=8),{offset:e,length:t,kind:i,start:s}}parseBoxFullHead(e){if(void 0!==e.version)return;let t=this.file.getUint32(e.start);e.version=t>>24,e.start+=4;}}class Ie extends Ue{static canHandle(e,t){if(0!==t)return !1;let i=e.getUint16(2);if(i>50)return !1;let s=16,n=[];for(;s<i;)n.push(e.getString(s,4)),s+=4;return n.includes(this.type)}async parse(){let e=this.file.getUint32(0),t=this.parseBoxHead(e);for(;"meta"!==t.kind;)e+=t.length,await this.file.ensureChunk(e,16),t=this.parseBoxHead(e);await this.file.ensureChunk(t.offset,t.length),this.parseBoxFullHead(t),this.parseSubBoxes(t),this.options.icc.enabled&&await this.findIcc(t),this.options.tiff.enabled&&await this.findExif(t);}async registerSegment(e,t,i){await this.file.ensureChunk(t,i);let s=this.file.subarray(t,i);this.createParser(e,s);}async findIcc(e){let t=this.findBox(e,"iprp");if(void 0===t)return;let i=this.findBox(t,"ipco");if(void 0===i)return;let s=this.findBox(i,"colr");void 0!==s&&await this.registerSegment("icc",s.offset+12,s.length);}async findExif(e){let t=this.findBox(e,"iinf");if(void 0===t)return;let i=this.findBox(e,"iloc");if(void 0===i)return;let s=this.findExifLocIdInIinf(t),n=this.findExtentInIloc(i,s);if(void 0===n)return;let[r,a]=n;await this.file.ensureChunk(r,a);let o=4+this.file.getUint32(r);r+=o,a-=o,await this.registerSegment("tiff",r,a);}findExifLocIdInIinf(e){this.parseBoxFullHead(e);let t,i,s,n,r=e.start,a=this.file.getUint16(r);for(r+=2;a--;){if(t=this.parseBoxHead(r),this.parseBoxFullHead(t),i=t.start,t.version>=2&&(s=3===t.version?4:2,n=this.file.getString(i+s+2,4),"Exif"===n))return this.file.getUintBytes(i,s);r+=t.length;}}get8bits(e){let t=this.file.getUint8(e);return [t>>4,15&t]}findExtentInIloc(e,t){this.parseBoxFullHead(e);let i=e.start,[s,n]=this.get8bits(i++),[r,a]=this.get8bits(i++),o=2===e.version?4:2,h=1===e.version||2===e.version?2:0,l=a+s+n,f=2===e.version?4:2,u=this.file.getUintBytes(i,f);for(i+=f;u--;){let e=this.file.getUintBytes(i,o);i+=o+h+2+r;let f=this.file.getUint16(i);if(i+=2,e===t)return f>1&&console.warn("ILOC box has more than one extent but we're only processing one\nPlease create an issue at https://github.com/MikeKovarik/exifr with this file"),[this.file.getUintBytes(i+a,s),this.file.getUintBytes(i+a+s,n)];i+=f*l;}}}class Be extends Ie{}e(Be,"type","heic");class Fe extends Ie{}e(Fe,"type","avif"),S.set("heic",Be),S.set("avif",Fe),B(L,["ifd0","ifd1"],[[256,"ImageWidth"],[257,"ImageHeight"],[258,"BitsPerSample"],[259,"Compression"],[262,"PhotometricInterpretation"],[270,"ImageDescription"],[271,"Make"],[272,"Model"],[273,"StripOffsets"],[274,"Orientation"],[277,"SamplesPerPixel"],[278,"RowsPerStrip"],[279,"StripByteCounts"],[282,"XResolution"],[283,"YResolution"],[284,"PlanarConfiguration"],[296,"ResolutionUnit"],[301,"TransferFunction"],[305,"Software"],[306,"ModifyDate"],[315,"Artist"],[316,"HostComputer"],[317,"Predictor"],[318,"WhitePoint"],[319,"PrimaryChromaticities"],[513,"ThumbnailOffset"],[514,"ThumbnailLength"],[529,"YCbCrCoefficients"],[530,"YCbCrSubSampling"],[531,"YCbCrPositioning"],[532,"ReferenceBlackWhite"],[700,"ApplicationNotes"],[33432,"Copyright"],[33723,"IPTC"],[34665,"ExifIFD"],[34675,"ICC"],[34853,"GpsIFD"],[330,"SubIFD"],[40965,"InteropIFD"],[40091,"XPTitle"],[40092,"XPComment"],[40093,"XPAuthor"],[40094,"XPKeywords"],[40095,"XPSubject"]]),B(L,"exif",[[33434,"ExposureTime"],[33437,"FNumber"],[34850,"ExposureProgram"],[34852,"SpectralSensitivity"],[34855,"ISO"],[34858,"TimeZoneOffset"],[34859,"SelfTimerMode"],[34864,"SensitivityType"],[34865,"StandardOutputSensitivity"],[34866,"RecommendedExposureIndex"],[34867,"ISOSpeed"],[34868,"ISOSpeedLatitudeyyy"],[34869,"ISOSpeedLatitudezzz"],[36864,"ExifVersion"],[36867,"DateTimeOriginal"],[36868,"CreateDate"],[36873,"GooglePlusUploadCode"],[36880,"OffsetTime"],[36881,"OffsetTimeOriginal"],[36882,"OffsetTimeDigitized"],[37121,"ComponentsConfiguration"],[37122,"CompressedBitsPerPixel"],[37377,"ShutterSpeedValue"],[37378,"ApertureValue"],[37379,"BrightnessValue"],[37380,"ExposureCompensation"],[37381,"MaxApertureValue"],[37382,"SubjectDistance"],[37383,"MeteringMode"],[37384,"LightSource"],[37385,"Flash"],[37386,"FocalLength"],[37393,"ImageNumber"],[37394,"SecurityClassification"],[37395,"ImageHistory"],[37396,"SubjectArea"],[37500,"MakerNote"],[37510,"UserComment"],[37520,"SubSecTime"],[37521,"SubSecTimeOriginal"],[37522,"SubSecTimeDigitized"],[37888,"AmbientTemperature"],[37889,"Humidity"],[37890,"Pressure"],[37891,"WaterDepth"],[37892,"Acceleration"],[37893,"CameraElevationAngle"],[40960,"FlashpixVersion"],[40961,"ColorSpace"],[40962,"ExifImageWidth"],[40963,"ExifImageHeight"],[40964,"RelatedSoundFile"],[41483,"FlashEnergy"],[41486,"FocalPlaneXResolution"],[41487,"FocalPlaneYResolution"],[41488,"FocalPlaneResolutionUnit"],[41492,"SubjectLocation"],[41493,"ExposureIndex"],[41495,"SensingMethod"],[41728,"FileSource"],[41729,"SceneType"],[41730,"CFAPattern"],[41985,"CustomRendered"],[41986,"ExposureMode"],[41987,"WhiteBalance"],[41988,"DigitalZoomRatio"],[41989,"FocalLengthIn35mmFormat"],[41990,"SceneCaptureType"],[41991,"GainControl"],[41992,"Contrast"],[41993,"Saturation"],[41994,"Sharpness"],[41996,"SubjectDistanceRange"],[42016,"ImageUniqueID"],[42032,"OwnerName"],[42033,"SerialNumber"],[42034,"LensInfo"],[42035,"LensMake"],[42036,"LensModel"],[42037,"LensSerialNumber"],[42080,"CompositeImage"],[42081,"CompositeImageCount"],[42082,"CompositeImageExposureTimes"],[42240,"Gamma"],[59932,"Padding"],[59933,"OffsetSchema"],[65e3,"OwnerName"],[65001,"SerialNumber"],[65002,"Lens"],[65100,"RawFile"],[65101,"Converter"],[65102,"WhiteBalance"],[65105,"Exposure"],[65106,"Shadows"],[65107,"Brightness"],[65108,"Contrast"],[65109,"Saturation"],[65110,"Sharpness"],[65111,"Smoothness"],[65112,"MoireFilter"],[40965,"InteropIFD"]]),B(L,"gps",[[0,"GPSVersionID"],[1,"GPSLatitudeRef"],[2,"GPSLatitude"],[3,"GPSLongitudeRef"],[4,"GPSLongitude"],[5,"GPSAltitudeRef"],[6,"GPSAltitude"],[7,"GPSTimeStamp"],[8,"GPSSatellites"],[9,"GPSStatus"],[10,"GPSMeasureMode"],[11,"GPSDOP"],[12,"GPSSpeedRef"],[13,"GPSSpeed"],[14,"GPSTrackRef"],[15,"GPSTrack"],[16,"GPSImgDirectionRef"],[17,"GPSImgDirection"],[18,"GPSMapDatum"],[19,"GPSDestLatitudeRef"],[20,"GPSDestLatitude"],[21,"GPSDestLongitudeRef"],[22,"GPSDestLongitude"],[23,"GPSDestBearingRef"],[24,"GPSDestBearing"],[25,"GPSDestDistanceRef"],[26,"GPSDestDistance"],[27,"GPSProcessingMethod"],[28,"GPSAreaInformation"],[29,"GPSDateStamp"],[30,"GPSDifferential"],[31,"GPSHPositioningError"]]),B(D,["ifd0","ifd1"],[[274,{1:"Horizontal (normal)",2:"Mirror horizontal",3:"Rotate 180",4:"Mirror vertical",5:"Mirror horizontal and rotate 270 CW",6:"Rotate 90 CW",7:"Mirror horizontal and rotate 90 CW",8:"Rotate 270 CW"}],[296,{1:"None",2:"inches",3:"cm"}]]);let Le=B(D,"exif",[[34850,{0:"Not defined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"}],[37121,{0:"-",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"}],[37383,{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"}],[37384,{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"}],[37385,{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"}],[41495,{1:"Not defined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"}],[41728,{1:"Film Scanner",2:"Reflection Print Scanner",3:"Digital Camera"}],[41729,{1:"Directly photographed"}],[41985,{0:"Normal",1:"Custom",2:"HDR (no original saved)",3:"HDR (original saved)",4:"Original (for HDR)",6:"Panorama",7:"Portrait HDR",8:"Portrait"}],[41986,{0:"Auto",1:"Manual",2:"Auto bracket"}],[41987,{0:"Auto",1:"Manual"}],[41990,{0:"Standard",1:"Landscape",2:"Portrait",3:"Night",4:"Other"}],[41991,{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"}],[41996,{0:"Unknown",1:"Macro",2:"Close",3:"Distant"}],[42080,{0:"Unknown",1:"Not a Composite Image",2:"General Composite Image",3:"Composite Image Captured While Shooting"}]]);const De={1:"No absolute unit of measurement",2:"Inch",3:"Centimeter"};Le.set(37392,De),Le.set(41488,De);const Te={0:"Normal",1:"Low",2:"High"};function ze(e){return "object"==typeof e&&void 0!==e.length?e[0]:e}function Ne(e){let t=Array.from(e).slice(1);return t[1]>15&&(t=t.map((e=>String.fromCharCode(e)))),"0"!==t[2]&&0!==t[2]||t.pop(),t.join(".")}function Ve(e){if("string"==typeof e){var[t,i,s,n,r,a]=e.trim().split(/[-: ]/g).map(Number),o=new Date(t,i-1,s);return Number.isNaN(n)||Number.isNaN(r)||Number.isNaN(a)||(o.setHours(n),o.setMinutes(r),o.setSeconds(a)),Number.isNaN(+o)?e:o}}function Me(e){if("string"==typeof e)return e;let t=[];if(0===e[1]&&0===e[e.length-1])for(let i=0;i<e.length;i+=2)t.push(Ee(e[i+1],e[i]));else for(let i=0;i<e.length;i+=2)t.push(Ee(e[i],e[i+1]));return d(String.fromCodePoint(...t))}function Ee(e,t){return e<<8|t}Le.set(41992,Te),Le.set(41993,Te),Le.set(41994,Te),B(T,["ifd0","ifd1"],[[50827,function(e){return "string"!=typeof e?m(e):e}],[306,Ve],[40091,Me],[40092,Me],[40093,Me],[40094,Me],[40095,Me]]),B(T,"exif",[[40960,Ne],[36864,Ne],[36867,Ve],[36868,Ve],[40962,ze],[40963,ze]]),B(T,"gps",[[0,e=>Array.from(e).join(".")],[7,e=>Array.from(e).join(":")]]);class Re extends te{static canHandle(e,t){return 225===e.getUint8(t+1)&&1752462448===e.getUint32(t+4)&&"http://ns.adobe.com/"===e.getString(t+4,"http://ns.adobe.com/".length)}static headerLength(e,t){return "http://ns.adobe.com/xmp/extension/"===e.getString(t+4,"http://ns.adobe.com/xmp/extension/".length)?79:4+"http://ns.adobe.com/xap/1.0/".length+1}static findPosition(e,t){let i=super.findPosition(e,t);return i.multiSegment=i.extended=79===i.headerLength,i.multiSegment?(i.chunkCount=e.getUint8(t+72),i.chunkNumber=e.getUint8(t+76),0!==e.getUint8(t+77)&&i.chunkNumber++):(i.chunkCount=1/0,i.chunkNumber=-1),i}static handleMultiSegments(e){return e.map((e=>e.chunk.getString())).join("")}normalizeInput(e){return "string"==typeof e?e:y.from(e).getString()}parse(e=this.chunk){if(!this.localOptions.parse)return e;e=function(e){let t={},i={};for(let e of Ye)t[e]=[],i[e]=0;return e.replace(qe,((e,s,n)=>{if("<"===s){let s=++i[n];return t[n].push(s),`${e}#${s}`}return `${e}#${t[n].pop()}`}))}(e);let t=Ge.findAll(e,"rdf","Description");0===t.length&&t.push(new Ge("rdf","Description",void 0,e));let i,s={};for(let e of t)for(let t of e.properties)i=$e(t.ns,s),He(t,i);return function(e){let t;for(let i in e)t=e[i]=h(e[i]),void 0===t&&delete e[i];return h(e)}(s)}assignToOutput(e,t){if(this.localOptions.parse)for(let[i,s]of Object.entries(t))switch(i){case"tiff":this.assignObjectToOutput(e,"ifd0",s);break;case"exif":this.assignObjectToOutput(e,"exif",s);break;case"xmlns":break;default:this.assignObjectToOutput(e,i,s);}else e.xmp=t;}}e(Re,"type","xmp"),e(Re,"multiSegment",!0),k.set("xmp",Re);class je{static findAll(e){return Ke(e,/([a-zA-Z0-9-]+):([a-zA-Z0-9-]+)=("[^"]*"|'[^']*')/gm).map(je.unpackMatch)}static unpackMatch(e){let t=e[1],i=e[2],s=e[3].slice(1,-1);return s=Xe(s),new je(t,i,s)}constructor(e,t,i){this.ns=e,this.name=t,this.value=i;}serialize(){return this.value}}class Ge{static findAll(e,t,i){if(void 0!==t||void 0!==i){t=t||"[\\w\\d-]+",i=i||"[\\w\\d-]+";var s=new RegExp(`<(${t}):(${i})(#\\d+)?((\\s+?[\\w\\d-:]+=("[^"]*"|'[^']*'))*\\s*)(\\/>|>([\\s\\S]*?)<\\/\\1:\\2\\3>)`,"gm");}else s=/<([\w\d-]+):([\w\d-]+)(#\d+)?((\s+?[\w\d-:]+=("[^"]*"|'[^']*'))*\s*)(\/>|>([\s\S]*?)<\/\1:\2\3>)/gm;return Ke(e,s).map(Ge.unpackMatch)}static unpackMatch(e){let t=e[1],i=e[2],s=e[4],n=e[8];return new Ge(t,i,s,n)}constructor(e,t,i,s){this.ns=e,this.name=t,this.attrString=i,this.innerXml=s,this.attrs=je.findAll(i),this.children=Ge.findAll(s),this.value=0===this.children.length?Xe(s):void 0,this.properties=[...this.attrs,...this.children];}get isPrimitive(){return void 0!==this.value&&0===this.attrs.length&&0===this.children.length}get isListContainer(){return 1===this.children.length&&this.children[0].isList}get isList(){let{ns:e,name:t}=this;return "rdf"===e&&("Seq"===t||"Bag"===t||"Alt"===t)}get isListItem(){return "rdf"===this.ns&&"li"===this.name}serialize(){if(0===this.properties.length&&void 0===this.value)return;if(this.isPrimitive)return this.value;if(this.isListContainer)return this.children[0].serialize();if(this.isList)return We(this.children.map(_e));if(this.isListItem&&1===this.children.length&&0===this.attrs.length)return this.children[0].serialize();let e={};for(let t of this.properties)He(t,e);return void 0!==this.value&&(e.value=this.value),h(e)}}function He(e,t){let i=e.serialize();void 0!==i&&(t[e.name]=i);}var _e=e=>e.serialize(),We=e=>1===e.length?e[0]:e,$e=(e,t)=>t[e]?t[e]:t[e]={};function Ke(e,t){let i,s=[];if(!e)return s;for(;null!==(i=t.exec(e));)s.push(i);return s}function Xe(e){if(function(e){return null==e||"null"===e||"undefined"===e||""===e||""===e.trim()}(e))return;let t=Number(e);if(!Number.isNaN(t))return t;let i=e.toLowerCase();return "true"===i||"false"!==i&&e.trim()}const Ye=["rdf:li","rdf:Seq","rdf:Bag","rdf:Alt","rdf:Description"],qe=new RegExp(`(<|\\/)(${Ye.join("|")})`,"g");

const defaultOptions = {
  maxRequests: 6
};
class RequestScheduler {
  constructor(options) {
    this.options = {
      ...defaultOptions,
      ...options
    };
    this.requestQueue = [];
    this.executing = /* @__PURE__ */ new Set();
  }
  remove(p) {
    this.executing.delete(p);
    if (!p.cancelled) {
      p.completed = true;
      this.enqueue();
    }
  }
  enqueue() {
    for (let numImageRequests = this.executing.size; numImageRequests < this.options.maxRequests && this.requestQueue.length > 0; numImageRequests++) {
      const q = this.requestQueue.shift();
      if (q.cancelled) {
        this.remove(q);
        continue;
      }
      const p = Promise.resolve().then(() => {
        const request = q.ref();
        q.request = request;
        return request;
      });
      this.executing.add(q);
      p.then(() => {
        this.remove(q);
      }).catch(() => {
        this.remove(q);
      });
    }
  }
  scheduleRequest(fn) {
    const request = {
      ref: fn,
      cancelled: false,
      completed: false,
      request: null,
      cancel: () => {
        if (!request.completed && !request.cancelled) {
          request.cancelled = true;
          if (request.request) {
            request.request.cancel();
          }
          this.enqueue();
        }
      }
    };
    this.requestQueue.push(request);
    this.enqueue();
    return request;
  }
}

var _bin = {
  nextZero: function(data, p) {
    while (data[p] != 0)
      p++;
    return p;
  },
  readUshort: function(buff, p) {
    return buff[p] << 8 | buff[p + 1];
  },
  writeUshort: function(buff, p, n) {
    buff[p] = n >> 8 & 255;
    buff[p + 1] = n & 255;
  },
  readUint: function(buff, p) {
    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
  },
  writeUint: function(buff, p, n) {
    buff[p] = n >> 24 & 255;
    buff[p + 1] = n >> 16 & 255;
    buff[p + 2] = n >> 8 & 255;
    buff[p + 3] = n & 255;
  },
  readASCII: function(buff, p, l) {
    var s = "";
    for (var i = 0; i < l; i++)
      s += String.fromCharCode(buff[p + i]);
    return s;
  },
  writeASCII: function(data, p, s) {
    for (var i = 0; i < s.length; i++)
      data[p + i] = s.charCodeAt(i);
  },
  readBytes: function(buff, p, l) {
    var arr = [];
    for (var i = 0; i < l; i++)
      arr.push(buff[p + i]);
    return arr;
  },
  pad: function(n) {
    return n.length < 2 ? "0" + n : n;
  },
  readUTF8: function(buff, p, l) {
    var s = "", ns;
    for (var i = 0; i < l; i++)
      s += "%" + _bin.pad(buff[p + i].toString(16));
    try {
      ns = decodeURIComponent(s);
    } catch (e) {
      return _bin.readASCII(buff, p, l);
    }
    return ns;
  }
};
function toRGBA8(out) {
  var w = out.width, h = out.height;
  if (out.tabs.acTL == null)
    return [decodeImage(out.data, w, h, out).buffer];
  var frms = [];
  if (out.frames[0].data == null)
    out.frames[0].data = out.data;
  var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
  for (var i = 0; i < out.frames.length; i++) {
    var frm = out.frames[i];
    var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
    var fdata = decodeImage(frm.data, fw, fh, out);
    if (i != 0)
      for (var j = 0; j < len; j++)
        prev[j] = img[j];
    if (frm.blend == 0)
      _copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.blend == 1)
      _copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
    frms.push(img.buffer.slice(0));
    if (frm.dispose == 0) ; else if (frm.dispose == 1)
      _copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.dispose == 2)
      for (var j = 0; j < len; j++)
        img[j] = prev[j];
  }
  return frms;
}
function decodeImage(data, w, h, out) {
  var area = w * h, bpp = _getBPP(out);
  var bpl = Math.ceil(w * bpp / 8);
  var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
  var ctype = out.ctype, depth = out.depth;
  var rs = _bin.readUshort;
  if (ctype == 6) {
    var qarea = area << 2;
    if (depth == 8)
      for (var i = 0; i < qarea; i += 4) {
        bf[i] = data[i];
        bf[i + 1] = data[i + 1];
        bf[i + 2] = data[i + 2];
        bf[i + 3] = data[i + 3];
      }
    if (depth == 16)
      for (var i = 0; i < qarea; i++) {
        bf[i] = data[i << 1];
      }
  } else if (ctype == 2) {
    var ts = out.tabs["tRNS"];
    if (ts == null) {
      if (depth == 8)
        for (var i = 0; i < area; i++) {
          var ti = i * 3;
          bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
        }
      if (depth == 16)
        for (var i = 0; i < area; i++) {
          var ti = i * 6;
          bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
        }
    } else {
      var tr = ts[0], tg = ts[1], tb = ts[2];
      if (depth == 8)
        for (var i = 0; i < area; i++) {
          var qi = i << 2, ti = i * 3;
          bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
            bf[qi + 3] = 0;
        }
      if (depth == 16)
        for (var i = 0; i < area; i++) {
          var qi = i << 2, ti = i * 6;
          bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
            bf[qi + 3] = 0;
        }
    }
  } else if (ctype == 3) {
    var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
    if (depth == 1)
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i = 0; i < w; i++) {
          var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j < tl ? ap[j] : 255;
        }
      }
    if (depth == 2)
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i = 0; i < w; i++) {
          var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j < tl ? ap[j] : 255;
        }
      }
    if (depth == 4)
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i = 0; i < w; i++) {
          var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j < tl ? ap[j] : 255;
        }
      }
    if (depth == 8)
      for (var i = 0; i < area; i++) {
        var qi = i << 2, j = data[i], cj = 3 * j;
        bf[qi] = p[cj];
        bf[qi + 1] = p[cj + 1];
        bf[qi + 2] = p[cj + 2];
        bf[qi + 3] = j < tl ? ap[j] : 255;
      }
  } else if (ctype == 4) {
    if (depth == 8)
      for (var i = 0; i < area; i++) {
        var qi = i << 2, di = i << 1, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 1];
      }
    if (depth == 16)
      for (var i = 0; i < area; i++) {
        var qi = i << 2, di = i << 2, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 2];
      }
  } else if (ctype == 0) {
    var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
    for (var y = 0; y < h; y++) {
      var off = y * bpl, to = y * w;
      if (depth == 1)
        for (var x = 0; x < w; x++) {
          var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 2)
        for (var x = 0; x < w; x++) {
          var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 4)
        for (var x = 0; x < w; x++) {
          var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 8)
        for (var x = 0; x < w; x++) {
          var gr = data[off + x], al = gr == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      else if (depth == 16)
        for (var x = 0; x < w; x++) {
          var gr = data[off + (x << 1)], al = rs(data, off + (x << 1)) == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
    }
  }
  return bf;
}
function decode(buff) {
  var data = new Uint8Array(buff), offset = 8, bin = _bin, rUs = bin.readUshort, rUi = bin.readUint;
  var out = { tabs: {}, frames: [] };
  var dd = new Uint8Array(data.length), doff = 0;
  var fd, foff = 0;
  var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i = 0; i < 8; i++)
    if (data[i] != mgck[i])
      throw "The input is not a PNG file!";
  while (offset < data.length) {
    var len = bin.readUint(data, offset);
    offset += 4;
    var type = bin.readASCII(data, offset, 4);
    offset += 4;
    if (type == "IHDR") {
      _IHDR(data, offset, out);
    } else if (type == "iCCP") {
      var off = offset;
      while (data[off] != 0)
        off++;
      bin.readASCII(data, offset, off - offset);
      data[off + 1];
      var fil = data.slice(off + 2, offset + len);
      var res = null;
      try {
        res = _inflate(fil);
      } catch (e) {
        res = inflateRaw(fil);
      }
      out.tabs[type] = res;
    } else if (type == "CgBI") {
      out.tabs[type] = data.slice(offset, offset + 4);
    } else if (type == "IDAT") {
      for (var i = 0; i < len; i++)
        dd[doff + i] = data[offset + i];
      doff += len;
    } else if (type == "acTL") {
      out.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) };
      fd = new Uint8Array(data.length);
    } else if (type == "fcTL") {
      if (foff != 0) {
        var fr = out.frames[out.frames.length - 1];
        fr.data = _decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      var rct = { x: rUi(data, offset + 12), y: rUi(data, offset + 16), width: rUi(data, offset + 4), height: rUi(data, offset + 8) };
      var del = rUs(data, offset + 22);
      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
      var frm = { rect: rct, delay: Math.round(del * 1e3), dispose: data[offset + 24], blend: data[offset + 25] };
      out.frames.push(frm);
    } else if (type == "fdAT") {
      for (var i = 0; i < len - 4; i++)
        fd[foff + i] = data[offset + i + 4];
      foff += len - 4;
    } else if (type == "pHYs") {
      out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
    } else if (type == "cHRM") {
      out.tabs[type] = [];
      for (var i = 0; i < 8; i++)
        out.tabs[type].push(bin.readUint(data, offset + i * 4));
    } else if (type == "tEXt" || type == "zTXt") {
      if (out.tabs[type] == null)
        out.tabs[type] = {};
      var nz = bin.nextZero(data, offset);
      var keyw = bin.readASCII(data, offset, nz - offset);
      var text, tl = offset + len - nz - 1;
      if (type == "tEXt")
        text = bin.readASCII(data, nz + 1, tl);
      else {
        var bfr = _inflate(data.slice(nz + 2, nz + 2 + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type][keyw] = text;
    } else if (type == "iTXt") {
      if (out.tabs[type] == null)
        out.tabs[type] = {};
      var nz = 0, off = offset;
      nz = bin.nextZero(data, off);
      var keyw = bin.readASCII(data, off, nz - off);
      off = nz + 1;
      var cflag = data[off]; data[off + 1];
      off += 2;
      nz = bin.nextZero(data, off);
      bin.readASCII(data, off, nz - off);
      off = nz + 1;
      nz = bin.nextZero(data, off);
      bin.readUTF8(data, off, nz - off);
      off = nz + 1;
      var text, tl = len - (off - offset);
      if (cflag == 0)
        text = bin.readUTF8(data, off, tl);
      else {
        var bfr = _inflate(data.slice(off, off + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type][keyw] = text;
    } else if (type == "PLTE") {
      out.tabs[type] = bin.readBytes(data, offset, len);
    } else if (type == "hIST") {
      var pl = out.tabs["PLTE"].length / 3;
      out.tabs[type] = [];
      for (var i = 0; i < pl; i++)
        out.tabs[type].push(rUs(data, offset + i * 2));
    } else if (type == "tRNS") {
      if (out.ctype == 3)
        out.tabs[type] = bin.readBytes(data, offset, len);
      else if (out.ctype == 0)
        out.tabs[type] = rUs(data, offset);
      else if (out.ctype == 2)
        out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
    } else if (type == "gAMA")
      out.tabs[type] = bin.readUint(data, offset) / 1e5;
    else if (type == "sRGB")
      out.tabs[type] = data[offset];
    else if (type == "bKGD") {
      if (out.ctype == 0 || out.ctype == 4)
        out.tabs[type] = [rUs(data, offset)];
      else if (out.ctype == 2 || out.ctype == 6)
        out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
      else if (out.ctype == 3)
        out.tabs[type] = data[offset];
    } else if (type == "IEND") {
      break;
    }
    offset += len;
    bin.readUint(data, offset);
    offset += 4;
  }
  if (foff != 0) {
    var fr = out.frames[out.frames.length - 1];
    fr.data = _decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
  }
  out.data = _decompress(out, dd, out.width, out.height);
  delete out.compress;
  delete out.interlace;
  delete out.filter;
  return out;
}
function _decompress(out, dd, w, h) {
  var bpp = _getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
  if (out.tabs["CgBI"])
    dd = inflateRaw(dd, buff);
  else
    dd = _inflate(dd, buff);
  if (out.interlace == 0)
    dd = _filterZero(dd, out, 0, w, h);
  else if (out.interlace == 1)
    dd = _readInterlace(dd, out);
  return dd;
}
function _inflate(data, buff) {
  var out = inflateRaw(new Uint8Array(data.buffer, 2, data.length - 6), buff);
  return out;
}
var inflateRaw = function() {
  var H = {};
  H.H = {};
  H.H.N = function(N, W) {
    var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;
    if (N[0] == 3 && N[1] == 0)
      return W ? W : new R(0);
    var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;
    if (Z)
      W = new R(N.length >>> 2 << 5);
    while (i == 0) {
      i = n(N, d, 1);
      m = n(N, d + 1, 2);
      d += 3;
      if (m == 0) {
        if ((d & 7) != 0)
          d += 8 - (d & 7);
        var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
        if (Z)
          W = H.H.W(W, w + q);
        W.set(new R(N.buffer, N.byteOffset + D, q), w);
        d = D + q << 3;
        w += q;
        continue;
      }
      if (Z)
        W = H.H.W(W, w + (1 << 17));
      if (m == 1) {
        v = b.J;
        C = b.h;
        X = (1 << 9) - 1;
        u = (1 << 5) - 1;
      }
      if (m == 2) {
        J = A(N, d, 5) + 257;
        h = A(N, d + 5, 5) + 1;
        Q = A(N, d + 10, 4) + 4;
        d += 14;
        var j = 1;
        for (var c = 0; c < 38; c += 2) {
          b.Q[c] = 0;
          b.Q[c + 1] = 0;
        }
        for (var c = 0; c < Q; c++) {
          var K = A(N, d + c * 3, 3);
          b.Q[(b.X[c] << 1) + 1] = K;
          if (K > j)
            j = K;
        }
        d += 3 * Q;
        M(b.Q, j);
        I(b.Q, j, b.u);
        v = b.w;
        C = b.d;
        d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);
        var r = V.V(b.v, 0, J, b.C);
        X = (1 << r) - 1;
        var S = V.V(b.v, J, h, b.D);
        u = (1 << S) - 1;
        M(b.C, r);
        I(b.C, r, v);
        M(b.D, S);
        I(b.D, S, C);
      }
      while (true) {
        var T = v[e(N, d) & X];
        d += T & 15;
        var p = T >>> 4;
        if (p >>> 8 == 0) {
          W[w++] = p;
        } else if (p == 256) {
          break;
        } else {
          var z = w + p - 254;
          if (p > 264) {
            var _ = b.q[p - 257];
            z = w + (_ >>> 3) + A(N, d, _ & 7);
            d += _ & 7;
          }
          var $ = C[e(N, d) & u];
          d += $ & 15;
          var s = $ >>> 4, Y = b.c[s], a = (Y >>> 4) + n(N, d, Y & 15);
          d += Y & 15;
          while (w < z) {
            W[w] = W[w++ - a];
            W[w] = W[w++ - a];
            W[w] = W[w++ - a];
            W[w] = W[w++ - a];
          }
          w = z;
        }
      }
    }
    return W.length == w ? W : W.slice(0, w);
  };
  H.H.W = function(N, W) {
    var R = N.length;
    if (W <= R)
      return N;
    var V = new Uint8Array(R << 1);
    V.set(N, 0);
    return V;
  };
  H.H.R = function(N, W, R, V, n, A) {
    var l = H.H.e, M = H.H.Z, I = 0;
    while (I < R) {
      var e = N[M(V, n) & W];
      n += e & 15;
      var b = e >>> 4;
      if (b <= 15) {
        A[I] = b;
        I++;
      } else {
        var Z = 0, m = 0;
        if (b == 16) {
          m = 3 + l(V, n, 2);
          n += 2;
          Z = A[I - 1];
        } else if (b == 17) {
          m = 3 + l(V, n, 3);
          n += 3;
        } else if (b == 18) {
          m = 11 + l(V, n, 7);
          n += 7;
        }
        var J = I + m;
        while (I < J) {
          A[I] = Z;
          I++;
        }
      }
    }
    return n;
  };
  H.H.V = function(N, W, R, V) {
    var n = 0, A = 0, l = V.length >>> 1;
    while (A < R) {
      var M = N[A + W];
      V[A << 1] = 0;
      V[(A << 1) + 1] = M;
      if (M > n)
        n = M;
      A++;
    }
    while (A < l) {
      V[A << 1] = 0;
      V[(A << 1) + 1] = 0;
      A++;
    }
    return n;
  };
  H.H.n = function(N, W) {
    var R = H.H.m, V = N.length, n, A, l, M, I, e = R.j;
    for (var M = 0; M <= W; M++)
      e[M] = 0;
    for (M = 1; M < V; M += 2)
      e[N[M]]++;
    var b = R.K;
    n = 0;
    e[0] = 0;
    for (A = 1; A <= W; A++) {
      n = n + e[A - 1] << 1;
      b[A] = n;
    }
    for (l = 0; l < V; l += 2) {
      I = N[l + 1];
      if (I != 0) {
        N[l] = b[I];
        b[I]++;
      }
    }
  };
  H.H.A = function(N, W, R) {
    var V = N.length, n = H.H.m, A = n.r;
    for (var l = 0; l < V; l += 2)
      if (N[l + 1] != 0) {
        var M = l >> 1, I = N[l + 1], e = M << 4 | I, b = W - I, Z = N[l] << b, m = Z + (1 << b);
        while (Z != m) {
          var J = A[Z] >>> 15 - W;
          R[J] = e;
          Z++;
        }
      }
  };
  H.H.l = function(N, W) {
    var R = H.H.m.r, V = 15 - W;
    for (var n = 0; n < N.length; n += 2) {
      var A = N[n] << W - N[n + 1];
      N[n] = R[A] >>> V;
    }
  };
  H.H.M = function(N, W, R) {
    R = R << (W & 7);
    var V = W >>> 3;
    N[V] |= R;
    N[V + 1] |= R >>> 8;
  };
  H.H.I = function(N, W, R) {
    R = R << (W & 7);
    var V = W >>> 3;
    N[V] |= R;
    N[V + 1] |= R >>> 8;
    N[V + 2] |= R >>> 16;
  };
  H.H.e = function(N, W, R) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;
  };
  H.H.b = function(N, W, R) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;
  };
  H.H.Z = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
  };
  H.H.i = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
  };
  H.H.m = function() {
    var N = Uint16Array, W = Uint32Array;
    return { K: new N(16), j: new N(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new N(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new W(32), J: new N(512), _: [], h: new N(32), $: [], w: new N(32768), C: [], v: [], d: new N(32768), D: [], u: new N(512), Q: [], r: new N(1 << 15), s: new W(286), Y: new W(30), a: new W(19), t: new W(15e3), k: new N(1 << 16), g: new N(1 << 15) };
  }();
  (function() {
    var N = H.H.m, W = 1 << 15;
    for (var R = 0; R < W; R++) {
      var V = R;
      V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
      V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
      V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
      N.r[R] = (V >>> 16 | V << 16) >>> 17;
    }
    function n(A, l, M) {
      while (l-- != 0)
        A.push(0, M);
    }
    for (var R = 0; R < 32; R++) {
      N.q[R] = N.S[R] << 3 | N.T[R];
      N.c[R] = N.p[R] << 4 | N.z[R];
    }
    n(N._, 144, 8);
    n(N._, 255 - 143, 9);
    n(N._, 279 - 255, 7);
    n(N._, 287 - 279, 8);
    H.H.n(N._, 9);
    H.H.A(N._, 9, N.J);
    H.H.l(N._, 9);
    n(N.$, 32, 5);
    H.H.n(N.$, 5);
    H.H.A(N.$, 5, N.h);
    H.H.l(N.$, 5);
    n(N.Q, 19, 0);
    n(N.C, 286, 0);
    n(N.D, 30, 0);
    n(N.v, 320, 0);
  })();
  return H.H.N;
}();
function _readInterlace(data, out) {
  var w = out.width, h = out.height;
  var bpp = _getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
  var img = new Uint8Array(h * bpl);
  var di = 0;
  var starting_row = [0, 0, 4, 0, 2, 0, 1];
  var starting_col = [0, 4, 0, 2, 0, 1, 0];
  var row_increment = [8, 8, 8, 4, 4, 2, 2];
  var col_increment = [8, 8, 4, 4, 2, 2, 1];
  var pass = 0;
  while (pass < 7) {
    var ri = row_increment[pass], ci = col_increment[pass];
    var sw = 0, sh = 0;
    var cr = starting_row[pass];
    while (cr < h) {
      cr += ri;
      sh++;
    }
    var cc = starting_col[pass];
    while (cc < w) {
      cc += ci;
      sw++;
    }
    var bpll = Math.ceil(sw * bpp / 8);
    _filterZero(data, out, di, sw, sh);
    var y = 0, row = starting_row[pass];
    while (row < h) {
      var col = starting_col[pass];
      var cdi = di + y * bpll << 3;
      while (col < w) {
        if (bpp == 1) {
          var val = data[cdi >> 3];
          val = val >> 7 - (cdi & 7) & 1;
          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
        }
        if (bpp == 2) {
          var val = data[cdi >> 3];
          val = val >> 6 - (cdi & 7) & 3;
          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
        }
        if (bpp == 4) {
          var val = data[cdi >> 3];
          val = val >> 4 - (cdi & 7) & 15;
          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
        }
        if (bpp >= 8) {
          var ii = row * bpl + col * cbpp;
          for (var j = 0; j < cbpp; j++)
            img[ii + j] = data[(cdi >> 3) + j];
        }
        cdi += bpp;
        col += ci;
      }
      y++;
      row += ri;
    }
    if (sw * sh != 0)
      di += sh * (1 + bpll);
    pass = pass + 1;
  }
  return img;
}
function _getBPP(out) {
  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
  return noc * out.depth;
}
function _filterZero(data, out, off, w, h) {
  var bpp = _getBPP(out), bpl = Math.ceil(w * bpp / 8);
  bpp = Math.ceil(bpp / 8);
  var i, di, type = data[off], x = 0;
  if (type > 1)
    data[off] = [0, 0, 1][type - 2];
  if (type == 3)
    for (x = bpp; x < bpl; x++)
      data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
  for (var y = 0; y < h; y++) {
    i = off + y * bpl;
    di = i + y + 1;
    type = data[di - 1];
    x = 0;
    if (type == 0)
      for (; x < bpl; x++)
        data[i + x] = data[di + x];
    else if (type == 1) {
      for (; x < bpp; x++)
        data[i + x] = data[di + x];
      for (; x < bpl; x++)
        data[i + x] = data[di + x] + data[i + x - bpp];
    } else if (type == 2) {
      for (; x < bpl; x++)
        data[i + x] = data[di + x] + data[i + x - bpl];
    } else if (type == 3) {
      for (; x < bpp; x++)
        data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);
      for (; x < bpl; x++)
        data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);
    } else {
      for (; x < bpp; x++)
        data[i + x] = data[di + x] + _paeth(0, data[i + x - bpl], 0);
      for (; x < bpl; x++)
        data[i + x] = data[di + x] + _paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);
    }
  }
  return data;
}
function _paeth(a, b, c) {
  var p = a + b - c, pa = p - a, pb = p - b, pc = p - c;
  if (pa * pa <= pb * pb && pa * pa <= pc * pc)
    return a;
  else if (pb * pb <= pc * pc)
    return b;
  return c;
}
function _IHDR(data, offset, out) {
  out.width = _bin.readUint(data, offset);
  offset += 4;
  out.height = _bin.readUint(data, offset);
  offset += 4;
  out.depth = data[offset];
  offset++;
  out.ctype = data[offset];
  offset++;
  out.compress = data[offset];
  offset++;
  out.filter = data[offset];
  offset++;
  out.interlace = data[offset];
  offset++;
}
function _copyTile(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
  var w = Math.min(sw, tw), h = Math.min(sh, th);
  var si = 0, ti = 0;
  for (var y = 0; y < h; y++)
    for (var x = 0; x < w; x++) {
      if (xoff >= 0 && yoff >= 0) {
        si = y * sw + x << 2;
        ti = (yoff + y) * tw + xoff + x << 2;
      } else {
        si = (-yoff + y) * sw - xoff + x << 2;
        ti = y * tw + x << 2;
      }
      if (mode == 0) {
        tb[ti] = sb[si];
        tb[ti + 1] = sb[si + 1];
        tb[ti + 2] = sb[si + 2];
        tb[ti + 3] = sb[si + 3];
      } else if (mode == 1) {
        var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
        var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
        var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
        tb[ti + 3] = 255 * oa;
        tb[ti + 0] = (fr + br * ifa) * ioa;
        tb[ti + 1] = (fg + bg * ifa) * ioa;
        tb[ti + 2] = (fb + bb * ifa) * ioa;
      } else if (mode == 2) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb) {
          tb[ti] = 0;
          tb[ti + 1] = 0;
          tb[ti + 2] = 0;
          tb[ti + 3] = 0;
        } else {
          tb[ti] = fr;
          tb[ti + 1] = fg;
          tb[ti + 2] = fb;
          tb[ti + 3] = fa;
        }
      } else if (mode == 3) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb)
          continue;
        if (fa < 220 && ba > 20)
          return false;
      }
    }
  return true;
}

class AJAXError extends Error {
  constructor(status, statusText, url, body) {
    super(`AJAXError: ${statusText} (${status}): ${url}`);
    this.status = status;
    this.statusText = statusText;
    this.url = url;
    this.body = body;
  }
}
const isFileURL = (url) => /^file:/.test(url) || /^file:/.test(getReferrer()) && !/^\w+:/.test(url);
function makeFetchRequest(requestParameters, callback) {
  const controller = new AbortController();
  const request2 = new Request(requestParameters.url, {
    method: requestParameters.method || "GET",
    body: requestParameters.body,
    credentials: requestParameters.credentials,
    headers: requestParameters.headers,
    referrer: getReferrer(),
    signal: controller.signal
  });
  let complete = false;
  let aborted = false;
  if (requestParameters.type === "json") {
    request2.headers.set("Accept", "application/json");
  }
  const validateOrFetch = (err, cachedResponse, responseIsFresh) => {
    if (aborted)
      return;
    if (err) {
      if (err.message !== "SecurityError") {
        warnOnce(err);
      }
    }
    if (cachedResponse && responseIsFresh) {
      return finishRequest(cachedResponse);
    }
    fetch(request2).then((response) => {
      if (response.ok) {
        return finishRequest(response);
      } else {
        return response.blob().then((body) => callback(new AJAXError(response.status, response.statusText, requestParameters.url, body)));
      }
    }).catch((error) => {
      if (error.code === 20) ;
      callback(new Error(error.message));
    });
  };
  const finishRequest = (response) => {
    (requestParameters.type === "arrayBuffer" ? response.arrayBuffer() : requestParameters.type === "json" ? response.json() : response.text()).then((result) => {
      if (aborted)
        return;
      complete = true;
      callback(null, result, response.headers.get("Cache-Control"), response.headers.get("Expires"));
    }).catch((err) => {
      if (!aborted)
        callback(new Error(err.message));
    });
  };
  validateOrFetch(null, null);
  return {
    cancel: () => {
      aborted = true;
      if (!complete)
        controller.abort();
    }
  };
}
function makeXMLHttpRequest(requestParameters, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open(requestParameters.method || "GET", requestParameters.url, true);
  if (requestParameters.type === "arrayBuffer") {
    xhr.responseType = "arraybuffer";
  }
  for (const k in requestParameters.headers) {
    xhr.setRequestHeader(k, requestParameters.headers[k]);
  }
  if (requestParameters.type === "json") {
    xhr.responseType = "text";
    xhr.setRequestHeader("Accept", "application/json");
  }
  xhr.withCredentials = requestParameters.credentials === "include";
  xhr.onerror = () => {
    callback(new Error(xhr.statusText));
  };
  xhr.onload = () => {
    if ((xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) && xhr.response !== null) {
      let data = xhr.response;
      if (requestParameters.type === "json") {
        try {
          data = JSON.parse(xhr.response);
        } catch (err) {
          return callback(err);
        }
      }
      callback(null, data, xhr.getResponseHeader("Cache-Control"), xhr.getResponseHeader("Expires"));
    } else {
      const body = new Blob([xhr.response], { type: xhr.getResponseHeader("Content-Type") });
      callback(new AJAXError(xhr.status, xhr.statusText, requestParameters.url, body));
    }
  };
  xhr.send(requestParameters.body);
  return { cancel: () => xhr.abort() };
}
const makeRequest = function(requestParameters, callback) {
  if (/:\/\//.test(requestParameters.url) && !/^https?:|^file:/.test(requestParameters.url)) {
    if (isWorker() && self.worker && self.worker.actor) {
      return self.worker.actor.send("getResource", requestParameters, callback);
    }
    if (!isWorker()) {
      return makeFetchRequest(requestParameters, callback);
    }
  }
  if (!isFileURL(requestParameters.url)) {
    if (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")
    ) {
      return makeFetchRequest(requestParameters, callback);
    }
    if (isWorker() && self.worker && self.worker.actor) {
      const queueOnMainThread = true;
      return self.worker.actor.send("getResource", requestParameters, callback, void 0, queueOnMainThread);
    }
  }
  return makeXMLHttpRequest(requestParameters, callback);
};
let pool;
function getPool() {
  if (!pool) {
    pool = new self.GeoTIFF.Pool();
  }
  return pool;
}
class RequestAdapter {
  constructor(options) {
    this.requestScheduler = new RequestScheduler(options);
  }
  getResource(mapId, params, callback) {
    return makeRequest(params, callback);
  }
  /**
   * arrayBuffer  Unit8
   * @param data
   * @param callback
   */
  arrayBuffer2unit8(data, callback) {
    const pngImage = decode(data);
    const pixels = toRGBA8(pngImage);
    callback(null, {
      data: new Uint8Array(pixels[0]),
      width: pngImage.width,
      height: pngImage.height
    });
  }
  /**
   * arrayBuffer 
   * 1.  ImageBitmap  `ImageBitmap` 
   * 2.  safari  rgba2float 
   * @param data
   * @param callback
   */
  arrayBuffer2Image(data, callback) {
    const imageBitmapSupported = typeof createImageBitmap === "function";
    if (imageBitmapSupported) {
      arrayBufferToImageBitmap(data, callback);
    } else {
      this.arrayBuffer2unit8(data, callback);
    }
  }
  /**
   * geotiff 
   * @param data
   * @param callback
   */
  arrayBuffer2tiff(data, callback) {
    if (!self.GeoTIFF) {
      throw new Error("Must config [geotiff](https://github.com/geotiffjs/geotiff.js) dep use `configDeps`");
    }
    self.GeoTIFF.fromArrayBuffer(data).then((geotiff) => {
      geotiff.getImage().then((image) => {
        const result = {};
        const fileDirectory = image.fileDirectory;
        const { GeographicTypeGeoKey, ProjectedCSTypeGeoKey } = image.getGeoKeys();
        result.projection = ProjectedCSTypeGeoKey || GeographicTypeGeoKey;
        const height = image.getHeight();
        result.height = height;
        const width = image.getWidth();
        result.width = width;
        const [resolutionX, resolutionY] = image.getResolution();
        result.pixelHeight = Math.abs(resolutionY);
        result.pixelWidth = Math.abs(resolutionX);
        const [originX, originY] = image.getOrigin();
        result.xmin = originX;
        result.xmax = result.xmin + width * result.pixelWidth;
        result.ymax = originY;
        result.ymin = result.ymax - height * result.pixelHeight;
        result.noDataValue = fileDirectory.GDAL_NODATA ? parseFloat(fileDirectory.GDAL_NODATA) : null;
        result.numberOfRasters = fileDirectory.SamplesPerPixel;
        image.readRasters({ pool: getPool() }).then((rasters) => {
          result.rasters = rasters;
          const r = rasters[0];
          if (r) {
            let i = 0;
            const bands = rasters.length;
            const d = new r.constructor(r.length * bands);
            for (; i < r.length; i++) {
              for (let j = 0; j < bands; j++) {
                d[i + j] = rasters[j][i];
              }
            }
            result.data = d;
          }
          result.metadata = image.getGDALMetadata();
          const metadata = parseMetedata(fileDirectory.ImageDescription || "");
          result.min = metadata.min;
          result.max = metadata.max;
          result.isTiff = true;
          callback(null, result);
        }).catch((err) => {
          callback(err);
        });
      }).catch((err) => {
        callback(err);
      });
    }).catch((err) => {
      callback(err);
    });
  }
  /**
   *  exif 
   * @param data
   * @param callback
   */
  parseExif(data, callback) {
    Z(data).then((res) => {
      this.arrayBuffer2Image(data, (error, image) => {
        if (error) {
          callback(error);
        } else {
          callback(null, {
            data: isImageBitmap(image) ? image : image.data,
            width: image.width,
            height: image.height,
            exif: res,
            withExif: true
          });
        }
      });
    }).catch((err) => {
      callback(err);
    });
  }
  fetch(params, callback) {
    let aborted = false;
    const r = this.requestScheduler.scheduleRequest(() => {
      const p = new Promise((resolve) => {
        const request2 = makeRequest(params, (...args) => {
          if (aborted) {
            resolve(false);
            return;
          }
          callback(...args);
          resolve(args);
        });
        p.cancel = () => {
          request2.cancel();
        };
      });
      return p;
    });
    return {
      cancel: () => {
        aborted = true;
        r.cancel();
      }
    };
  }
}
let request = null;
function getRequest(options = {}, force = false) {
  if (!request || force) {
    request = new RequestAdapter(options);
  }
  return request;
}

const registry = {};
function register(name, klass, options = {}) {
  if (registry[name])
    throw new Error(`${name} is already registered.`);
  Object.defineProperty(klass, "_classRegistryKey", {
    value: name,
    writeable: false
  });
  registry[name] = {
    klass,
    omit: options.omit || [],
    shallow: options.shallow || []
  };
}
register("Object", Object);
register("Error", Error);
register("AJAXError", AJAXError);
function serialize(input, transferables) {
  if (input === null || input === void 0 || typeof input === "boolean" || typeof input === "number" || typeof input === "string" || input instanceof Boolean || input instanceof Number || input instanceof String || input instanceof Date || input instanceof RegExp || input instanceof Blob) {
    return input;
  }
  if (isArrayBuffer(input)) {
    if (transferables) {
      transferables.push(input);
    }
    return input;
  }
  if (isImageBitmap(input)) {
    if (transferables) {
      transferables.push(input);
    }
    return input;
  }
  if (ArrayBuffer.isView(input)) {
    const view = input;
    if (transferables) {
      transferables.push(view.buffer);
    }
    return view;
  }
  if (input instanceof ImageData) {
    if (transferables) {
      transferables.push(input.data.buffer);
    }
    return input;
  }
  if (Array.isArray(input)) {
    const serialized = [];
    for (const item of input) {
      serialized.push(serialize(item, transferables));
    }
    return serialized;
  }
  if (typeof input === "object") {
    const klass = input.constructor;
    const name = klass._classRegistryKey;
    if (!name) {
      throw new Error("can't serialize object of unregistered class");
    }
    if (!registry[name])
      throw new Error(`${name} is not registered.`);
    const properties = klass.serialize ? (
      // (Temporary workaround) allow a class to provide static
      // `serialize()` and `deserialize()` methods to bypass the generic
      // approach.
      // This temporary workaround lets us use the generic serialization
      // approach for objects whose members include instances of dynamic
      // StructArray types. Once we refactor StructArray to be static,
      // we can remove this complexity.
      klass.serialize(input, transferables)
    ) : {};
    if (!klass.serialize) {
      for (const key in input) {
        if (!input.hasOwnProperty(key))
          continue;
        if (registry[name].omit.indexOf(key) >= 0)
          continue;
        const property = input[key];
        properties[key] = registry[name].shallow.indexOf(key) >= 0 ? property : serialize(property, transferables);
      }
      if (input instanceof Error) {
        properties.message = input.message;
      }
    } else if (transferables && properties === transferables[transferables.length - 1]) {
      throw new Error("statically serialized object won't survive transfer of $name property");
    }
    if (properties.$name) {
      throw new Error("$name property is reserved for worker serialization logic.");
    }
    if (name !== "Object") {
      properties.$name = name;
    }
    return properties;
  }
  throw new Error(`can't serialize object of type ${typeof input}`);
}
function deserialize(input) {
  if (input === null || input === void 0 || typeof input === "boolean" || typeof input === "number" || typeof input === "string" || input instanceof Boolean || input instanceof Number || input instanceof String || input instanceof Date || input instanceof RegExp || input instanceof Blob || isArrayBuffer(input) || isImageBitmap(input) || ArrayBuffer.isView(input) || input instanceof ImageData) {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map(deserialize);
  }
  if (typeof input === "object") {
    const name = input.$name || "Object";
    if (!registry[name]) {
      throw new Error(`can't deserialize unregistered class ${name}`);
    }
    const { klass } = registry[name];
    if (!klass) {
      throw new Error(`can't deserialize unregistered class ${name}`);
    }
    if (klass.deserialize) {
      return klass.deserialize(input);
    }
    const result = Object.create(klass.prototype);
    for (const key of Object.keys(input)) {
      if (key === "$name")
        continue;
      const value = input[key];
      result[key] = registry[name].shallow.indexOf(key) >= 0 ? value : deserialize(value);
    }
    return result;
  }
  throw new Error(`can't deserialize object of type ${typeof input}`);
}

class ThrottledInvoker {
  constructor(callback) {
    this.callback = callback;
    this.triggered = false;
    if (typeof MessageChannel !== "undefined") {
      this.channel = new MessageChannel();
      this.channel.port2.onmessage = () => {
        this.triggered = false;
        this.callback();
      };
    }
  }
  trigger() {
    if (!this.triggered) {
      this.triggered = true;
      if (this.channel) {
        this.channel.port1.postMessage(true);
      } else {
        setTimeout(() => {
          this.triggered = false;
          this.callback();
        }, 0);
      }
    }
  }
  remove() {
    this.channel = null;
    this.callback = nullFunction;
  }
}

class Actor {
  constructor(target, parent, dispatcherId) {
    this.target = target;
    this.parent = parent;
    this.id = uid("actor");
    this.dispatcherId = dispatcherId;
    this.callbacks = {};
    this.tasks = {};
    this.taskQueue = [];
    this.cancelCallbacks = {};
    this.receive = this.receive.bind(this);
    this.process = this.process.bind(this);
    this.invoker = new ThrottledInvoker(this.process);
    this.target.addEventListener("message", this.receive, false);
    this.globalScope = isWorker() ? target : window;
  }
  /**
   * Sends a message from a main-thread map to a Worker or from a Worker back to
   * a main-thread map instance.
   *
   * @param type The name of the target method to invoke or '[source-type].[source-name].name' for a method on a WorkerSource.
   * @param data
   * @param callback
   * @param targetId A particular mapId to which to send this message.
   * @param mustQueue
   * @private
   */
  send(type, data, callback, targetId, mustQueue = false) {
    const id = Math.round(Math.random() * 1e18).toString(36).substring(0, 10);
    if (callback) {
      this.callbacks[id] = callback;
    }
    const buffers = isSafari(this.globalScope) ? void 0 : [];
    this.target.postMessage(
      {
        id,
        type,
        hasCallback: !!callback,
        targetId,
        mustQueue,
        dispatcherId: this.dispatcherId,
        data: serialize(data, buffers)
      },
      buffers
    );
    return {
      cancel: () => {
        if (callback) {
          delete this.callbacks[id];
        }
        this.target.postMessage({
          id,
          type: "<cancel>",
          targetId,
          dispatcherId: this.dispatcherId
        });
      }
    };
  }
  receive(message) {
    const { data } = message;
    const { id } = data;
    if (!id) {
      return;
    }
    if (data.targetId && this.dispatcherId !== data.targetId) {
      return;
    }
    if (data.type === "<cancel>") {
      delete this.tasks[id];
      const cancel = this.cancelCallbacks[id];
      delete this.cancelCallbacks[id];
      if (cancel) {
        cancel();
      }
    } else if (isWorker() || data.mustQueue) {
      this.tasks[id] = data;
      this.taskQueue.push(id);
      this.invoker.trigger();
    } else {
      this.processTask(id, data);
    }
  }
  process() {
    if (!this.taskQueue.length) {
      return;
    }
    const id = this.taskQueue.shift();
    if (id === void 0)
      return;
    const task = this.tasks[id];
    delete this.tasks[id];
    if (this.taskQueue.length) {
      this.invoker.trigger();
    }
    if (!task) {
      return;
    }
    this.processTask(id, task);
  }
  processTask(id, task) {
    if (task.type === "<response>") {
      const callback = this.callbacks[id];
      delete this.callbacks[id];
      if (callback) {
        if (task.error) {
          callback(deserialize(task.error));
        } else {
          callback(null, deserialize(task.data));
        }
      }
    } else {
      let completed = false;
      const buffers = isSafari(this.globalScope) ? void 0 : [];
      const done = task.hasCallback ? (err, data) => {
        completed = true;
        delete this.cancelCallbacks[id];
        this.target.postMessage(
          {
            id,
            type: "<response>",
            dispatcherId: this.dispatcherId,
            error: err ? serialize(err) : null,
            data: serialize(data, buffers)
          },
          buffers
        );
      } : () => {
        completed = true;
      };
      let callback = null;
      const params = deserialize(task.data);
      if (this.parent[task.type]) {
        callback = this.parent[task.type]?.(task.dispatcherId, params, done);
      } else {
        done(new Error(`Could not find function ${task.type}`));
      }
      if (!completed && callback && callback.cancel) {
        this.cancelCallbacks[id] = callback.cancel;
      }
    }
  }
  remove() {
    this.invoker.remove();
    this.target.removeEventListener("message", this.receive, false);
  }
}

exports.Actor = Actor;
exports.RequestScheduler = RequestScheduler;
exports.ThrottledInvoker = ThrottledInvoker;
exports.asyncAll = asyncAll;
exports.getReferrer = getReferrer;
exports.getRequest = getRequest;
exports.isWorker = isWorker;
exports.nullFunction = nullFunction;
exports.register = register;
exports.uid = uid;
exports.utils = utils;

}));

define(['./shared'], (function (Actor) {
class Worker {
  constructor(self2) {
    this.cancelMap = /* @__PURE__ */ new Map();
    this.self = self2;
    this.actor = new Actor.Actor(self2, this);
    this.request = Actor.getRequest();
  }
  setReferrer(dispatcherId, referrer) {
    this.referrer = referrer;
  }
  configDeps(dispatcherId, deps, callback) {
    if (deps && Array.isArray(deps) && deps.length > 0) {
      try {
        self.importScripts(...deps);
        callback(null, true);
      } catch (e) {
        Actor.asyncAll(
          deps,
          (d, done) => {
            this.request.fetch(
              {
                url: d,
                type: "arrayBuffer"
              },
              (err, data) => {
                if (err) {
                  done(err, false);
                  return console.error(err);
                }
                const url = URL.createObjectURL(new Blob([data], { type: "application/javascript" }));
                self.importScripts(url);
                setTimeout(() => {
                  URL.revokeObjectURL(url);
                });
                done(null, true);
              }
            );
          },
          callback
        );
      }
    } else {
      callback(null, true);
    }
  }
  loadData(dispatcherId, params, callback) {
    const cancelId = params?.cancelId;
    const { cancel } = this.request.fetch(params, (err, data) => {
      this.cancelMap.delete(cancelId);
      if (err) {
        callback(err);
      } else {
        if (params?.decodeType === 0) {
          this.request.arrayBuffer2Image(data, callback);
        } else if (params?.decodeType === 1) {
          this.request.arrayBuffer2unit8(data, callback);
        } else if (params?.decodeType === 2) {
          this.request.arrayBuffer2tiff(data, callback);
        } else if (params?.decodeType === 3) {
          this.request.parseExif(data, callback);
        }
      }
    });
    this.cancelMap.set(cancelId, cancel);
  }
  cancel(dispatcherId, params, callback) {
    const cancelId = params?.cancelId;
    const c = this.cancelMap.get(cancelId);
    if (c) {
      c();
      callback(null, true);
    } else {
      callback(new Error("\u65E0\u76F8\u5173\u7684\u53EF\u53D6\u6D88\u8BF7\u6C42\uFF01"));
    }
  }
}
if (Actor.isWorker()) {
  self.worker = new Worker(self);
}

return Worker;

}));

define(['./shared'], (function (Actor) {
let u = "";
function setWorkerUrl(url) {
  u = url;
}
function getWorkerUrl() {
  return u;
}
let deps = [];
function configDeps(d) {
  deps = d;
}
function getConfigDeps() {
  return deps;
}

function workerFactory() {
  return new Worker(getWorkerUrl());
}

const PRELOAD_POOL_ID = "__wind_layer_preloaded_worker_pool__";
class WorkerPool {
  constructor() {
    this.active = {};
  }
  /**
   *  `Worker` 
   * @param id
   */
  acquire(id) {
    if (!this.workers) {
      this.workers = [];
      for (let i = 0; i < WorkerPool.workerCount; i++) {
        const worker = workerFactory();
        if (worker) {
          this.workers.push(worker);
        }
      }
    }
    this.active[id] = true;
    return this.workers.slice();
  }
  /**
   *  `Worker`
   * @param id
   */
  release(id) {
    delete this.active[id];
    if (this.numActive() === 0 && this.workers) {
      this.workers.forEach((w) => {
        w.terminate();
      });
      this.workers = null;
    }
  }
  isPreloaded() {
    return !!this.active[PRELOAD_POOL_ID];
  }
  /**
   * `Worker` 
   */
  numActive() {
    return Object.keys(this.active).length;
  }
}
const hardwareConcurrency = typeof navigator !== "undefined" && navigator.hardwareConcurrency || 4;
const availableLogicalProcessors = Math.floor(hardwareConcurrency / 2);
WorkerPool.workerCount = Math.max(Math.min(availableLogicalProcessors, 6), 1);

class Dispatcher {
  constructor(workerPool, parent, dispatcherId) {
    this.workerPool = workerPool;
    this.actors = [];
    this.currentActor = 0;
    this.id = Actor.uid("dispatcher");
    this.dispatcherId = dispatcherId;
    const workers = this.workerPool.acquire(this.dispatcherId);
    for (let i = 0; i < workers.length; i++) {
      const worker = workers[i];
      const actor = new Actor.Actor(worker, parent, this.dispatcherId);
      actor.name = `Worker ${i}`;
      this.actors.push(actor);
    }
    if (!this.actors.length)
      throw new Error("No actors found");
  }
  /**
   *  Actor
   * @param type
   * @param data
   * @param cb
   */
  broadcast(type, data, cb) {
    cb = cb || Actor.nullFunction;
    Actor.asyncAll(
      this.actors,
      (actor, done) => {
        actor.send(type, data, done);
      },
      cb
    );
  }
  send(type, data, cb, id) {
    const actor = this.getActor(id);
    if (actor) {
      actor.send(type, data, cb);
    }
  }
  /**
   *  `Actor`
   * TIP:  `Actor` 
   */
  getActor(id) {
    if (id !== void 0) {
      const index = this.actors.findIndex((a) => a.id === id);
      if (index > -1) {
        this.currentActor = index;
      } else {
        this.currentActor = (this.currentActor + 1) % this.actors.length;
      }
    } else {
      this.currentActor = (this.currentActor + 1) % this.actors.length;
    }
    return this.actors[this.currentActor];
  }
  remove(removed = true) {
    this.actors.forEach((actor) => {
      actor.remove();
    });
    this.actors = [];
    if (removed)
      this.workerPool.release(this.id);
  }
}

let globalWorkerPool;
function getGlobalWorkerPool() {
  if (!globalWorkerPool) {
    globalWorkerPool = new WorkerPool();
  }
  return globalWorkerPool;
}
function prewarm() {
  const workerPool = getGlobalWorkerPool();
  workerPool.acquire(PRELOAD_POOL_ID);
}
const exported = {
  utils: Actor.utils,
  request: Actor.getRequest,
  register: Actor.register,
  configDeps,
  getConfigDeps,
  prewarm,
  getReferrer: Actor.getReferrer,
  setWorkerUrl,
  getGlobalWorkerPool,
  Actor: Actor.Actor,
  WorkerPool,
  Dispatcher,
  RequestScheduler: Actor.RequestScheduler,
  ThrottledInvoker: Actor.ThrottledInvoker
};

return exported;

}));

// eslint-disable-next-line no-undef
var wgw$1 = wgw;

return wgw$1;

}));
//# sourceMappingURL=index.js.map
